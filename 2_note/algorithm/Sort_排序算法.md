# Sort / 排序算法

---

## 基础部分

---

### Arrays.sort ()

Arrays.sort () 调用的 sort 方式被定义在 java.util.DualPivotQuicksort 中，这个类名翻译过来就是双轴快速排序。

底层实现比较复杂，不仅用到了双轴快排，还用到了插入排序，双插入排序，还借鉴了 Tim 排序的思想（二分插入排序和归并）。

---

## 通用排序算法

---

### 归并排序

先把大小为一的两个数组，归并成大小为二的有序数组，

然后再把它和相邻的大小为二的有序数组进行归并，得到大小为四的有序数组。依次类推，归并整个数组。

由于归并两个有序数组，只需要用双指针进行比较和合并，整个归并的过程很快。

递归式归并排序

非递归式归并排序

### 快速排序

快排需要使用递归，并且实现的方式不直观。和归并一样也是属于分治。

选择一个中轴元素，即把小于中轴的元素放左边，大于中轴的元素放右边。

然后在中轴左边和右边继续选中轴，递归到数组的大小为一，无法再选出中轴。

### 插入排序

类似于斗地主里面的扑克手牌，洗牌完成的那一刻，三个的手牌就确定了（叫地主除外），发牌分牌的过程本质上就是插入排序。

从第二个数的下标开始，和第一个数比较，如果比第一个数小，则插到第一个数的前面，然后继续查第三个数；

如果第三个数数比第二个数大，则继续查第四个数；如果四个数比第三个数小，则要插到第三个数前面。

### 希尔排序

插入排序的变种。

插入排序的问题就是位移的次数太多了，虽然对人来说很直观，但是效率不高。

希尔排序就是按一定的步长（数组长度 / 2），把数组分成多个组，组里元素不再相邻，然后在组里做插入排序。

完成之后把步长改为（数组长度 / 4），然后再分组做插入排序。

直到步长等于一，插入排序之后就得到了一个有序的数组。

### 堆排序

维护一个大顶堆，每次大顶堆完成重排之后，取出最大的那个数，也就是完全二叉树的根，放到另一个数组；

然后再重排，直到堆的数被全部移至数组中，此时的数组是个从大到小的有序数组。

### 选择排序

从头开始，找出最小的数放在下标为零的位置，然后继续找第二小的数，放在下标为一的位置。

### 冒泡排序

从头开始，相邻的两个数比较，右边的数大于等于左边，则往另一端挪动一个下标；

右边的数小于左边，则交换两个数位置，再继续挪动下标。

非优化版本：

优化版本：




---

## 非通用排序算法

---

### 桶排序

每个桶都是一个区间，区间里选择归并或者快排。

所有桶按顺序合并起来，就是一个有序的数组。

桶排序的前提：要知道最大值和最小值，不然没法确定区间。

### 计数排序

把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数。

再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。

计数排序的前提：适合最大值和最小值的差值不是不是很大的排序。

非优化版本

优化版本

### 基数排序

先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小。

排到最后，就是一组有序的元素了。

在以某位数进行排序的时候，是用”桶“来排序的。

基数排序的前提：排序对象是数字。

---

## 提高部分

---

###

---











---

参考链接：

- [Java8 中 Arrays.sort () 排序分析](https://blog.csdn.net/realYuzhou/article/details/109299625)
- [十大排序算法](https://leetcode-cn.com/circle/article/0akb5U/)
- []()
- []()

---











