# Data Structure / 数据结构

---

## Content / 目录

---

- [一、基础部分](#基础部分)
    - [01、什么是数据结构](#什么是数据结构)
    - [02、数据之间的关系](#数据之间的关系)
    - [03、算法的定义](#算法的定义)
    - [04、算法的数学基础](#算法的数学基础)
    - [05、算法的复杂度函数](#算法的复杂度函数)
    - [06、Hash 算法](#Hash-算法)
    - [07、树结构](#树结构)
    - [08、二叉搜索树](#二叉搜索树)
- [二、线性数据结构](#线性数据结构)
    - [01、HashMap](#HashMap)
    - [02、Bloom Filter](#Bloom Filter)
    - [03、SkipList](#SkipList)
    - [04、AVL Tree](#AVL Tree)
    - [05、Red Black Tree](#Red Black Tree)
    - [06、B-Tree](#B-Tree)
    - [07、B+Tree](#B+Tree)
    - [08、HashTree](#HashTree)

---

## 基础部分

---

### 什么是数据结构

**数据**：信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号的总称。

**数据结构**：数据元素和数据元素之间的相互关系或数据的组织形式。

**数据元素**：数据的的基本单位，数据元素有若干基本项组成。

### 数据之间的关系

**逻辑关系：**

> 表示数据之间的抽象关系，按每个元素可能具有的前趋数和直接后继数将逻辑结构分为线性结构和非线性结构。

逻辑关系或逻辑结构有如下特点：

> 只是描述数据结构中数据元素之间的联系规律；
>
> 是从具体问题中抽象出来的数学模型，是独立于计算机存储器的（与硬件无关）

逻辑结构的分类如下：

> 线性结构
>
> 树形结构
>
> 图状结构
>
> 其他结构

**物理关系：**

> 逻辑关系在计算中的具体实现方法，分为顺序存储方法、链式存储方法、索引存储方法、散列存储方法。

物理关系或物理结构有如下特点：

> 是数据的逻辑结构在计算机存储其中的映像；
>
> 存储结构是通过计算机程序来实现，因而是依赖于具体的计算机语言的；

物理结构分类如下：

> 顺序结构
>
> 链式结构
>
> 索引结构

### 算法的定义

**算法**：是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。

> 对于一个问题，一旦某种算法给定并且被确定是正确的，那么重要的一步就是确定该算法将需要多少诸如时间或空间等资源量的问题。
>
> 如果一个问题的求解算法竟然需要长达一年时间，那么这种算法就很难能有什么用处。
>
> 同样，一个需要若干个 GB 的内存的算法在当前的大多数机器上也是无法使用的。

### 算法的数学基础

**在用大 O 表示法的时候，要保留高阶次幂，丢弃常数项和低阶次幂。**

常见的已知函数结果：

| | |
|:---:|:---|
| c | 常数函数 |
| logN | 对数函数 |
| logN^2 | 对数平方函数 |
| N | 线性函数 |
| NlogN | 线性函数 |
| N^2 | 二次函数 |
| N^3 | 三次函数 |
| 2^N | 指数函数 |

### 算法的复杂度函数

复杂度函数包含如下两种：

> 时间复杂度
>
> 空间复杂度

**正常情况下，时间复杂度的单位基本上是以一次内存访问或者一次 IO 来决定。**

**空间复杂度是指在算法执行过程中需要占用的存储空间。**

对于一个算法来说，时间复杂度和空间复杂度往往是相互影响，当追求一个好的时间复杂度时，可能会使空间复杂度变差，即可能占用更多的存储空间；

反之，当追求一个较好的空间复杂度时，可能会使时间复杂度变差，即可能占用较长的运算时间。

### Hash 算法

常见的 Hash 算法：

> MD4：消息摘要算法；
>
> **MD5**：消息摘要算法，MD4 的升级版本；
>
> SHA-1：SHA-1 的设计和 MD4 相同原理，并模仿该算法；
>
> 自定义 HASH 算法：程序设计者可以自定义 HASH 算法，比如 java 中重写的 hashCode () 方法。

解决 **Hash 碰撞**常见的方法：

> 分离链接法（链表法）：做法是将散列到同一个值的所有元素保留在一个表中，例如 JDK 中的 HashMap；
>
> 探测散列表：当发生 Hash 碰撞时，尝试寻找另外一个单元格，直到知道到空的单元为止。包括：线性探测法，平方探测法，双散列。

### 树结构

树的递归定义：

> 一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由根节点 root 以及 0 个或多个非空的子树组成，这些子树中每一棵的根都被来自根 root 的一条有向的边所连接；

**树叶节点**：没有儿子节点称为树叶；

**深度**：对于任意节点 ni，ni 的深度为从根到 ni 的唯一路径的长；

**高度**：对于任意节点 ni，ni 的高度为从 ni 到一片树叶的最长路径的长；

树的遍历：树的遍历分为两种，先序遍历和后续遍历。

### 二叉搜索树

二叉搜索树是一棵二叉树，其中每个节点都不能有多于两个子节点。

对于二叉查找树的每一个节点 X，它的左子树中所有项的值都小于 X 节点中的项，而它的右子树中所有项的值大于 X 中的项。

---

## 线性数据结构

---

### HashMap

HashMap / 哈希散列：开发中最常用的数据结构之一，数据常驻于内存中，对于小的数据量来说，HashMap 的增删改查的效率都非常高，复杂度接近于 O(1)。

具体结构和算法：

> HashMap 由一个 hash 函数和一个数组组成；
>
> 数据插入，当 <key,value> 进入到 map 的时候，根据 hash (key) 找到对应点位置。如果位置为空，直接保存；如果位置不为空，则使用链表的方式处理。为了解决遍历链表所增加的时间，JDK 中的链表在大小增大到 8 时，将会演变成红黑树以降低时间复杂度。
>
> 为什么开始使用链表，后面使用红黑树：
>
> > 数据量较小的时候，链表的查询效率相对来说也比较高，使用红黑树占用空间比链表要大；
> >
> > 为什么选择 8，请参考泊松分布；
>
> 查找和删除的过程，同插入的过程类似。
>
> HashMap 可以支持自动扩容，扩容机制需要看具体的实现。

优点：

> 动态可变长存储数据，快速的查询速度，查询复杂度接近 O(1);

缺点：

> 只支持小数据量的内存查询；

使用场景：

> 在内存中小数据量的数据保存和快速查找。

### Bloom Filter

视频讲解：[学习布隆过滤器](https://www.bilibili.com/video/BV19i4y1u7rV)

Bloom Filter / 布隆过滤器：

> 布隆过滤器的输出为否定的结果一定为真；
>
> 布隆过滤器的输出为肯定的结果不一定为真。

布隆过滤器算法为大数据量的查找提供了快速的方法，时间复杂度为 O(k)。

具体结构和算法：

> 布隆过滤器包含 k 个 hash 函数，每个函数可以把 key 散列成一个整数（下标）；
>
> 布隆过滤器包含了一个长度为 n 的 bit 数组（向量数组），每个 bit 的初始值为 0；
>
> 当某个 key 加入的时候，用 k 个 hash 函数计算出 k 个散列值，并把数组中对应的比特置为 1；
>
> 判断某个 key 是否在集合时，用 k 个 hash 函数算出 k 个值，并查询数组中对应的比特位，如果所有的 bit 位都为 1，认为在集合中；
>
> 布隆过滤器的大小需要提前评估，并且不能扩容；

布隆过滤器的插入过程：

> 判断某个 key 是否在集合时，用 k 个 hash 函数算出 k 个值，并查询数组中对应的比特位，如果所有的 bit 位都为 1，认为在集合中

特点：

> 布隆过滤器无法删除数据；
>
> 布隆过滤器查询的时间复杂度为 O(k)；
>
> 布隆过滤器空间的占用在初始化的时候已经固定不能扩容。

优点：

> 布隆过滤器在时间和空间上都有巨大的优势。布隆过滤器存储空间和插入 / 查找时间都是常数。布隆过滤器不需要存储数据本身，节省空间。

缺点：

> 布隆过滤器的缺点是有误差。元素越多误差越高。可以通过提高 hash 函数的个数和扩大 bit 数组的长度来降低误差率；

场景：

> 使用场景：缓存击穿，判断有无。

### SkipList

SkipList / 跳表：

是一种特殊的链表，相比一般的链表有更高的查找效率，可比拟二差查找树，平均期望的插入，查找，删除的时间复杂度都是 O (logN)。

具体结构和算法：

> 跳表可视为水平排列（Level）、垂直排列（Row）的位置（Position）的二维集合。每个 Level 是一个列表 Si，每个 Row 包含存储连续列表中相同 Entry 的位置，跳表的各个位置可以通过以下方式进行遍历。

- After (P)：返回和 P 在同一 Level 的后面的一个位置，若不存在则返回 NULL；
- Before (P)：返回和 P 在同一 Level 的前面的一个位置，若不存在则返回 NULL；
- Below (P)：返回和 P 在同一 Row 的下面的一个位置，若不存在则返回 NULL；
- Above (P)：返回和 P 在同一 Row 的上面的一个位置，若不存在则返回 NULL。

> 有顺序关系的多个 Entry (K,V) 集合 M 可以由跳表实现，跳表 S 由一系列列表 {S0，S1，S2，......，Sh} 组成，其中 h 代表的跳表的高度。每个列表 Si 按照 Key 顺序存储 M 项的子集，此外 S 中的列表满足如下要求：

- 列表 S0 中包含了集合 M 的每个一个 Entry；
- 对于 i = 1 ，...... ，h-1 列表 Si 包含列表 Si-1 中 Entry 的随机子集；

> Si 中的 Entry 是从 Si-1 中的 Entry 集合中随机选择的，对于 Si-1 中的每一个 Entry，以 1/2 的概率来决定是否需要拷贝到 Si 中，我们期望 S1 有大约 n/2 个 Entry，S2 中有大约 n/4 个 Entry，Si 中有 n/2^i。跳表的高度 h 大约是 logn。从一个列表到下一个列表的 Entry 数减半并不是跳表的强制要求；

插入的过程描述，以插入 Entry58 为例：

> 找到底层列表 S0 中 55 的位置，在其后插入 Entry58；
>
> 假设随机函数取值为 1，紧着回到 20 的位置，在其后插入 58，并和底层列表 S0 的 Entry58 链接起来形成 Entry58 的 Row；
>
> 假设随机函数取值为 0，则插入过程终止；

删除过程：同查找过程。

时间复杂度：

> 查找包括两个循环，外层循环是从上层 Level 到底层 Level，内层循环是在同一个 Level，从左到右；
>
> 跳表的高度大概率为 O(logn)，所以外层循环的次数大概率为 O(logn);
>
> 在上层查找比对过的 key，不会再下层再次查找比对，任意一个 key 被查找比对的概率为 1/2，因此内存循环比对的期望次数是 2 也就是 O(1);
>
> 因此最终的时间复杂度函数 O(n) = O(1)*O(logn) 也就是 O(logn)；

空间复杂度：

> Level i 期望的元素个数为 n/2^i；
>
> 跳表中所有的 Entry（包含同一个 Entry 的 Row 中的元素） Σn/2^i = nΣ1/2^i，其中有级数公式得到 Σ1/2^i < 2；
>
> 期望的列表空间为 O(n)；

优点：快速查找，算法实现简单；

缺点：跳表在链表的基础上增加了多级索引以提升查询效率，使用空间来换取时间，必然会增加存储的负担。

使用场景：

许多开源的软件都在使用跳表。

> Redis 中的有序集合 zset；
>
> LevelDB Hbase 中的 memtable；
>
> Lucene 中的 Posting List。

### AVL Tree

AVL Tree / AVL 树：

是带有平衡条件的二叉查找树，这个平衡条件必须要容易保持，而且它保证树的深度必须是 O (logN)。在 AVL 树中任何节点的两个子树的高度最大差别为 1。

AVL 树本质上还是一棵二叉查找树，有以下特点：

> AVL 首先是一棵二叉搜索树；
>
> 带有平衡条件：每个节点的左右子树的高度之差的绝对值最多为 1；
>
> 当插入节点或者删除节点时，树的结构发生变化导致破坏特点二时，就要进行旋转保证树的平衡。

针对旋转做详细分析如下：

> 把必须重新平衡的节点叫做 a，由于任意节点最多有两个儿子，因此出现高度不平衡就需要 a 点的两棵子树的高度差 2。可以看出，这种不平衡可能出现一下四种情况：

- 对 a 的左儿子的左子树进行一次插入；
- 对 a 的左儿子的右子树进行一次插入；
- 对 a 的右儿子的左子树进行一次插入；
- 对 a 的右儿子的柚子树进行一次插入。

> 情形 1 和 4 是关于 a 的对称，而 2 和 3 是关于 a 点的对称。因此理论上解决两种情况。
>
> 第一种情况是插入发生在外侧的情况，该情况通过对树的一次单旋转而完成调整。
>
> 第二种情况是插入发生在内侧的情况，这种情况通过稍微复杂些的双旋转来处理。

优点：使用二叉查找算法时间复杂度为 O(logN)，结构清晰简单；

缺点：插入和删除都需要进行再平衡，浪费 CPU 资源；

使用场景：少量数据的查找和保存；

### Red Black Tree

视频讲解：[什么是红黑树，据说红黑树很难理解，看动画 5 分钟就弄明白原理](https://www.bilibili.com/video/BV1zU4y1H77f)

Red Black Tree / 红黑树：

是一种自平衡的二叉查找树，是 2-3-4 树的一种等同，它可以在 O (logN) 内做查找，插入和删除。

在 AVL 的基础之上，红黑树又增加了如下特点：

> 每个节点或者是红色，或者是黑色；
>
> 根节点是黑色；
>
> 如果一个节点时红色的，那么它的子节点必须是黑色的；
>
> 从一个节点到一个 null 引用的每一条路径必须包含相同数目的黑色节点。

那么将一个节点插入到红黑树中，需要执行哪些步骤呢？

> 将红黑树当做一棵二叉搜索树，将节点插入；
>
> 将插入的节点着色为红色；
>
> 通过一系列的旋转和着色等操作，使之重新成为一棵红黑树。

在第二步中，被插入的节点被着为红色之后，他会违背哪些特性呢
>
> 对于特性 1，显然是不会违背；
>
> 对于特性 2，显然也是不会违背；
>
> 对于特性 4，显然也是不会违背；
>
> 对于特性 3，有可能会违背，我们将情况描述如下：
>
> > 被插入的节点是根节点：直接把此节点涂为黑色；
> >
> > 被插入的节点的父节点是黑色：什么也不需要做。节点被插入后，仍然是红黑树；
> >
> > 被插入的节点的父节点是红色：此种情况下与特性 3 违背，所以将情况分析如下：
> >
> > > 当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点也是红色。处理策略为：将父节点置为黑色、将叔叔节点置为黑色、将祖父节点置为红色；
> > >
> > > 当前节点的父节点是红色，叔叔节点时黑色，且当前节点是其父节点的右子节点。将父节点作为新的当前节点、以新的当前节点作为支点进行左旋；
> > >
> > > 当前节点的父节点是红色，叔叔节点时黑色，且当前节点时父节点的左子节点。将父节点置为黑色、将祖父节点置为红色、以祖父节点为支点进行右旋。

定理：一棵含有 n 个节点的红黑树的高度至多为 2log(N+1)，证明过程请查看参考资料。

由此定理可推论：**红黑树的时间复杂度为 log(N)。**

优点：查询效率高，插入和删除的失衡的代销比 AVL 要小很多。

缺点：红黑树不追求完全平衡。

使用场景：

> 红黑树的应用很广泛，主要用来存储有序的数据，时间复杂度为 log(N)，效率非常高。例如 java 中的 TreeSet、TreeMap、HashMap 等。

### B-Tree

一棵 m 阶 B-Tree 的特性：

> 每个节点最多有 m 个子节点；
>
> 除了根节点和叶子结点外，其他每个节点至少有 m/2 个子节点；
>
> 若根节点不是叶子节点，则至少有两个子节点；
>
> 所有的叶子结点都是同一深度；
>
> 每个非叶子节点都包含 n 个关键字
>
> 关键字的个数的关系为 m/2-1 < n < m-1

B-Tree 很适合作为搜索来使用，但是 B-Tree 有一个缺点就是针对范围查找支持的不太友好，所以才有了 B+Tree。

### B+Tree

B+Tree / B+ 树：

提起 B+Tree 都会想到大名鼎鼎的 MySql 的 InnoDB 引擎，该引擎使用的数据结构就是 B+Tree。

B+Tree 是 B-Tree（平衡多路查找树）的一种改良，使得更适合实现存储索引结构，也是该篇分享中唯一一个与磁盘有关系的数据结构。

首先我们先了解一下磁盘的相关东西。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位，位于同一块磁盘块中的数据会被一次性读取出来。InnoDB
存储引擎中有页（Page）的概念，页是引擎管理磁盘的基本单位。

B+Tree 的特性在 B-Tree 的基础上又增加了如下几点：

> 非叶子节点只存储键值信息；
>
> 所有的叶子节点之间都有一个链指针（方便范围查找）；
>
> 数据记录都存放在叶子节点中；

这样的数据结构可以进行两种运算，一种是针对主键的范围查找和分页查找，另外一种是从根节点开始，进行随机查找。

优点：

> 利用磁盘可以存储大量的数据，简单的表结构在深度为 3 的 B+Tree 上可以保存大概上亿条数据；B+Tree 的深度大概也就是 2~4，深度少就意味这 IO 会减少；B+Tree 的时间复杂度 log(m)N

缺点：

> 插入或者删除数据有可能会导致数据页分裂；即使主键是递增的也无法避免随机写，这点 LSM-Tree 很好的解决了；无法支持全文索引；

使用场景：

> 使用场景大多数数据库的引擎，例如 MySql,MongoDB 等。

### HashTree

HashTree / 哈希树：

是一种特殊的树状结构，根据质数分辨定理，树每层的个数为 1、2、3、5、7、11、13、17、19、23、29.....

具体结构和算法：

> 从 2 起的连续质数，连续 10 个质数接可以分辨大约 6464693230 个数，而按照目前 CPU 的计算水平，100 次取余的整数除法操作几乎不算什么难事。
>
> 我们选择质数分辨算法来构建一颗哈希树。选择从 2 开始的连续质数来构建一个 10 层的哈希树。第一层节点为根节点，根节点先有 2 个节点，第二层的每个节点包含 3 个子节点；以此类推，即每层节点的数据都是连续的质数。对质数进行取余操作得到的数据决定了处理的路径。
>
> HashTree 的节点查找过程和节点插入过程类似，就是对关键字用质数取余，根据余数确定下一节点的分叉路径，知道找到目标节点。如上图，在从对象中查找所匹配的对象，比较次数不超过 10 次，也就是说时间复杂度最多是 o (1).
>
> 删除的过程和查找类似。

优点：结构简单，查找迅速，结构不变。

缺点：非有序性。


---

##

---

###

---








---

参考链接：

- [搜索中常见数据结构与算法探究（一）](https://mp.weixin.qq.com/s/5O4qDVP48jI5AFYGnAfKEw)
- []()

---




















