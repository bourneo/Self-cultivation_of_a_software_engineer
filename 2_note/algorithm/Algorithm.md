# Algorithm / 算法

---

## Content / 目录

---

- [一、基础部分](#基础部分)
    - [01、堆排序](#堆排序)
    - [02、双堆法](#双堆法)
    - [03、分治法](#分治法)
    - [04、位图法](#位图法)
    - [05、HashMap 法](#HashMap-法)
    - [06、前缀树法](#前缀树法)
    - [07、查表法](#查表法)
- [二、动态规划](#动态规划)
    - [01、斐波那契数列](#斐波那契数列)
    - [](#)

---

## 基础部分

---

### 堆排序

**堆顶：**

堆是一种非线性结构，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组。

**大顶堆**：每个结点的值都大于或等于其左右孩子结点的值。

**小顶堆**：每个结点的值都小于或等于其左右孩子结点的值。

题目描述：

_有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？_

解题思路：

**对于 TopK 问题，最常用的方法是使用堆排序。**

具体过程：

> 首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。
>
> 接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。
>
> 重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。
>
> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

解题代码：👉 [HeapSort.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/HeapSort.java
) 👈

### 双堆法

题目描述：

_从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。_

解题思路：

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法：双堆法。

具体过程：

> 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。
>
> 若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。

解题代码：👉 [TwoHeap.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/TwoHeap.java
) 👈

### 分治法

题目描述：

_有个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词 (Top 100)。_

解题思路：

**分而治之，进行哈希取余；使用 HashMap 统计频数；求解 最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。**

具体过程：

> 首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB
> 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。
>
> 接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map
> 中不存在，则执行 map.put(x, 1)；若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。
>
> 上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为
> 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

### 位图法

**位图：**

用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

**位图通过位数组来表示某些元素是否存在，它可以用于快速查找，判重，排序等。**

题目描述：

_在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。_

解题思路：

**判断数字是否重复的问题，位图法是一种非常高效的方法。对于整数相关的算法的求解，位图法是一种非常实用的算法。**

具体过程：

> 我们用 2 个 bit 来表示各个数字的状态。00 表示这个数字没出现过；01 表示这个数字出现过一次（即为题目所找的不重复整数）；10 表示这个数字出现了多次。
>
> 那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。
>
> 假设内存满足位图法需求，进行下面的操作：遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。
>
> 遍历结束后，查看位图，把对应位是 01 的整数输出即可。

### HashMap 法

题目描述：

_假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过
1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）_

解题思路：

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4
个字节）。由此可见，1G 的内存空间完全够用。

具体过程：

> 首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。
>
> 接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。
>
> 遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。

### 前缀树法

**Trie 树 / 前缀树 / 字典树：**

**是一种空间换时间的数据结构，是一种树形结构 (字典树是一种数据结构)，典型用于统计、排序、和保存大量字符串。**

> 前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。经常被搜索引擎系统用于文本词频统计。

优点：

> 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

题目描述：

_假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过
1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）_

解题思路：

**如果这些字符串有大量相同前缀，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。**

### 查表法

题目描述：

_查询数组中有没有比它前面元素都大，比它后面的元素都小的数，没有打印 -1, 有显示其索引。_

解题思路：

**将一些事先计算好的结果，存储在常量数组中，运行时节省计算开销。**

具体过程：

> 一个数组存从左到右的最大值 max, 另一个数组存从右到左的最小值 min。




---

## 动态规划

---

### 斐波那契数列

题目描述：

_斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。_

```
F(0) = 0，F(1) =  1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

_给你 n ，请计算 F(n) 。_

解题代码：👉 [FibonacciNumber.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/FibonacciNumber.java
) 👈



---

##

---

###

---








---

参考链接：

- [10 道 BAT 大厂海量数据面试题（附题解 + 方法总结）](https://mp.weixin.qq.com/s/rjGqxUvrEqJNlo09GrT1Dw)
- [谈谈堆排序，大顶堆，小顶堆？](https://www.jianshu.com/p/15a29c0ace73)
- [位图算法：什么是 BitMap ](https://www.cnblogs.com/54chensongxia/p/11591979.html)
- [一文搞懂字典树](https://segmentfault.com/a/1190000040801084)
- []()

---




















