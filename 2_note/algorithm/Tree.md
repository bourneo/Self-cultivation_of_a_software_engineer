## Tree

---

#### 基础部分

###### 二叉树的遍历

- 深度优先遍历

1. 前序遍历 (Pre-Order Traversal)：
    - 先访问根，然后访问子树
    - Java 代码：
   ```
   if (root != null) {
      System.out.print(root.val + " ");
      recursionMiddleorderTraversal(root.left);
      recursionMiddleorderTraversal(root.right);
   }
   ```
2. 中序遍历 (In-Order Traversal)：
    - 先访问左（右）子树，然后访问根，最后访问右（左）子树
    - Java 代码：
   ```
   if (root != null) {
      recursionMiddleorderTraversal(root.left);
      System.out.print(root.val + " ");
      recursionMiddleorderTraversal(root.right);
   }
   ```
3. 后序遍历 (Post-Order Traversal)：
    - 先访问子树，然后访问根
    - Java 代码：
   ```
   if (root != null) {
      recursionMiddleorderTraversal(root.left);
      recursionMiddleorderTraversal(root.right);
      System.out.print(root.val + " ");
   }
   ```

- 广度优先遍历

1. 按层次遍历：
    - 先访问离根节点最近的节点
    - 借助队列实现
    - Java 代码：
   ```    
        if (root == null) {
			return;
		}
		LinkedList<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()) {
			TreeNode node = queue.poll();
			System.out.print(node.val+"  ");
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
   ```

###### 多叉树的遍历

- 深度优先遍历
    - 先访问根结点，后选择一子结点访问并访问该节点的子结点，持续深入后再依序访问其他子树
    - 可以用递归或栈的方式实现

###### 平衡二叉树

- 本质上是特殊的**二叉搜索树**

- 它具有二叉搜索树所有的特点，此外它有自己的特别的性质：
    1. 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
    2. 平衡二叉树的左右两个子树都是一棵平衡二叉树

- 平衡因子：
    - 节点的平衡因子 = 该节点的左子树的高度 - 该节点右子树的高度

- 旋转分类：
    1. 左旋转
    2. 右旋转
    3. 左右旋转
    4. 右左旋转

- 搜索性能：
    - 最差的情况下的也能达到O（logN）

###### 红黑树

1972 年由鲁道夫·贝尔发明，被称为"**对称二叉B树**"

特点：

- 结构复杂，但有着良好的最坏情况运行时间：它可以在 O（logN）时间内完成查找、插入和删除

红黑树约束：

1. 节点是红色或黑色
2. 根是黑色
3. **所有叶子都是黑色**
4. **所有红色节点必须有两个黑色的子节点**
5. **从任一节点到其每个叶子的所有简单路径，都包含相同数目的黑色节点**

###### 红黑树和 AVL 树的区别

1. AVL 树：
    - AVL 树是最早被发明的**自平衡二叉查找树**
    - 在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为**高度平衡树**
    - 查找、插入和删除在平均和最坏情况下的时间复杂度都是 O（logN）
    - 增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡
    - AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis
    - AVL 平衡二叉树很好的解决了，二叉搜索树在遇到有序序列性能退化为 O（N）的情况，使得在最坏情况下的搜索效率仍然能够达到 O（logN）
    - **这种优化是牺牲了插入和删除的性能换来的**
    - **AVL 树并不适合需要频繁插入和删除的场景**


2. 红黑树
    - 并不强调严格的平衡性，而是保持一定的平衡性
    - 从而使得在搜索，插入，删除的场景下均有一个不错的速度

###### B 树和 B+ 树

- B 树特点
    1. 一种自平衡树，是一般化的二叉查找树（binary search tree），一个节点可以拥有 2 个以上的子节点
    2. B 树减少定位记录时所经历的中间过程，从而加快存取速度，适用于读写相对大的数据块的存储系统
    3. 子节点数量的上界和下界依特定的实现而设置，例如，在一个 2-3 B 树（通常简称 2-3 树），每一个内部节点只能有 2 或 3 个子节点
    4. 因为子节点数量有一定的允许范围，所以 B 树不需要像其他自平衡查找树那样频繁地重新保持平衡
    5. 但是由于节点没有被完全填充，可能浪费了一些空间


- B 树定义
    1. **内部节点**（非叶子）可以拥有可变数量（数量范围预先定义）的子节点
    2. 当数据被插入或从一个节点中移除，它的子节点数量发生变化
    3. 为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离


- B+ 树特点
    1. B+ 树元素**自底向上插入**，这与二叉树恰好相反
    2. 通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，效率增加
    3. 因为子节点数量有一定的允许范围，所以 B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡
    4. 例如，在 2-3 B 树（常简称为 2-3 树）中，每个内部节点只可能有 2 或 3 个子节点
    5. 如果节点有无效数目的子节点则被当作处于违规状态


- B+ 树定义
    1. 在 B+ 树中的节点通常被表示为一组有序的元素和子指针
    2. 如果此 B+ 树的阶数是 m，则非根节点元素个树的范围为：m/2 <= k <= m-1，对于任意的结点有最多 m 个子指针
    3. 对于所有**内部节点**（也称索引结点），子指针的数目总是比元素的数目多一个
    4. **内部节点**（非叶子）可以拥有可变数量（数量范围预先定义）的子节点
    5. 内部节点不存储数据，只存储索引，数据都存储在叶子节点
    6. 所有**叶子节点**都在相同的高度上，叶结点本身按关键字大小从小到大链接，形成一个**有序链表**


- B+ 树相比 B 树的优势
    1. 单一节点存储的元素更多，使得查询的 IO 次数更少
    2. 所有的查询都要查找到**叶子节点**，查询性能是稳定的；B 树每个节点都可以查找到数据，所以不稳定
    3. 所有的**叶子节点**形成了一个**有序链表**，更加便于查找

---

#### 提高部分

######                                                                                          

---









---

参考链接：

- [树的遍历](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)
- [二叉树遍历(先序、中序、后序)](https://www.jianshu.com/p/456af5480cee)
- [二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）](https://blog.csdn.net/My_Jobs/article/details/43451187)
- [什么是平衡二叉树](https://cloud.tencent.com/developer/article/1419168)
- [红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
- [B 树](https://zh.wikipedia.org/wiki/B%E6%A0%91)
- [B+ 树](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91)
- [面试官问你B树和B+树，就把这篇文章丢给他](https://segmentfault.com/a/1190000020416577)

---











