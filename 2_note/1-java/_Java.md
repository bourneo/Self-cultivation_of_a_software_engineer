# Java-collection / Java Collection 接口

---

## 基础部分

---

### 深拷贝和浅拷贝

**深拷贝：**

**拷贝数据，相当于复制一份。**

优点是可以避免其他任务修改对象；缺点是拷贝蔓，比较占用资源。

推荐使用序列化；要序列化的类，要有一个固定版本号。

**浅拷贝：**

**只拷贝引用地址**。优点是拷贝效率高。调用对象的 clone 方法即可。

### volatile 关键字

volatile 的作用：

**1、保证变量的内存可见性**

**2、禁止指令重排序**

JMM / Java Memory Model 定义了线程和主内存之间的抽象关系：

> 线程之间的共享变量存储在主内存中，**每个线程都有一个私有的本地内存，本地内存中存储了该线程以读、写共享变量的副本。**
>
> 可能会导致线程对共享变量的修改没有即时更新到主内存，或者线程没能够即时将共享变量的最新值同步到工作内存中，从而使得线程在使用共享变量的值时，该值并不是最新的。

**指令重排序**:

一般重排序可以分为如下三种类型：

1、编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2、指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3、内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

### Comparator 和 Comparable 的不同

Comparable 更像是自然排序

Comparator 更像是定制排序

同时存在时采用 Comparator（定制排序）的规则进行比较。

对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。

而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。

###

---

## 提高部分

---

###

---

---

参考链接：

- []()
- []()
- []()

---



