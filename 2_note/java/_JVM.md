# JVM

---

## 基础部分

---

### JVM 内存模型

视频讲解：[【java】jvm 内存模型全面解析](https://www.bilibili.com/video/BV12t411u726)

JVM 内存模型共分为 5 个区：堆、元空间（方法区）、Java 虚拟机栈、本地方法栈、程序计数器。

各个区各自的作用：

> 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。用于字符串常量池，对象。
>
> 元空间（方法区）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。
>
> Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象）
>
> 本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由 native 修饰，由 C 语言实现。
>
> **程序计数器**：它是一块很小的内存空间，**主要用来记录各个线程执行的字节码的地址**，例如，分支、循环、线程恢复等都依赖于计数器。

线程私有：Java 虚拟机栈、本地方法栈、程序计数器。

> 每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存

线程全局共享的：堆、元空间。

栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的。

### JVM 内存模型概览

堆：

> 包括：字符串常量池，对象。

元空间（方法区）：

> 包括：方法、静态文件、类加载器、运行时常量池、静态常量池。

虚拟机栈：

> 存储的是对象名及其引用，即堆中的内存地址。包括：局部变量表、操作数栈、方法出口、动态链接等。

本地方法栈：

> 一个 java 调用非 java 代码的接口。

程序计数器：

> 记录各线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。

### JVM 堆空间模型

新生代：

> 使用复制清理算法。
>
> 分为两个存活区和一个伊甸区；
>
> 伊甸区比两个存活区大很多，约是八倍，因为产生的多但是幸存的少。
>
> 复制是的具体过程：从伊甸区复制到一个存活区 s1，然后清理伊甸区和另一个存活区 s2 的空间，下一轮就是伊甸区复制到 s2，依次循环。

老年代：

> 使用标记清理算法。

### JVM 垃圾回收原理

视频讲解：[老 k 动画 - jvm 垃圾回收原理](https://www.bilibili.com/video/BV1W44y1477T)

### JVM 垃圾回收算法

视频讲解：[【java】10 分钟，了解 GC 过程](https://www.bilibili.com/video/BV1dt411u7wi)

垃圾回收的判断标准：

> 是否被 GCRoot 直接引用或间接引用。

**四种垃圾回收算法**：

> 标记清理算法：缺点是由碎片。
>
> 标记整理算法：缺点是代价大。
>
> 复制算法：缺点是需要两倍内存。
>
> 分代回收算法。

### JVM 垃圾收集器

视频讲解：[【java】垃圾收集器 | g1 收集器](https://www.bilibili.com/video/BV13J411g7A1)

历代垃圾收集器：

| # | 新生代 | 老年代 | 新生代和老年代收集器 |
|:---|:---|:---|:---|
| 01 | Serial（单线程） | Serial Old（单线程） |  |
| 02 | ParNew | CMS（最短回收停顿时间） |  |
| 03 | Parallel Scavenge（吞吐量优先） | Parallel Old（注重吞吐量） | G1 |

**Garbage-First / G1 收集器：**

G1 收集器是一款面向服务端应用的垃圾收集器，目前是 JDK9 的默认垃圾收集器。

是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

G1 特点：

> 并行与并发。G1 能充分利用多 CPU，多核环境下的硬件优势。
>
> 分代收集。能够采用不同的方式去处理新创建的对象和已经存活了一段时间的对象，不需要与其他收集器进行合作。
>
> 空间整合。G1 从整体上来看基于 “标记 - 整理” 算法实现的收集器，从局部上看是基于复制算法实现的，因此 G1 运行期间不会产生空间碎片。
>
> 可预测的停顿。G1 能建立可预测的时间停顿模型，能让使用者明确指定一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

G1 适用场景：

> 要求尽可能可控 GC 停顿时间；内存占用较大的应用。
>
> 可以用 -XX:+UseG1GC 使用 G1 收集器

### 老年代的空间分配担保

**空间分配担保：**

> 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，
>
> 如果大于，则此次 Minor GC 是安全的。

为什么要进行空间担保：

因为新生代采用复制收集算法，假如大量对象在 Minor GC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，把
Survivor 无法容纳的对象放到老年代。

老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。

使用这个平均值与老年代剩余空间进行比较，来决定是否进行 Full GC 来让老年代腾出更多空间。

### 类加载

JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。

自定义加载器，必须继承 ClassLoader。

### 类的初始化步骤

如果这个类还没有被加载和链接，那先进行加载和链接；

假如这个类存在直接父类，并且这个类还没有被初始化 (注意：在一个类加载器中，类只能初始化一次)，那就初始化直接的父类 (不适用于接口)；

加入类中存在初始化语句 (如 static 变量和 static 块)，那就依次执行这些初始化语句。

### 双亲委派机制

当某个类加载器需要加载某个.class 文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

作用：

1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。

2、保证核心.class 不能被篡改。

    通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class 对象了。
    不同的加载器加载同一个.class 也不是同一个 Class 对象。这样保证了 Class 执行安全。

### JVM 性能调优

1、监控 GC 的状态

2、生成堆的 dump 文件

3、分析 dump 文件：Eclipse 的静态内存分析工具

4、判断是否需要优化

    如果满足下面的指标，则一般不需要进行 GC：

        Minor GC 执行时间不到 50ms；
        Minor GC 执行不频繁，约 10 秒一次；
        Full GC 执行时间不到 1s；
        Full GC 执行频率不算频繁，不低于 10 分钟 1 次； 

5、调整 GC 类型和内存分配

### JVM 调优参数

在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。

### JVM 内存调优

减少 GC 的频率和 Full GC 的次数。

增大年轻代的内存，即调整 Xmn 的大小为 2048m，让 JVM 几乎不发生 Full GC。

###

###

###

###

###

---

## 应用

---

### JVM 指令与工具：jstat/jstack/jmap/jconsole/jps/visualVM

视频讲解：[【java】jvm 指令与工具 jstat/jstack/jmap/jconsole/jps/visualVM](https://www.bilibili.com/video/BV1QJ411P78Q)

jmap：

> 查看内存或者 dump 内存详情的工具，排查内存泄露的利器。
>
> dump 内存信息保存为文件：jmap -dump:file=a pid
>
> 打印堆栈信息：jmap -heap pid
>
> OOM 时自动执行 dump：-XX:+HeapDumpOnOutOfMemoryError

jps：

> 进程分析。
>
> 命令：jps

jstat：

> 内存分析。
>
> 例如：jstat -gcutil pid interval，堆内存的使用百分比。
>
> 例如：jstat -gc pid，堆内存占用。

jstack：

> 线程分析。
>
> 例如：jstack pid，查看堆栈信息。

jconsole：

> 可视化界面：内存、线程、类、VM 概要，MBean 等信息。

**visualVM：**

> Java 8 之后的版本不再内置 visualVM。

---

## 提高部分

---

### Class文件结构

### 字段方法名长度

### 常量池计数器

### 类索引查找全限定类名过程

### 类中常量(final static String)在字节码中的存储方式

### 方法中代码在字节码中的存储方式(方法表Code属性,JVM字节码指令)

### 类加载子系统

### JVM类加载流程

### 双亲委派模型

### 双亲委派模型的优点

### 数组加载

### 链接阶段

### 初始化阶段

### JVM执行类初始化的场景(有且只有6类)

### 运行时数据区

### 运行时数据区包括什么

### 程序计数器

### 方法区

### 运行时常量池与Class文件中的常量池有何区别

### 堆

### 64位JVM在new Object()操作时,对象实例占多少个字节

### 对象如何被线程访问定位

### 虚拟机栈与本地方法栈

### 栈帧(结构, 作用)

---

参考链接：

- [7 种垃圾回收器特点，优劣及使用场景](https://www.jianshu.com/p/5b2721b891c0)
- [【JVM】空间分配担保机制](https://www.cnblogs.com/july-sunny/p/12618054.html)
- [G1 回收器](https://blog.csdn.net/m0_37989980/article/details/112794928)
- [JVM - 各版本默认垃圾收集器](https://juejin.cn/post/7001406102621388831)
- [基于 JDK1.8 的 JVM 内存结构【JVM 篇三】](https://www.cnblogs.com/yichunguo/p/12007038.html)
- [解析 Java 类加载机制](https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html)
- [java 的双亲委派模式了解么](https://blog.csdn.net/qq_27828675/article/details/109514389)
- [JVM 性能调优](https://blog.csdn.net/zhan_lang/article/details/88567569)
- [JVM 调优案例详解](https://blog.csdn.net/m0_67393827/article/details/124288488)
- []()
- []()
- []()

---

















