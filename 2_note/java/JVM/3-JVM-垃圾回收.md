# JVM

---

## 基础部分

---

### JVM 垃圾回收原理

视频讲解：[老 k 动画 - jvm 垃圾回收原理](https://www.bilibili.com/video/BV1W44y1477T)

### JVM 垃圾回收算法

视频讲解：[【java】10 分钟，了解 GC 过程](https://www.bilibili.com/video/BV1dt411u7wi)

垃圾回收的判断标准：

> 是否被 GCRoot 直接引用或间接引用。

**四种垃圾回收算法**：

> 标记清理算法：缺点是有碎片。
>
> 标记整理算法：缺点是代价大。
>
> 复制算法：缺点是需要两倍内存。
>
> 分代回收算法。

### JVM 垃圾收集器

视频讲解：[【java】垃圾收集器 | g1 收集器](https://www.bilibili.com/video/BV13J411g7A1)

历代垃圾收集器：

| # | 新生代 | 老年代 | 新生代和老年代收集器 |
|:---|:---|:---|:---|
| 01 | Serial（单线程） | Serial Old（单线程） |  |
| 02 | ParNew | CMS（最短回收停顿时间） |  |
| 03 | Parallel Scavenge（吞吐量优先） | Parallel Old（注重吞吐量） | G1 |

**Garbage-First / G1 收集器：**

G1 收集器是一款面向服务端应用的垃圾收集器，目前是 JDK9 的默认垃圾收集器。

是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

G1 特点：

> 并行与并发。G1 能充分利用多 CPU，多核环境下的硬件优势。
>
> 分代收集。能够采用不同的方式去处理新创建的对象和已经存活了一段时间的对象，不需要与其他收集器进行合作。
>
> 空间整合。G1 从整体上来看基于 “标记 - 整理” 算法实现的收集器，从局部上看是基于复制算法实现的，因此 G1 运行期间不会产生空间碎片。
>
> 可预测的停顿。G1 能建立可预测的时间停顿模型，能让使用者明确指定一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

G1 适用场景：

> 要求尽可能可控 GC 停顿时间；内存占用较大的应用。
>
> 可以用 -XX:+UseG1GC 使用 G1 收集器

---

## 提高部分

---

### G1 / Garbage First

新生代和老年代收集器，不需要与其他收集器进行合作

并行与并发好，充分利用多 CPU，多核环境下的硬件优势

空间碎片少，整体上基于标记整理算法，局部上基于复制算法

### G1 的 Mixed GC 模式

### G1 的 Region 堆内存布局

把连续的 Java 堆划分为多个大小相等的独立区域（Region）

每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间

G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的，而是一系列区域（不需要连续）动态集合

### G1 的可预测的停顿时间模型

使用 Region 划分内存空间，以及具有优先级的区域回收方式，能在有限的时间内获取尽可能高的收集效率

它将 Region 作为单次回收的最小单元，每次收集到的内存空间都是 Region 大小的整数倍，可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集

让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，

每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些 Region

### 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行

CMS 收集器采用增量更新算法实现

G1 收集器则是通过原始快照（SATB）算法来实现的

### G1 收集器垃圾回收的步骤

·初始标记（Initial Marking）：

仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下 一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而
且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

·并发标记（Concurrent Marking）：

从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图， 找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB
记录下的在并发时有引用变动的对象。

·最终标记（Final Marking）：

对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少 量的SATB记录。

·筛选回收（Live Data Counting and Evacuation）：

负责更新Region的统计数据，对各个Region的回收价值和成 本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决
定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉 及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。

###






