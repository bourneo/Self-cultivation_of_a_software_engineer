# JVM

---

## 内存模型

---

### JVM 内存模型

视频讲解：[【java】jvm 内存模型全面解析](https://www.bilibili.com/video/BV12t411u726)

JVM 内存模型共分为 5 个区：堆、元空间（方法区）、Java 虚拟机栈、本地方法栈、程序计数器。

各个区各自的作用：

> 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。用于字符串常量池，对象。
>
> 元空间（方法区）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。
>
> Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象）
>
> 本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由 native 修饰，由 C 语言实现。
>
> **程序计数器**：它是一块很小的内存空间，**主要用来记录各个线程执行的字节码的地址**，例如，分支、循环、线程恢复等都依赖于计数器。

线程私有：Java 虚拟机栈、本地方法栈、程序计数器。

> 每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存

线程全局共享的：堆、元空间。

栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的。

### JVM 内存模型概览

堆：

> 包括：字符串常量池，对象。

元空间（方法区）：

> 包括：方法、静态文件、类加载器、运行时常量池、静态常量池。

虚拟机栈：

> 存储的是对象名及其引用，即堆中的内存地址。包括：局部变量表、操作数栈、方法出口、动态链接等。

本地方法栈：

> 一个 java 调用非 java 代码的接口。

程序计数器：

> 记录各线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。

### JVM 堆空间模型

新生代：

> 使用复制清理算法。
>
> 分为两个存活区 / Survivor，一个伊甸区 / Eden；
>
> HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8∶1。
>
> 每次分配内存只使用 Eden 和其中一块 Survivor。
>
> 发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。

老年代：

> 使用标记清理算法。


---

## 内存问题

---

### 新创建的对象可能直接分配到老年代吗

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

HotSpot虚拟机提供了-XX：PretenureSizeThreshold参数，指定大于该设置值的对象直接在老年代分配，

这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。

### 老年代存放的都是什么对象

虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。

对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。

对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。

对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。

### Jvm中对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代吗

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，

年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。

### 老年代的空间分配担保

**空间分配担保：**

> 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，
>
> 如果大于，则此次 Minor GC 是安全的。
>
> 如果不成立，则虚拟机会先查看 -XX：HandlePromotionFailure 参数的设置值是否允许担保失败（Handle Promotion Failure）；
>
> 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
>
> 如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；
>
> 如果小于，或者 -XX：HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。

为什么要进行空间担保：

因为新生代采用复制收集算法，假如大量对象在 Minor GC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，把
Survivor 无法容纳的对象放到老年代。

老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。

使用这个平均值与老年代剩余空间进行比较，来决定是否进行 Full GC 来让老年代腾出更多空间。

###











