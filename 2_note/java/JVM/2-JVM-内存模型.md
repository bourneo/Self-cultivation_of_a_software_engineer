# JVM

---

## 内存模型

---

### JVM 内存模型

视频讲解：[【java】jvm 内存模型全面解析](https://www.bilibili.com/video/BV12t411u726)

JVM 内存模型共分为 5 个区：堆、元空间（方法区）、Java 虚拟机栈、本地方法栈、程序计数器。

各个区各自的作用：

> 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。用于字符串常量池，对象。
>
> 元空间（方法区）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。
>
> Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象）
>
> 本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由 native 修饰，由 C 语言实现。
>
> **程序计数器**：它是一块很小的内存空间，**主要用来记录各个线程执行的字节码的地址**，例如，分支、循环、线程恢复等都依赖于计数器。

线程私有：Java 虚拟机栈、本地方法栈、程序计数器。

> 每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存

线程全局共享的：堆、元空间。

栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的。

### JVM 内存模型概览

堆：

> 包括：字符串常量池，对象。

元空间（方法区）：

> 包括：方法、静态文件、类加载器、运行时常量池、静态常量池。

虚拟机栈：

> 存储的是对象名及其引用，即堆中的内存地址。包括：局部变量表、操作数栈、方法出口、动态链接等。

本地方法栈：

> 一个 java 调用非 java 代码的接口。

程序计数器：

> 记录各线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。

### JVM 堆空间模型

新生代：

> 使用复制清理算法。
>
> 分为两个存活区和一个伊甸区；
>
> 伊甸区比两个存活区大很多，约是八倍，因为产生的多但是幸存的少。
>
> 复制是的具体过程：从伊甸区复制到一个存活区 s1，然后清理伊甸区和另一个存活区 s2 的空间，下一轮就是伊甸区复制到 s2，依次循环。

老年代：

> 使用标记清理算法。

---

## 内存问题

---

### 老年代的空间分配担保

**空间分配担保：**

> 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，
>
> 如果大于，则此次 Minor GC 是安全的。

为什么要进行空间担保：

因为新生代采用复制收集算法，假如大量对象在 Minor GC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，把
Survivor 无法容纳的对象放到老年代。

老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。

使用这个平均值与老年代剩余空间进行比较，来决定是否进行 Full GC 来让老年代腾出更多空间。





