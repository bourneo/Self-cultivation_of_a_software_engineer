# JVM

---

## 基础部分

---

### JVM内存模型

视频讲解：[【java】jvm 内存模型全面解析](https://www.bilibili.com/video/BV12t411u726)

JVM 内存模型共分为 5 个区：Java 虚拟机栈、本地方法栈、堆、程序计数器、方法区（元空间）

各个区各自的作用：

> 本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由 native 修饰，由 C 语言实现。
>
> 程序计数器：它是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。
>
> 方法区（Java8 叫元空间）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。
>
> Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象）
>
> 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；

线程私有：
>
> 每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存
>
> Java 虚拟机栈、本地方法栈、程序计数器是线程私有的

线程全局共享的：

> 堆和方法区

栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的。

### 内存模型

虚拟机栈：

> 线程私有；
>
> 存储的是对象名及其引用，即堆中的内存地址

堆：

> 线程共有；
>
> 新生代：复制清理算法
>
> 老年代：标记清理算法
>
> 包括：字符串常量池，对象

元空间（方法区）：

> 线程共有；
>
> 包括：方法、静态文件、类加载器、运行时常量池、静态常量池


程序计数器：

> 线程私有；
>
>

本地方法栈：

> 线程私有；
>
> 一个 java 调用非 java 代码的接口。

### 堆空间模型

新生代：

> 使用复制清理算法。
>
> 分为两个存活区和一个伊甸区；
>
> 伊甸区比两个存活区大很多，约是八倍，因为产生的多但是幸存的少。
>
> 复制是的具体过程：从伊甸区复制到一个存活区 s1，然后清理伊甸区和另一个存活区 s2 的空间，下一轮就是伊甸区复制到 s2，依次循环。

老年代：

> 使用标记清理算法

### 垃圾回收

视频讲解：[【java】10 分钟，了解 GC 过程](https://www.bilibili.com/video/BV1dt411u7wi)

垃圾回收的判断标准：

> 是否被 GCRoot 直接引用或间接引用。

垃圾回收算法：

> 标记清理算法：缺点是由碎片。
>
> 标记整理算法：缺点是代价大。
>
> 复制算法：缺点是需要两倍内存。


垃圾收集器：

> ParNew：新生代
>
> CMS：老年代

历代垃圾收集器：

视频讲解：[【java】垃圾收集器 | g1 收集器](https://www.bilibili.com/video/BV13J411g7A1)

| 历代垃圾收集器 | 新生代 | 老年代 | 新生代和老年代收集器 |
|:---|:---|:---|:---|
| 00 | Serial（单线程） | Serial Old（单线程） | G1 |
| 01 | ParNew | CMS（最短回收停顿时间） | G1 |
| 02 | Parallel Scavenge（吞吐量优先） | Parallel Old（注重吞吐量） | G1 |

G1 收集器：

G1 收集器是一款面向服务端应用的垃圾收集器，目前是 JDK9 的默认垃圾收集器。

特点：

> 并行与并发。G1 能充分利用多 CPU，多核环境下的硬件优势。
>
> 分代收集。能够采用不同的方式去处理新创建的对象和已经存活了一段时间的对象，不需要与其他收集器进行合作。
>
> 空间整合。G1 从整体上来看基于 “标记 - 整理” 算法实现的收集器，从局部上看是基于复制算法实现的，因此 G1 运行期间不会产生空间碎片。
>
> 可预测的停顿。G1 能建立可预测的时间停顿模型，能让使用者明确指定一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

适用场景：

> 要求尽可能可控 GC 停顿时间；内存占用较大的应用。
>
> 可以用 -XX:+UseG1GC 使用 G1 收集器

---

## 提高部分

---

### 指令与工具 jstat/jstack/jmap/jconsole/jps/visualVM

视频讲解：[【java】jvm 指令与工具 jstat/jstack/jmap/jconsole/jps/visualVM](https://www.bilibili.com/video/BV1QJ411P78Q)

jmap：

> 查看内存或者 dump 内存详情的工具，排查内存泄露的利器。
>
> dump 内存信息保存为文件：jmap -dump:file=a pid
>
> 打印堆栈信息：jmap -heap pid
>
> OOM 时自动执行 dump：-XX:+HeapDumpOnOutOfMemoryError

jps：

> 进程分析。
>
> 命令：jps

jstat：

> 内存分析。
>
> 例如：jstat -gcutil pid interval，堆内存的使用百分比。
>
> 例如：jstat -gc pid，堆内存占用。

jstack：

> 线程分析。
>
> 例如：jstack pid，查看堆栈信息。

jconsole：

> 可视化界面：内存、线程、类、VM 概要，MBean 等信息。

visualVM：

> Java 8 之后的版本不再内置 visualVM。


---






---

参考链接：

- [7 种垃圾回收器特点，优劣及使用场景](https://www.jianshu.com/p/5b2721b891c0)
- []()

---

















