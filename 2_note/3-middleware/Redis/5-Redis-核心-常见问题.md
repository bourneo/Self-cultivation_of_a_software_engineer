# Redis

---

## Redis 三剑客

---

### Redis 缓存雪崩

视频讲解：[什么是 Redis 缓存雪崩、穿透、击穿，十分钟给你讲的明明白白](https://www.bilibili.com/video/BV1f5411b7ux)

缓存雪崩：key 同一时间大面积失效。

解决方案：

key 不设置过期时间；

> key 的过期时间避免设置成一样。

### Redis 缓存击穿

热点 key 失效，导致大致大量请求直接到达数据库。

解决方案：

> 分布式锁，防止同一时间直接请求数据库。

### Redis 缓存穿透

被恶意大规模查询缓存中不存在的 key，导致大致大量请求直接到达数据库。

解决方案：

> 限制 ip 的请求次数。





---

## Redis 常见问题

---

### Redis 过期 key 的清理策略

1、**被动删除**。访问 key 发现过期时，会将 key 删除。

2、主动删除。定时清理，每次清理都会遍历。

3、内存不够时清理。当使用内存超过了设置的最大内存，就会释放内存，按照配置的**淘汰策略**清理内存。

### Redis 内存不够用的优化思路

1、有条件先增加内存

2、存淘汰策略，删除过期数据，再使用 LRU 算法进行淘汰

3、转码压缩

### 热点商品的路由问题，导致请求的倾斜

万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。

就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，

如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。

### 热 key 问题

目前业内的方案有两种：

1、利用二级缓存

比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。

针对这种热key请求，会直接从jvm中取，而不会走到redis层。

假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。

现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。

这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。

2、备份热 key

这个方案也很简单。不要让key走到同一台redis上不就行了。

我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。

### 大 key 问题

根据大key的实际用途可以分为两种情况：可删除和不可删除。

**删除大 key：**

如果发现某些大key并非热key就可以在DB中查询使用，则可以在Redis中删掉：

当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。

**压缩和拆分 key：**

当 value 是 string 时，比较难拆分，则使用序列化、压缩算法将 key 的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。

当 value 是 string，压缩之后仍然是大 key，则需要进行拆分，一个大 key 分为不同的部分，记录每个部分的 key，使用 multiget 等操作实现事务读取。

当 value 是 list/set 等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。






---

## Redis 与数据库

---

### Redis 和 MySQL 的双写一致性

视频讲解：[MySQL 和 Redis 的双写一致性](https://www.bilibili.com/video/BV1CD4y1X75a) （推荐）

1、先更新缓存，再更新数据库。不可取，更新数据库可能会失败，失去一致性。

2、先更新数据库，再更新缓存。

> 也不可取，更新缓存可能会失败或者超时，失去一致性。
>
> 并发场景下，更新缓存太慢，导致其他其他线程先更新了缓存，然后把过期的数据更新进缓存，失去一致性。

3、先删除缓存，再更新数据库。

> 高并发场景下，更新数据库太慢，其他线程读取数据库之后重新写入缓存，更新数据库之后和缓存数据不一致。
>
> 解决办法：延迟双删。在更新数据库之后再删一次缓存。延迟时间大于业务的一次读操作时间。

4、先更新数据库，再删除缓存。

> 高并发场景下，一个小概率场景：线程 1 读取数据库后准备写入缓存，但是线程 2 执行了数据库更新，并删除缓存。
>
> 线程 1 在执行线程 2 执行完删除缓存治藏，把之前读取的数据写入了缓存，导致一致性丢失。
>
> 解决办法：延迟双删。

延迟双删：存在缓存删除失败的情况，需要用队列做重试循环。









---

