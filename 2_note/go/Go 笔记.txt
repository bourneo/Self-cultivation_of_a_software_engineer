
Go 笔记

一、介绍：

	特点：
		Go 也叫 Golang；
			按照 Rob Pike 说法，语言叫做 Go，Golang 只是官方网站的网址；
			是开源的编译型的静态语言，源代码会编译为二进制机器码；
			支持静态链接，Go 代码可以静态链接为一个大的二进制文件；
		Go 使得高可用性和可扩展性的 Web 应用的开发变得简便容易；
			Go 的定位是系统编程语言，只是对 Web 开发支持较好。

	工作区：
		Go 源文件都应该放置在工作区里的 src 目录下。

	基本命令：
		run：后面加 Go 格式的文件名，编译运行文件中的代码；
		install：后面加包名，创建一个同包名的二进制文件；

	文件结构：
		例如：
			package main
			import "fmt"
			func main() {
				fmt.Println("Hello World")
			}
		package：每一个 Go 文件都应该在开头进行 package name 的声明；
			只有可执行程序的包名应当为 main：package main。
		import ""：引入了外部的包，多个包可以用圆括号括起来。
		func main()：main 是一个特殊的函数，是程序的入口，main 函数必须放置在 main 包中。

	目录结构：
		src：源码文件夹；
		bin：二进制文件。


二、基础：

	变量：
		变量：指定了某存储单元（Memory Location）的名称，
			该存储单元会存储特定类型的值。

		声明单个变量：
			语法：var name type
				例如：
					func main() {
						var age int // 变量声明
					}
			如果变量未被赋值，Go 会自动地将其初始化，
				赋值该变量类型的零值（Zero Value）。

		声明变量并初始化：
			语法：var name type = initialvalue
				例如：
					func main() {
						var age int = 29 // 声明变量并初始化
					}

		类型推断（Type Inference）：
			如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。
				如果变量有初始值，就可以在变量声明中省略 type。
			语法：var name = initialvalue
				Go 能够根据初始值推断变量的类型。
				例如：
					func main() {
						var age = 29 // 可以推断类型
					}

		声明多个变量：
			语法：var name1, name2 type = initialvalue1, initialvalue2
				例如：
					func main() {
						var width, height int = 100, 50 // 声明多个变量
					}
			在一个语句中声明不同类型的变量：
				语法：
					var (
						name1 = initialvalue1,
						name2 = initialvalue2
					)
				例如：
					func main() {
						var (
							name   = "naveen"
							age    = 29
							height int
						)
					}

		简短声明：
			Go 也支持一种声明变量的简洁形式，称为简短声明（Short Hand Declaration），
				该声明使用了 := 操作符。
			语法：name := initialvalue
				例如：
					func main() {
						name, age := "naveen", 29 // 简短声明
					}
			要求：
				:= 操作符左边的所有变量都有初始值。
					例如：
						func main() {
							name, age := "naveen" //error
						}
				:= 操作符的左边至少有一个变量是尚未声明的。
					例如：
						func main() {
							a, b := 20, 30 // 声明变量 a 和 b
							b, c := 40, 50 // b 已经声明，但 c 尚未声明
							b, c = 80, 90 // 给已经声明的变量 b 和 c 赋新值
						}
					如果:= 操作符的左边没有尚未声明的变量，
						会抛出 no new variables on left side of := 的错误。
						例如：
							func main() {
								a, b := 20, 30 // 声明 a 和 b
								a, b := 40, 50 // 错误，没有尚未声明的变量
							}
			变量也可以在运行时进行赋值；
				例如：
					func main() {
						a, b := 145.8, 543.8
						c := math.Min(a, b)
						fmt.Println("minimum value is ", c)
					}
			Go 是强类型（Strongly Typed）语言，
				不允许某一类型的变量赋值为其他类型的值。
					例如：
						func main() {
							age := 29      // age 是 int 类型
							age = "naveen" // 错误，尝试赋值一个字符串给 int 类型变量
						}

	类型：
		基本类型：
			bool (布尔型)；
				例如：
					func main() {
						a := true
						b := false
						c := a && b
						d := a || b
					}

			数字类型：
				int8, int16, int32, int64, int (有符号整型)：
					通常应该使用 int 表示整型；
					大小：32 位系统下是 32 位，64 位系统下是 64 位；
					范围：32 位系统下是 -2147483648～2147483647，
						64 位系统是 -9223372036854775808～9223372036854775807。
					例如：
						func main() {
							var a int = 89
							b := 95
							// a 的类型和大小
							fmt.Printf("type of a is %T, size of a is %d", a, unsafe.Sizeof(a))
							// b 的类型和大小
							fmt.Printf("\ntype of b is %T, size of b is %d", b, unsafe.Sizeof(b))
						}
				uint8, uint16, uint32, uint64, uint (无符号整型)：
					范围：32 位系统下是 0～4294967295，
						64 位系统是 0～18446744073709551615。
				float32, float64 (浮点型)：
					float64 是浮点数的默认类型。
					例如：
						func main() {
							a, b := 5.67, 8.97
							fmt.Printf("type of a %T b %T\n", a, b)
							sum := a + b
							diff := a - b
							fmt.Println("sum", sum, "diff", diff)
						}
				complex64, complex128 (复数类型)：
					实部和虚部都是 float32 或者 float64 类型的的复数；
					内建函数 complex 用于创建一个包含实部和虚部的复数：
						func complex(r, i FloatType) ComplexType
					使用简短语法来创建复数：
						c := 6 + 7i
				byte (字节)：
					是 uint8 的别名。
				rune (如尼)：
					是 int32 的别名。

			string (字符串)：
				Go 中，字符串是字节的集合。

		类型转换：
			Go 有着非常严格的强类型特征，没有自动类型提升或类型转换。
				例如：
					func main() {
						i := 55      //int
						j := 67.8    //float64
						sum := i + j //不允许 int + float64
					}
			类型强行转换：
				T(v)。
				例如：
					func main() {
						i := 55      //int
						j := 67.8    //float64
						sum := i + int(j) //j is converted to int
					}
			把一个变量赋值给另一个不同类型的变量，需要显式的类型转换。
				例如：
					func main() {
						i := 10
						var j float64 = float64(i) // 若没有显式转换，该语句会报错
					}

	常量：
		定义：固定的值。
			关键字 const 被用于表示常量；
				例如：
					func main() {
						const a = 55；
						var b string = "I love Go"
					}
			常量不能再重新赋值为其他的值。
				例如：
					func main() {
						const a = 55 // 允许
						a = 89       // 不允许重新赋值
					}
			常量的值会在编译的时候确定，所以不能将函数的返回值赋值给常量。
				例如：
					func main() {
						fmt.Println("Hello, playground")
						var a = math.Sqrt(4)   // 允许
						const b = math.Sqrt(4) // 不允许
					}

		字符串常量：
			双引号中的任何值都是 Go 中的字符串常量。
				例如：
					const hello = "Hello World"
				像 Hello World 这样的字符串常量是没有任何类型的。
			Go 是一门强类型语言，所有的变量必须有明确的类型。
				无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。
				在声明中 var name = "Sam" ， name 需要一个类型，它从字符串常量 Sam 的默认类型中获取。
			创建一个带类型的常量：
				const typedhello string = "Hello World"
			创建一个新类型 myString：
				type myString string
					myString 是 string 的别名。
				即使我们知道这个 myString 是 string 类型的别名。
					Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。
			Go 是一个强类型的语言，在分配过程中混合类型是不允许的。
				例如：
					func main() {
						var defaultName = "Sam" // 允许
						type myString string
						var customName myString = "Sam" // 允许
						customName = defaultName // 不允许
					}
				因此将 defaultName 赋值给 customName 是不允许的，编译器会抛出一个错误。

		布尔常量：
			布尔常量和字符串常量没有什么不同。
			他们是两个无类型的常量 true 和 false。
			字符串常量的规则适用于布尔常量。
				例如：
					func main() {
						const trueConst = true
						type myBool bool
						var defaultBool = trueConst // 允许
						var customBool myBool = trueConst // 允许
						defaultBool = customBool // 不允许
					}

		数字常量：
			数字常量包含整数、浮点数和复数的常量。数字常量中有一些微妙之处。
			const a = 5
			上面的常量 a 是没有类型的；
			常量的默认类型可以被认为是根据上下文在运行中生成的。
				例如：
					func main() {
						const a = 5
						var intVar int = a
						var int32Var int32 = a
						var float64Var float64 = a
						var complex64Var complex64 = a
						fmt.Println("intVar",intVar, "\nint32Var", int32Var, "\nfloat64Var", float64Var, "\ncomplex64Var",complex64Var)
					}

		数字表达式：
			数字常量可以在表达式中自由混合和匹配，
			只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。
				例如：
					func main() {
						var a = 5.9/8
						fmt.Printf("a's type %T value %v",a, a)
					}
				5.9/8 是允许的，因为两个都是数字常量。
				除法的结果是 0.7375 是一个浮点型，所以 var a = 5.9/8 中，a 的类型是浮点型。

	函数：
		函数（Function）：
			是一块执行特定任务的代码。
			一个函数是在输入源基础上，通过执行一系列的算法，生成预期的输出。

		函数声明：
			语法：
				func functionName(parameterName type) returnType {
					// 函数体（具体实现的功能）
				}
			解析：
				func：函数的声明以关键词 func 开始，
				函数名：后面紧跟自定义的函数名 functionname；
				参数列表：函数的参数列表定义在 ( 和 ) 之间，
					参数：声明一个参数的语法采用 参数名 参数类型 的方式，
						任意多个参数采用类似 (parameter1 type, parameter2 type)，
						即(参数1 参数1的类型, 参数2 参数2的类型)的形式指定。
				返回值类型：定义在之后的 returnType 处。
				函数体：之后包含在 { 和 } 之间的代码。
			函数中的参数列表和返回值并非是必须的。
				例如：
					func functionname() {
						// 译注: 表示这个函数不需要输入参数，且没有返回值
					}

		函数示例：
			输入参数是单件商品的价格和商品的个数，两者的乘积为商品总价，作为函数的输出值。
				func calculateBill(price int, no int) int {
					var totalPrice = price * no // 商品总价 = 商品单价 * 数量
					return totalPrice // 返回总价
				}
			如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。
				例如：
					func calculateBill(price, no int) int {
						var totalPrice = price * no
						return totalPrice
					}
				price int, no int 可以简写为 price, no int。

		函数调用：
			语法：functionname(parameters)。
				例如：
					calculateBill(10, 5)

		多返回值：
			Go 语言支持一个函数可以有多个返回值。
			如果一个函数有多个返回值，那么这些返回值必须用圆括号括起来。
				例如：
					func rectProps(length, width float64)(float64, float64) {
						var area = length * width
						var perimeter = (length + width) * 2
						return area, perimeter
					}

		命名返回值：
			从函数中可以返回一个命名值。
			一旦命名了返回值，可以认为这些值在函数第一行就被声明为变量了。
				例如：
					func rectProps(length, width float64)(area, perimeter float64) {
						area = length * width
						perimeter = (length + width) * 2
						return // 不需要明确指定返回值，默认返回 area, perimeter 的值
					}
				上面函数中的 return 语句没有显式返回任何值。
					由于 area 和 perimeter 在函数声明中指定为返回值,
					因此当遇到 return 语句时, 它们将自动从函数返回。

		空白符：
			_ 在 Go 中被用作空白符，可以用作表示任何类型的任何值。
				例如：
					func main() {
						area, _ := rectProps(10.8, 5.6) // 返回值周长被丢弃
						fmt.Printf("Area %f ", area)
					}
				在 area, _ := rectProps(10.8, 5.6) 这一行中，_ 用来跳过不要的计算结果。

		常用函数：
			Printf()：
				格式化打印；
				格式说明符（Format Specifier）：
					%T 可以打印变量的类型；
					%d 可以打印数值型变量的值；
					%x 字节；
					%c 字符；
					%s 字符串；
					%f 浮点类型；
					%.2f 可以将浮点数截断到小数点两位。
			Sizeof()：
				变量的字节大小；
				unsafe 包提供的函数，该函数接收变量并返回它的字节大小。
				unsafe 包应该小心使用，因为使用 unsafe 包可能会带来可移植性问题。
			make()：
				切片的创建：
					make（[]T，len，cap）
				map 的初始化；
					make(map[string]int)
				定义信道：
					make(chan int)

	包：
		包（Package）：
			用于组织 Go 源代码，提供了更好的可重用性与可读性。

		main 函数和 main 包：
			所有可执行的 Go 程序都必须包含一个 main 函数；
				这个函数是程序运行的入口；
				main 函数应该放置于 main 包中。
			package packagename 这行代码指定了某一源文件属于一个包；
				应该放在每一个源文件的第一行。
				例如：
					// geometry.go
					package main
					import "fmt"
					func main() {
						fmt.Println("Geometrical shape properties")
					}
				package main 这一行指定该文件属于 main 包。
				import "packagename" 语句用于导入一个已存在的包。

		创建自定义的包：
			属于某一个包的源文件都应该放置于一个单独命名的文件夹里。
				按照 Go 的惯例，应该用包名命名该文件夹。
				例如：
					// rectprops.go
					package rectangle
					import "math"
					func Area(len, wid float64) float64 {
						area := len * wid
						return area
					}
					func Diagonal(len, wid float64) float64 {
						diagonal := math.Sqrt((len * len) + (wid * wid))
						return diagonal
					}
				注意：函数 Area 和 Diagonal 都是以大写字母开头的。

		导入自定义包：
			为了使用自定义包，我们必须要先导入它。导入自定义包的语法为 import path。
			我们必须指定自定义包相对于工作区内 src 文件夹的相对路径。
				例如：
					// geometry.go
					package main
					import (
						"fmt"
						"geometry/rectangle" // 导入自定义包
					)
					func main() {
						var rectLen, rectWidth float64 = 6, 7
						/*Area function of rectangle package used*/
						fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
						/*Diagonal function of rectangle package used*/
						fmt.Printf("diagonal of the rectangle %.2f ", rectangle.Diagonal(rectLen, rectWidth))
					}

		导出名字（Exported Names）：
			在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。
				其它包只能访问被导出的函数和变量。
				如果想在包外访问一个函数，它应该首字母大写。

		init 函数：
			所有包都可以包含一个 init 函数。
				init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。
				init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。
			包的初始化顺序：
				首先初始化包级别（Package Level）的变量；
				紧接着调用 init 函数。
					包可以有多个 init 函数（在一个文件或分布于多个文件中），
					它们按照编译器解析它们的顺序进行调用。
			项目级别的初始化顺序：
				如果一个包导入了另一个包，会先初始化被导入的包。
				尽管一个包可能会被导入多次，但是它只会被初始化一次。

		使用空白标识符（Blank Identifier）：
			导入了包，却不在代码中使用它，这在 Go 中是非法的。
				当这么做时，编译器是会报错的。
				原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。
					例如：
						package main
						import (
							"geometry/rectangle" // 导入自定的包
						)
						func main() {
						}
					上面的程序将会抛出错误 geometry.go:6: imported and not used: "geometry/rectangle"。

			在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。
				遇到这种情况就可以使用空白标识符 _。
					例如：
						package main
						import (
							"geometry/rectangle"
						)
						var _ = rectangle.Area // 错误屏蔽器
						func main() {
						}
				我们应该了解错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们。
				建议在 import 语句下面的包级别范围中写上错误屏蔽器。

			有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。
				例如，我们或许需要确保调用了 rectangle 包的 init 函数，而不需要在代码中使用它。
				这种情况也可以使用空白标识符。
					例如：
						package main
						import (
							_ "geometry/rectangle"
						)
						func main() {
						}

	if-else 语句：
		if 条件语句：
			语法：
				if condition {
				}

		if-else 语句：
			有可选的 else if 和 else 部分：
			语法：
				if condition {
				} else if condition {
				} else {
					}
			注意：
				if-else 语句之间可以有任意数量的 else if。
				条件判断顺序是从上到下。
				如果 if 或 else if 条件判断的结果为真，则执行相应的代码块。
				如果没有条件为真，则 else 代码块被执行。
			例如：
				func main() {
					num := 10
					if num % 2 == 0 { //checks if number is even
						fmt.Println("the number is even")
					}  else {
						fmt.Println("the number is odd")
					}
				}

		if 还有另外一种形式，它包含一个 statement 可选语句部分，该组件在条件判断之前运行。
			语法：
				if statement; condition {
				}
			例如：
				func main() {
					if num := 10; num % 2 == 0 { //checks if number is even
						fmt.Println(num,"is even")
					}  else {
						fmt.Println(num,"is odd")
					}
				}
				num 在 if 语句中进行初始化，num 只能从 if 和 else 中访问。
				也就是说 num 的范围仅限于 if else 代码块。
				如果我们试图从其他外部的 if 或者 else 访问 num, 编译器会不通过。

		一个注意点：
			else 语句应该在 if 语句的大括号 } 之后的同一行中。
			如果不是，编译器会不通过。
				例如：
					func main() {
						num := 10
						if num % 2 == 0 { //checks if number is even
							fmt.Println("the number is even")
						}
						else {
							fmt.Println("the number is odd")
						}
					}
					编译器会输出错误：main.go:12:5: syntax error: unexpected else, expecting }
			因为 Go 语言的分号是自动插入：
				如果 } 是该行的最终标记， } 之后会被插入一个分号。

	循环：
		for：是 Go 语言唯一的循环语句。
			语法：
				for initialisation; condition; post {
				}
			执行顺序：
				初始化语句只执行一次。
				循环初始化后，将检查循环条件。
				如果条件的计算结果为 true ，则 {} 内的循环体将执行，接着执行 post 语句。
				post 语句将在每次成功循环迭代后执行。
				在执行 post 语句后，条件将被再次检查。
					如果为 true, 则循环将继续执行，否则 for 循环将终止。
				这是典型的 for 循环三个表达式：
					第一个为初始化表达式或赋值语句；
					第二个为循环条件判定表达式；
					第三个为循环变量修正表达式，即此处的 post。
				这三个组成部分，即初始化，条件和 post 都是可选的。
			例如：
				func main() {
					for i := 1; i <= 10; i++ {
						fmt.Printf(" %d",i)
					}
				}

		break：
			break 语句，用于在完成正常执行之前突然终止 for 循环，
				之后程序将会在 for 循环下一行代码开始执行。
			例如：
				func main() {
					for i := 1; i <= 10; i++ {
						if i > 5 {
							break //loop is terminated if i > 5
						}
						fmt.Printf("%d ", i)
					}
					fmt.Printf("\nline after for loop")
				}

		continue：
			continue 语句，用来跳出 for 循环中当前循环。
				在 continue 语句后的所有的 for 循环语句都不会在本次循环中执行。
				循环体会在一下次循环中继续执行。
			例如：
				func main() {
					for i := 1; i <= 10; i++ {
						if i%2 == 0 {
							continue
						}
						fmt.Printf("%d ", i)
					}
				}

		for 循环的多样性：
			for 循环的三部分，初始化语句、条件语句、post 语句都是可选的。
				例如：
					func main() {
						i := 0
						for ;i <= 10; { // initialisation and post are omitted
							fmt.Printf("%d ", i)
							i += 2
						}
					}
			上面 for 循环中的分号也可以省略。
				例如：
					func main() {
						i := 0
						for i <= 10 { //semicolons are ommitted and only condition is present
							fmt.Printf("%d ", i)
							i += 2
						}
					}
			在 for 循环中可以声明和操作多个变量。
				例如：
					func main() {
						for no, i := 10, 1; i <= 10 && no <= 19; i, no = i+1, no+1 { //multiple initialisation and increment
							fmt.Printf("%d * %d = %d\n", no, i, no*i)
						}

					}

		无限循环：
			语法：
				for {
				}
			例如：
				func main() {
					for {
						fmt.Println("Hello World")
					}
				}
			这里还有一个 range 结构，它可以被用来在 for 循环中操作数组对象。

	switch 语句：
		switch 是一个条件语句；
			用于将表达式的值与可能匹配的选项列表进行比较，并根据匹配情况执行相应的代码块。
				它可以被认为是替代多个 if else 子句的常用方式。
			例如：
				func main() {
					finger := 4
					switch finger {
						case 1:
							fmt.Println("Thumb")
						case 2:
							fmt.Println("Index")
						case 3:
							fmt.Println("Middle")
						case 4:
							fmt.Println("Ring")
						case 5:
							fmt.Println("Pinky")
					}
				}
			在选项列表中，case 不允许出现重复项。

		默认情况（Default Case）：
			例如：
				func main() {
					switch finger := 8; finger {
						case 1:
							fmt.Println("Thumb")
						case 2:
							fmt.Println("Index")
						case 3:
							fmt.Println("Middle")
						case 4:
							fmt.Println("Ring")
						case 5:
							fmt.Println("Pinky")
						default: // 默认情况
							fmt.Println("incorrect finger number")
					}
				}
			default 不一定只能出现在 switch 语句的最后，它可以放在 switch 语句的任何地方。
			在这里，finger 声明在了 switch 语句内，finger 变量的作用域仅限于这个 switch 内。

		多表达式判断：
			通过用逗号分隔，可以在一个 case 中包含多个表达式。
				例如：
					func main() {
						letter := "i"
						switch letter {
							case "a", "e", "i", "o", "u": // 一个选项多个表达式
								fmt.Println("vowel")
							default:
								fmt.Println("not a vowel")
						}
					}

		无表达式的 switch：
			在 switch 语句中，表达式是可选的，可以被省略。
				如果省略表达式，则表示这个 switch 语句等同于 switch true，
				并且每个 case 表达式都被认定为有效，相应的代码块也会被执行。
			例如：
				func main() {
					num := 75
					switch { // 表达式被省略了
						case num >= 0 && num <= 50:
							fmt.Println("num is greater than 0 and less than 50")
						case num >= 51 && num <= 100:
							fmt.Println("num is greater than 51 and less than 100")
						case num >= 101:
							fmt.Println("num is greater than 100")
					}
				}
			在上述代码中，switch 中缺少表达式，因此默认它为 true，
				true 值会和每一个 case 的求值结果进行匹配。
				这种类型的 switch 语句可以替代多个 if else 子句。

		Fallthrough 语句：
			Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。
			fallthrough 可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中。
					例如：
						func main() {
							switch num := number(); { // num is not a constant
								case num < 50:
									fmt.Printf("%d is lesser than 50\n", num)
									fallthrough
								case num < 100:
									fmt.Printf("%d is lesser than 100\n", num)
									fallthrough
								case num < 200:
									fmt.Printf("%d is lesser than 200", num)
							}
						}
					switch 和 case 的表达式不一定是常量。它们也可以在运行过程中通过计算得到。
				fallthrough 语句应该是 case 子句的最后一个语句。
					如果它出现在了 case 语句的中间，编译器会报错：fallthrough statement out of place

	数组和切片：
		数组：
			同一类型元素的集合。

		数组的声明：
			形式：
				一个数组的表示形式为 [n]T。
				n 表示数组中元素的数量，T 代表每个元素的类型。
					元素的数量 n 也是该类型的一部分。
						例如：
							func main() {
								var a [3]int //int array with length 3
							}
					数组中的所有元素都被自动赋值为数组类型的零值。
			索引：
				数组的索引从 0 开始到 length - 1 结束。
					例如：
						func main() {
							var a [3]int //int array with length 3
							a[0] = 12 // array index starts at 0
							a[1] = 78
							a[2] = 50
						}
			简略声明：
				来创建相同的数组。
					例如：
						func main() {
							a := [3]int{12, 78, 50} // short hand declaration to create array
						}
				在简略声明中，不需要将数组中所有的元素赋值。
					例如：
						func main() {
							a := [3]int{12}
						}
					声明一个长度为 3 的数组，但只提供了一个值 12，剩下的 2 个元素自动赋值为 0。
			不定长数组：
				可以忽略声明数组的长度，并用 ... 代替，让编译器为你自动计算长度：
					例如：
						func main() {
							a := [...]int{12, 78, 50} // ... makes the compiler determine the length
						}
				数组的大小是类型的一部分。因此 [5]int 和 [25]int 是不同类型。
				数组不能调整大小，不要担心这个限制，因为 slices 的存在能解决这个问题。

		数组是值类型：
			Go 中的数组是值类型而不是引用类型。
				当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。
				如果对新变量进行更改，则不会影响原始数组。
					例如：
						func main() {
							a := [...]string{"USA", "China", "India", "Germany", "France"}
							b := a // a copy of a is assigned to b
							b[0] = "Singapore"
						}
			当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。
				例如：
					func changeLocal(num [5]int) {
						num[0] = 55
					}
					func main() {
						num := [...]int{5, 6, 7, 8, 8}
						changeLocal(num) //num is passed by value
					}
				上述数组 num 实际上是通过值传递给函数 changeLocal，数组不会因为函数调用而改变。

		数组的长度：
			将数组作为参数传递给 len 函数，可以得到数组的长度。
				例如：
					func main() {
						a := [...]float64{67.7, 89.8, 21, 78}
						fmt.Println("length of a is",len(a))
					}

		使用 range 迭代数组：
			for 循环可用于遍历数组中的元素。
				例如：
					func main() {
						a := [...]float64{67.7, 89.8, 21, 78}
						for i := 0; i < len(a); i++ { // looping from 0 to the length of the array
							fmt.Printf("%d th element of a is %.2f\n", i, a[i])
						}
					}
			Go 提供了一种更好、更简洁的方法，通过使用 for 循环的 range 方法来遍历数组。
				range 返回索引和该索引处的值。
				使用 range 重写上面的代码，我们还可以获取数组中所有元素的总和。
					例如：
						func main() {
							a := [...]float64{67.7, 89.8, 21, 78}
							sum := float64(0)
							for i, v := range a {//range returns both the index and value
								fmt.Printf("%d the element of a is %.2f\n", i, v)
								sum += v
							}
							fmt.Println("\nsum of all elements of a",sum)
						}
				如果你只需要值并希望忽略索引，则可以通过用 _ 空白标识符替换索引来执行。
					例如：
						for _, v := range a { // ignores index
						}

		多维数组：
			例如：
				var b [3][2]string
				b[0][0] = "apple"
				b[0][1] = "samsung"
				b[1][0] = "microsoft"
				b[1][1] = "google"
				b[2][0] = "AT&T"
				b[2][1] = "T-Mobile"
			简略语法声明多维数组：
				a := [3][2]string{
					{"lion", "tiger"},
					{"cat", "dog"},
					{"pigeon", "peacock"},
					// this comma is necessary. The compiler will complain if you omit this comma
				}

		切片：
			Go 中，切片比传统数组更常见。
			切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。
			切片本身不拥有任何数据，它们只是对现有数组的引用。

		创建一个切片：
			形式：
				带有 T 类型元素的切片由 []T 表示。
			使用语法：
				a[start:end]
				创建一个从 a 数组索引 start 开始到 end - 1 结束的切片。
					例如：
						func main() {
							a := [5]int{76, 77, 78, 79, 80}
							var b []int = a[1:4] // creates a slice from a[1] to a[3]
						}
			另一种创建切片的方法：
				例如：
					func main() {
						c := []int{6, 7, 8} // creates an array and returns a slice reference
					}
				创建一个有 3 个整型元素的数组，并返回一个存储在 c 中的切片引用。

		切片的修改：
			切片自己不拥有任何数据，它只是底层数组的一种表示。
			对切片所做的任何修改都会反映在底层数组中。
				例如：
					func main() {
						darr := [...]int{57, 89, 90, 82, 100, 78, 67, 69, 59}
						dslice := darr[2:5]
						fmt.Println("array before", darr)
						for i := range dslice {
							dslice[i]++
						}
						fmt.Println("array after", darr)
					}
			当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。
				例如：
					func main() {
						numa := [3]int{78, 79 ,80}
						nums1 := numa[:] // creates a slice which contains all elements of the array
						nums2 := numa[:]
						fmt.Println("array before change 1", numa)
						nums1[0] = 100
						fmt.Println("array after modification to slice nums1", numa)
						nums2[1] = 101
						fmt.Println("array after modification to slice nums2", numa)
					}
				numa [:] 缺少开始和结束值，开始和结束的默认值分别为 0 和 len (numa)。

		切片的长度和容量：
			切片的长度是切片中的元素数。
			切片的容量是从创建切片索引开始的底层数组中元素数。
				例如：
					func main() {
						fruitarray := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
						fruitslice := fruitarray[1:3]
						// length of is 2 and capacity is 6
						fmt.Printf("length of slice %d capacity %d", len(fruitslice), cap(fruitslice))
					}
			切片可以重置容量：
				超出切片的容量会导致程序运行时抛出错误。
				例如：
					func main() {
						fruitarray := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
						fruitslice := fruitarray[1:3]
						fmt.Printf("length of slice %d capacity %d\n", len(fruitslice), cap(fruitslice)) // length of is 2 and capacity is 6
						fruitslice = fruitslice[:cap(fruitslice)] // re-slicing furitslice till its capacity
						fmt.Println("After re-slicing length is",len(fruitslice), "and capacity is",cap(fruitslice))
					}

		使用 make 创建一个切片：
			func make（[]T，len，cap）
				[]T 通过传递类型，长度和容量来创建切片。
				容量是可选参数, 默认值为切片长度。
				make 函数创建一个数组，并返回引用该数组的切片。
			例如：
				func main() {
					i := make([]int, 5, 5)
				}

		追加切片元素：
			数组的长度是固定的，它的长度不能增加。
			切片是动态的，使用 append 可以将新元素追加到切片上。
			append 函数：
				func append（s []T，x ... T）[]T。
					x ... T 在函数定义中表示该函数接受参数 x 的个数是可变的。
					这些类型的函数被称为可变函数。
			当新的元素被添加到切片时，会创建一个新的数组。
				现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。
				新切片的容量是旧切片的两倍。
			切片类型的零值为 nil。一个 nil 切片的长度和容量为 0。
				可以使用 append 函数将值追加到 nil 切片。
					例如：
						func main() {
							var names []string //zero value of a slice is nil
							if names == nil {
								fmt.Println("slice is nil going to append")
								names = append(names, "John", "Sebastian", "Vinay")
								fmt.Println("names contents:",names)
							}
						}
				也可以使用 ... 运算符将一个切片添加到另一个切片。
					例如：
						func main() {
							veggies := []string{"potatoes", "tomatoes", "brinjal"}
							fruits := []string{"oranges", "apples"}
							food := append(veggies, fruits...)
							fmt.Println("food:",food)
						}

		切片的函数传递：
			切片在内部可由一个结构体类型表示。
				表现形式，
					type slice struct {
						Length        int
						Capacity      int
						ZerothElement *byte
					}
			切片包含长度、容量和指向数组第零个元素的指针。
				当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。
				当切片作为参数传递给函数时，函数内所做的更改也会在函数外可见。
					例如：
						func subtactOne(numbers []int) {
							for i := range numbers {
								numbers[i] -= 2
							}
						}
						func main() {
							nos := []int{8, 7, 6}
							fmt.Println("slice before function call", nos)
							subtactOne(nos)                               // function modifies the slice
							fmt.Println("slice after function call", nos) // modifications are visible outside
						}

		多维切片：
			类似于数组，切片可以有多个维度。
				例如：
					func main() {
						 pls := [][]string {
								{"C", "C++"},
								{"JavaScript"},
								{"Go", "Rust"},
								}
						for _, v1 := range pls {
							for _, v2 := range v1 {
								fmt.Printf("%s ", v2)
							}
							fmt.Printf("\n")
						}
					}

		内存优化：
			切片持有对底层数组的引用。
			只要切片在内存中，数组就不能被垃圾回收，在内存管理方面，这是需要注意的。
				假设有一个非常大的数组，我们只想处理它的一小部分。
				然后，我们由这个数组创建一个切片，并开始处理切片。
				这里需要重点注意的是，在切片引用时数组仍然存在内存中。
			一种解决方法是使用 copy 函数
				func copy(dst，src[]T)int 生成一个切片的副本；
				这样我们可以使用新的切片，原始数组可以被垃圾回收。
					例如：
						func countries() []string {
							countries := []string{"USA", "Singapore", "Germany", "India", "Australia"}
							neededCountries := countries[:len(countries)-2]
							countriesCpy := make([]string, len(neededCountries))
							copy(countriesCpy, neededCountries) //copies neededCountries to countriesCpy
							return countriesCpy
						}
						func main() {
							countriesNeeded := countries()
							fmt.Println(countriesNeeded)
						}

	可变参数函数：
		定义：
			参数个数可变的函数。
		语法：
			如果函数最后一个参数被记作 ...T ，
				函数可以接受任意个 T 类型参数作为最后一个参数。
			注意：
				只有函数的最后一个参数才允许是可变的。

		理解可变参数函数：
			append 函数的定义：
				func append(slice []Type, elems ...Type) []Type
					例如：
						func find(num int, nums ...int) {
							fmt.Printf("type of nums is %T\n", nums)
							found := false
							for i, v := range nums {
								if v == num {
									fmt.Println(num, "found at index", i, "in", nums)
									found = true
								}
							}
							if !found {
								fmt.Println(num, "not found in ", nums)
							}
							fmt.Printf("\n")
						}
						func main() {
							find(89, 89, 90, 95)
							find(45, 56, 67, 45, 90, 109)
							find(78, 38, 56, 98)
							find(87)
						}
			可变参数函数的工作原理：
				把可变参数转换为一个新的切片。

		切片传入可变参数函数：
			例如：
				func find(num int, nums ...int) {
					fmt.Printf("type of nums is %T\n", nums)
					found := false
					for i, v := range nums {
						if v == num {
							fmt.Println(num, "found at index", i, "in", nums)
							found = true
						}
					}
					if !found {
						fmt.Println(num, "not found in ", nums)
					}
					fmt.Printf("\n")
				}
				func main() {
					nums := []int{89, 90, 95}
					find(89, nums)
				}
			这种情况下无法通过编译，编译器报出错误。
				可变参数参数会被转换为 int 类型切片然后在传入 find 函数中。
				但是在这里 nums 已经是一个 int 类型切片，编译器试图在 nums 基础上再创建一个切片。
				因为 nums 是一个 []int 类型 而不是 int 类型，所以创建失败。
			将切片传入可变参数函数：
				有一个可以直接将切片传入可变参数函数的语法糖，
				你可以在在切片后加上 ... 后缀。
				如果这样做，切片将直接传入函数，不再创建新的切片
					例如：
						func find(num int, nums ...int) {
							fmt.Printf("type of nums is %T\n", nums)
							found := false
							for i, v := range nums {
								if v == num {
									fmt.Println(num, "found at index", i, "in", nums)
									found = true
								}
							}
							if !found {
								fmt.Println(num, "not found in ", nums)
							}
							fmt.Printf("\n")
						}
						func main() {
							nums := []int{89, 90, 95}
							find(89, nums...)
						}

		不直观的错误：
			当你修改可变参数函数中的切片时，请确保你知道你正在做什么。
				例如：
					func change(s ...string) {
						s[0] = "Go"
					}
					func main() {
						welcome := []string{"hello", "world"}
						change(welcome...)
						fmt.Println(welcome)
					}
				例如：
					func change(s ...string) {
						s[0] = "Go"
						s = append(s, "playground")
						fmt.Println(s)
					}

					func main() {
						welcome := []string{"hello", "world"}
						change(welcome...)
						fmt.Println(welcome)
					}

	Maps：
		定义：
			map 是在 Go 中将值（value）与键（key）关联的内置类型；
			通过相应的键可以获取到值。

		创建 map：
			通过向 make 函数传入键和值的类型，可以创建 map。
			语法：
				make(map[type of key]type of value)
					例如：
						personSalary := make(map[string]int)
			map 的零值是 nil。
				如果你想添加元素到 nil map 中，会触发运行时 panic。
					panic: assignment to entry in nil map
				因此 map 必须使用 make 函数初始化，然后才能添加元素。
					例如：
						func main() {
							var personSalary map[string]int
							if personSalary == nil {
								fmt.Println("map is nil. Going to make one.")
								personSalary = make(map[string]int)
							}
						}

		给 map 添加元素：
			给 map 添加新元素的语法和数组相同：
				例如：
					func main() {
						personSalary := make(map[string]int)
						personSalary["steve"] = 12000
						personSalary["jamie"] = 15000
						personSalary["mike"] = 9000
						fmt.Println("personSalary map contents:", personSalary)
					}
			可以在声明的时候初始化 map：
				例如：
					func main() {
						personSalary := map[string]int {
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						fmt.Println("personSalary map contents:", personSalary)
					}
			键不一定只能是 string 类型：
				所有可比较的类型，如 boolean，interger，float，complex，string 等，都可以作为键。

		获取 map 中的元素：
			语法：
				map[key]
					例如：
						func main() {
							personSalary := map[string]int{
								"steve": 12000,
								"jamie": 15000,
							}
							personSalary["mike"] = 9000
							employee := "jamie"
							fmt.Println("Salary of", employee, "is", personSalary[employee])
						}
			如果获取一个不存在的元素，map 会返回该元素类型的零值：
				例如：
					func main() {
						personSalary := map[string]int{
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						employee := "jamie"
						fmt.Println("Salary of joe is", personSalary["joe"])
					}
				personSalary 中不包含 joe 的情况下我们不会获取到任何运行时错误。
			如果想知道 map 中到底是不是存在这个 key：
				语法：
					value, ok := map[key]
					如果 ok 是 true，表示 key 存在，key 对应的值就是 value，反之表示 key 不存在。
				例如：
					func main() {
						personSalary := map[string]int{
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						newEmp := "joe"
						value, ok := personSalary[newEmp]
						if ok == true {
							fmt.Println("Salary of", newEmp, "is", value)
						} else {
							fmt.Println(newEmp,"not found")
						}
					}
			遍历 map 中所有的元素：
				需要用 for range 循环。
				例如：
					func main() {
						personSalary := map[string]int{
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						fmt.Println("All items of a map")
						for key, value := range personSalary {
							fmt.Printf("personSalary[%s] = %d\n", key, value)
						}
					}
				注意：
					当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。

		删除 map 中的元素：
			语法：
				delete(map, key)
				这个函数没有返回值。
					例如：
						func main() {
							personSalary := map[string]int{
								"steve": 12000,
								"jamie": 15000,
							}
							personSalary["mike"] = 9000
							fmt.Println("map before deletion", personSalary)
							delete(personSalary, "steve")
							fmt.Println("map after deletion", personSalary)
						}

		获取 map 的长度：
			len 函数：
				例如：
					func main() {
						personSalary := map[string]int{
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						fmt.Println("length is", len(personSalary))
					}

		Map 是引用类型：
			和 slices 类似，map 也是引用类型。
			当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。
			改变其中一个变量，就会影响到另一变量。
				例如：
					func main() {
						personSalary := map[string]int{
							"steve": 12000,
							"jamie": 15000,
						}
						personSalary["mike"] = 9000
						fmt.Println("Original person salary", personSalary)
						newPersonSalary := personSalary
						newPersonSalary["mike"] = 18000
						fmt.Println("Person salary changed", personSalary)
					}
			当 map 作为函数参数传递时也会发生同样的情况。
			函数中对 map 的任何修改，对于外部的调用都是可见的。

		Map 的相等性：
			map 之间不能使用 == 操作符判断，
			== 只能用来检查 map 是否为 nil。

	字符串：
		定义：
			Go 语言中的字符串是一个字节切片。把内容放在双引号""之间，我们可以创建一个字符串。
				例如：
					func main() {
						name := "Hello World"
					}
				Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。

		单独获取字符串的每一个字节：
			字符串是一个字节切片，所以我们可以获取字符串的每一个字节。
				例如：
					func printBytes(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%x ", s[i])
						}
					}
					func main() {
						name := "Hello World"
						printBytes(name)
					}
					上面的程序输出 48 65 6c 6c 6f 20 57 6f 72 6c 64。
					这些打印出来的字符是 "Hello World" 以 Unicode UTF-8 编码的结果。
				len(s)：返回字符串中字节的数量；
				%x ：格式限定符，用于指定 16 进制编码。

			Unicode 和 UTF-8：
				Unicode 是「字符集」；UTF-8 是「编码规则」。
				字符集：
					为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）
				编码规则：
					将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）
				Unicode 字符集：
					为每一个字符分配一个码位，
					例如「知」的码位是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。
				UTF-8 是一套以 8 位为一个编码单位的可变长编码；
					会将一个码位编码为 1 到 4 个字节：

			打印字符串的每一个字符：
				例如：
					func printBytes(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%x ", s[i])
						}
					}
					func printChars(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%c ",s[i])
						}
					}
					func main() {
						name := "Hello World"
						printBytes(name)
						fmt.Printf("\n")
						printChars(name)
					}
			上面的程序获取字符串的每一个字符，虽然看起来是合法的，但却有一个严重的 bug：
				例如：
					func printBytes(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%x ", s[i])
						}
					}
					func printChars(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%c ",s[i])
						}
					}
					func main() {
						name := "Hello World"
						printBytes(name)
						fmt.Printf("\n")
						printChars(name)
						fmt.Printf("\n")
						name = "Señor"
						printBytes(name)
						fmt.Printf("\n")
						printChars(name)
					}
				我们打印字符时，却假定每个字符的编码只会占用一个字节，这是错误的。
				在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。

		rune：
			rune 是 Go 语言的内建类型，它也是 int32 的别称。
			在 Go 中，rune 表示一个代码点。
			代码点无论占用多少个字节，都可以用一个 rune 来表示。
				例如：
					func printBytes(s string) {
						for i:= 0; i < len(s); i++ {
							fmt.Printf("%x ", s[i])
						}
					}
					func printChars(s string) {
						runes := []rune(s)
						for i:= 0; i < len(runes); i++ {
							fmt.Printf("%c ",runes[i])
						}
					}
					func main() {
						name := "Hello World"
						printBytes(name)
						fmt.Printf("\n")
						printChars(name)
						fmt.Printf("\n\n")
						name = "Señor"
						printBytes(name)
						fmt.Printf("\n")
						printChars(name)
					}

		字符串的 for range 循环：
			使用 rune 是一种遍历字符串的好方法，
			但是 Go 给我们提供了一种更简单的方法来做到这一点：使用 for range 循环。
				例如：
					func printCharsAndBytes(s string) {
						for index, rune := range s {
							fmt.Printf("%c starts at byte %d\n", rune, index)
						}
					}
					func main() {
						name := "Señor"
						printCharsAndBytes(name)
					}

		用字节切片构造字符串：
			例如：
				func main() {
					byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}
					str := string(byteSlice)
					fmt.Println(str)
				}
			如果把 16 进制换成对应的 10 进制值：
				例如：
					func main() {
						byteSlice := []byte{67, 97, 102, 195, 169}//decimal equivalent of {'\x43', '\x61', '\x66', '\xC3', '\xA9'}
						str := string(byteSlice)
						fmt.Println(str)
					}
			进制表示：
				二进制(Binary)：前缀 0b，后缀 B；
				八进制(Octal)：前缀 0，后缀 Q；
				十进制(Decimal)：前缀 \，后缀 D；
				十六进制(Hexadecimal)：前缀 0x，后缀 H。

		用 rune 切片构造字符串：
			例如：
				func main() {
					runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
					str := string(runeSlice)
					fmt.Println(str)
				}

		字符串的长度：
			获取字符串的长度：
				utf8 package 包中的 func RuneCountInString(s string) (n int) 方法；
				这个方法传入一个字符串参数然后返回字符串中的 rune 的数量。
					例如：
						func length(s string) {
							fmt.Printf("length of %s is %d\n", s, utf8.RuneCountInString(s))
						}
						func main() {
							word1 := "Señor"
							length(word1)
							word2 := "Pets"
							length(word2)
						}
					utf8.RuneCountInString()：字符数。

		字符串是不可变的：
			Go 中的字符串是不可变的：一旦一个字符串被创建，那么它将无法被修改。
				例如：
					func mutate(s string)string {
						s[0] = 'a'//any valid unicode character within single quote is a rune
						return s
					}
					func main() {
						h := "hello"
						fmt.Println(mutate(h))
					}
				由于字符串是不可变的，因此这个操作是非法的。
				所以程序抛出了一个错误 main.go:8: cannot assign to s[0]。
			为了修改字符串，可以把字符串转化为一个 rune 切片。
			然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。
				例如：
					func mutate(s []rune) string {
						s[0] = 'a'
						return string(s)
					}
					func main() {
						h := "hello"
						fmt.Println(mutate([]rune(h)))
					}
				mutate 函数接收一个 rune 切片参数，它将切片的第一个元素修改为 'a'，
					然后将 rune 切片转化为字符串，并返回该字符串。
				把 h 转化为一个 rune 切片，并传递给了 mutate。

	指针：
		定义：
			一种存储变量内存地址（Memory Address）的变量。
				例如：
					变量 b 的值为 156，而 b 的内存地址为 0x1040a124。
					变量 a 存储了 b 的地址。我们就称 a 指向了 b。

		指针的声明：
			指针变量的类型：*T，该指针指向一个 T 类型的变量。
			& 操作符用于获取变量的地址。
				例如：
					func main() {
						b := 255
						var a *int = &b
					}

		指针的零值（Zero Value）：
			指针的零值是 nil。
				例如：
					func main() {
						a := 25
						var b *int
						if b == nil {
							b = &a
							fmt.Println("b after initialization is", b)
						}
					}

		指针的解引用：
			指针的解引用可以获取指针所指向的变量的值。将 a 解引用的语法是 *a。
				例如：
					func main() {
						b := 255
						a := &b
						fmt.Println("value of b is", *a)
					}
			用指针来修改 b 的值：
				例如：
					func main() {
						b := 255
						a := &b
						fmt.Println("value of b is", *a)
						*a++
						fmt.Println("new value of b is", b)
					}

		向函数传递指针参数：
			例如：
				func change(val *int) {
					*val = 55
				}
				func main() {
					a := 58
					fmt.Println("value of a before function call is", a)
					b := &a
					change(b)
					fmt.Println("value of a after function call is", a)
				}
			向函数 change 传递了指针变量 b，而 b 存储了 a 的地址。
			在 change 函数内使用解引用，修改了 a 的值。

		不要向函数传递数组的指针，而应该使用切片：
			想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，
			一种解决方案是把一个指向数组的指针传递给这个函数。
				例如：
					func modify(arr *[3]int) {
						(*arr)[0] = 90
					}
					func main() {
						a := [3]int{89, 90, 91}
						modify(&a)
						fmt.Println(a)
					}
				将数组的地址传递给了 modify 函数。
				在 modify 函数里把 arr 解引用，并将 90 赋值给这个数组的第一个元素。
			a[x] 是 (*a)[x] 的简写形式，因此上面代码中的 (*arr)[0] 可以替换为 arr[0]。
				例如：
					func modify(arr *[3]int) {
						arr[0] = 90
					}
					func main() {
						a := [3]int{89, 90, 91}
						modify(&a)
						fmt.Println(a)
					}
			这种方式向函数传递一个数组指针参数，并在函数内修改数组。
			尽管它是有效的，但却不是 Go 语言惯用的实现方式。我们最好使用切片来处理。
				接下来我们用切片来重写之前的代码：
					func modify(sls []int) {
						sls[0] = 90
					}
					func main() {
						a := [3]int{89, 90, 91}
						modify(a[:])
						fmt.Println(a)
					}
				别再传递数组指针了，而是使用切片吧。
				使用切片的代码更加简洁，也更符合 Go 语言的习惯。

		Go 不支持指针运算
			Go 并不支持其他语言（例如 C）中的指针运算。
				例如：
					func main() {
						b := [...]int{109, 110, 111}
						p := &b
						p++
					}
				上面的程序会抛出编译错误：
					main.go:6: invalid operation: p++ (non-numeric type *[3]int)。

		指针变量和变量的指针：
			指针变量：
				是变量，该变量的指针指向另一个指针；
			变量指针：
				是指针，变量的指针。
				未被显式地初始化的变量，指针指向 nil；
				已被显式地初始化的变量，指针指向某个内存地址。

	结构体：
		结构体：
			用户定义的类型，表示若干个字段（Field）的集合。
			有时应该把数据整合在一起，而不是让这些数据没有联系，这种情况下可以使用结构体。

		结构体的声明：
			命名的结构体（Named Structure）：
				创建名为 Employee 的新类型，它可以用于创建 Employee 类型的结构体变量。
					例如：
						type Employee struct {
							firstName string
							lastName  string
							age       int
						}
				过把相同类型的字段声明在同一行，结构体可以变得更加紧凑。
					例如：
						type Employee struct {
							firstName, lastName string
							age, salary         int
						}
			匿名结构体（Anonymous Structure）：
				声明结构体时也可以不用声明一个新类型。
					例如：
						var employee struct {
							firstName, lastName string
							age int
						}
					上述代码片段创建一个匿名结构体 employee。

		创建命名的结构体：
			定义一个命名的结构体 Employee。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						//creating structure using field names
						emp1 := Employee{
							firstName: "Sam",
							age:       25,
							salary:    500,
							lastName:  "Anderson",
						}
						//creating structure without using field names
						emp2 := Employee{"Thomas", "Paul", 29, 800}
					}
				定义 emp2 时我们省略了字段名，这需要保证字段名的顺序与声明结构体时的顺序相同。

		创建匿名结构体：
			例如：
				func main() {
					emp3 := struct {
						firstName, lastName string
						age, salary         int
					}{
						firstName: "Andreah",
						lastName:  "Nikola",
						age:       31,
						salary:    5000,
					}
					fmt.Println("Employee 3", emp3)
				}
			只是创建一个新的结构体变量 em3，而没有定义任何结构体类型。

		结构体的零值（Zero Value）：
			当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						var emp4 Employee //zero valued structure
						fmt.Println("Employee 4", emp4)
					}
				该程序定义了 emp4，却没有初始化任何值。
					firstName 和 lastName 赋值为 string 的零值（""）。
					age 和 salary 赋值为 int 的零值（0）。
			还可以为某些字段指定初始值，而忽略其他字段，被忽略的字段名会赋值为零值。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						emp5 := Employee{
							firstName: "John",
							lastName:  "Paul",
						}
						fmt.Println("Employee 5", emp5)
					}
				firstName 和 lastName 初始化了，而 age 和 salary 没有进行初始化。
				age 和 salary 赋值为零值。

		访问结构体的字段：
			点号操作符 . 用于访问结构体的字段。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						emp6 := Employee{"Sam", "Anderson", 55, 6000}
						fmt.Println("First Name:", emp6.firstName)
						fmt.Println("Last Name:", emp6.lastName)
						fmt.Println("Age:", emp6.age)
						fmt.Printf("Salary: $%d", emp6.salary)
					}
			还可以创建零值的 struct，以后再给各个字段赋值。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						var emp7 Employee
						emp7.firstName = "Jack"
						emp7.lastName = "Adams"
						fmt.Println("Employee 7:", emp7)
					}

		结构体的指针：
			可以创建指向结构体的指针。
				例如：
					type Employee struct {
						firstName, lastName string
						age, salary         int
					}
					func main() {
						emp8 := &Employee{"Sam", "Anderson", 55, 6000}
						fmt.Println("First Name:", (*emp8).firstName)
						fmt.Println("Age:", (*emp8).age)
					}
				emp8 是一个指向结构体 Employee 的指针；
				(*emp8).firstName 表示访问结构体 emp8 的 firstName 字段。
			Go 允许我们在访问 firstName 字段时，可以使用 emp8.firstName，
				代替显式的解引用 (*emp8).firstName。
					例如：
						type Employee struct {
							firstName, lastName string
							age, salary         int
						}
						func main() {
							emp8 := &Employee{"Sam", "Anderson", 55, 6000}
							fmt.Println("First Name:", emp8.firstName)
							fmt.Println("Age:", emp8.age)
						}

		匿名字段：
			匿名字段（Anonymous Field）：
				创建结构体时，字段可以只有类型，而没有字段名。
					例如：
						type Person struct {
							string
							int
						}
					例如：
						type Person struct {
							string
							int
						}
						func main() {
							p := Person{"Naveen", 50}
							fmt.Println(p)
						}
				虽然匿名字段没有名称，其实匿名字段的名称默认为它的类型。
					例如：
						下面的 Person 结构体里，有两个名为 string 和 int 的字段。
					例如：
						type Person struct {
							string
							int
						}
						func main() {
							var p1 Person
							p1.string = "naveen"
							p1.int = 50
							fmt.Println(p1)
						}

		嵌套结构体（Nested Structs）：
			嵌套结构体：
				结构体的字段有可能也是一个结构体。
					例如：
						type Address struct {
							city, state string
						}
						type Person struct {
							name string
							age int
							address Address
						}
						func main() {
							var p Person
							p.name = "Naveen"
							p.age = 50
							p.address = Address {
								city: "Chicago",
								state: "Illinois",
							}
							fmt.Println("Name:", p.name)
							fmt.Println("City:",p.address.city)
						}

		提升字段（Promoted Fields）：
			提升字段：
				如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。
				这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。
					例如：
						type Address struct {
							city, state string
						}
						type Person struct {
							name string
							age  int
							Address
						}
						func main() {
							var p Person
							p.name = "Naveen"
							p.age = 50
							p.Address = Address{
								city:  "Chicago",
								state: "Illinois",
							}
							fmt.Println("Name:", p.name)
							fmt.Println("City:", p.city) //city is promoted field
							fmt.Println("State:", p.state) //state is promoted field
						}

		导出结构体和字段：
			如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。
			如果结构体里的字段首字母大写，它也能被其他包访问到。
				例如：
					package computer
					type Spec struct { //exported struct
						Maker string //exported field
						model string //unexported field
					}
				例如：
					package main
					import "structs/computer"
					import "fmt"
					func main() {
						var spec computer.Spec
						spec.Maker = "apple"
						spec.model = "Mac Mini"
						fmt.Println("Spec:", spec)
					}
				访问未导出的字段 model，编译器会报错：
					spec.model undefined (cannot refer to unexported field or method model)。

		结构体相等性（Structs Equality）：
			结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。
			如果两个结构体变量的对应字段相等，则这两个变量也是相等的。
				例如：
					type name struct {
						firstName string
						lastName string
					}
					func main() {
						name1 := name{"Steve", "Jobs"}
						name2 := name{"Steve", "Jobs"}
						if name1 == name2 {
							fmt.Println("name1 and name2 are equal")
						} else {
							fmt.Println("name1 and name2 are not equal")
						}
						name3 := name{firstName:"Steve", lastName:"Jobs"}
						name4 := name{}
						name4.firstName = "Steve"
						if name3 == name4 {
							fmt.Println("name3 and name4 are equal")
						} else {
							fmt.Println("name3 and name4 are not equal")
						}
					}
				name 包含两个 string 类型。
				由于字符串是可比较的，因此可以比较两个 name 类型的结构体变量。
				上面代码中 name1 和 name2 相等，而 name3 和 name4 不相等。
			如果结构体包含不可比较的字段，则结构体变量也不可比较。
				例如：
					type image struct {
						data map[int]int
					}
					func main() {
						image1 := image{data: map[int]int{
							0: 155,
						}}
						image2 := image{data: map[int]int{
							0: 155,
						}}
						if image1 == image2 {
							fmt.Println("image1 and image2 are equal")
						}
					}
				map 类型是不可比较的，因此 image1 和 image2 也不可比较。

	方法：
		方法：
			其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。
			接收器可以是结构体类型或者是非结构体类型。
			接收器是可以在方法的内部访问的。

		语法：
			创建一个接收器类型为 Type 的方法 methodName：
				func (t Type) methodName(parameter list) {
				}
			例如：
				type Employee struct {
					name     string
					salary   int
					currency string
				}
				/*
				  displaySalary() 方法将 Employee 做为接收器类型
				*/
				func (e Employee) displaySalary() {
					fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
				}
				func main() {
					emp1 := Employee {
						name:     "Sam Adolf",
						salary:   5000,
						currency: "$",
					}
					emp1.displaySalary() // 调用 Employee 类型的 displaySalary() 方法
				}

		为什么已经有函数了还需要方法：
			Go 不是纯粹的面向对象编程语言，而且 Go 不支持类。
				因此，基于类型的方法是一种实现和类相似行为的途径。
			相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。
				假设我们有一个 Square 和 Circle 结构体。
				可以在 Square 和 Circle 上分别定义一个 Area 方法。
					例如：
						type Rectangle struct {
							length int
							width  int
						}
						type Circle struct {
							radius float64
						}
						func (r Rectangle) Area() int {
							return r.length * r.width
						}
						func (c Circle) Area() float64 {
							return math.Pi * c.radius * c.radius
						}
						func main() {
							r := Rectangle{
								length: 10,
								width:  5,
							}
							fmt.Printf("Area of rectangle %d\n", r.Area())
							c := Circle{
								radius: 12,
							}
							fmt.Printf("Area of circle %f", c.Area())
						}

		指针接收器与值接收器：
			除了创建使用值接收器的方法，还可以创建使用指针接收器的方法。
			值接收器和指针接收器之间的区别：
				在指针接收器的方法内部的改变对于调用者是可见的，
				然而值接收器的情况不是这样的。
					例如：
						type Employee struct {
							name string
							age  int
						}
						/*
						使用值接收器的方法。
						*/
						func (e Employee) changeName(newName string) {
							e.name = newName
						}
						/*
						使用指针接收器的方法。
						*/
						func (e *Employee) changeAge(newAge int) {
							e.age = newAge
						}
						func main() {
							e := Employee{
								name: "Mark Andrew",
								age:  50,
							}
							fmt.Printf("Employee name before change: %s", e.name)
							e.changeName("Michael Andrew")
							fmt.Printf("\nEmployee name after change: %s", e.name)

							fmt.Printf("\n\nEmployee age before change: %d", e.age)
							(&e).changeAge(51)
							fmt.Printf("\nEmployee age after change: %d", e.age)
						}
					changeName 方法中对 Employee 结构体的字段 name 所做的改变对调用者是不可见的，
					changeAge 方法是使用指针 (e *Employee) 接收器的，
						所以在调用 (&e).changeAge(51) 方法对 age 字段做出的改变对调用者将是可见的。
					由于 changeAge 方法有一个指针接收器，所以我们使用 (&e) 来调用这个方法。
						其实没有这个必要，Go 语言让我们可以直接使用 e.changeAge(51)。
						e.changeAge(51) 会自动被 Go 语言解释为 (&e).changeAge(51)。

		值接收器和指针接收器的使用：
			指针接收器可以使用在：
				对方法内部的接收器所做的改变应该对调用者可见时。
			指针接收器也可以被使用在如下场景：
				当拷贝一个结构体的代价过于昂贵时。
					考虑下一个结构体有很多的字段。
					在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。
					在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。
			在其他的所有情况，值接收器都可以被使用。

		匿名字段的方法：
			属于结构体的匿名字段的方法可以被直接调用，
			就好像这些方法是属于定义了匿名字段的结构体一样。
				例如：
					type address struct {
						city  string
						state string
					}
					func (a address) fullAddress() {
						fmt.Printf("Full address: %s, %s", a.city, a.state)
					}
					type person struct {
						firstName string
						lastName  string
						address
					}
					func main() {
						p := person{
							firstName: "Elon",
							lastName:  "Musk",
							address: address {
								city:  "Los Angeles",
								state: "California",
							},
						}
						p.fullAddress() //访问 address 结构体的 fullAddress 方法
					}
				明确的调用 p.address.fullAddress() 是没有必要的。

		在方法中使用值接收器 与 在函数中使用值参数：
			当一个函数有一个值参数，它只能接受一个值参数。
			当一个方法有一个值接收器，它可以接受值接收器和指针接收器。
				例如：
					type rectangle struct {
						length int
						width  int
					}
					func area(r rectangle) {
						fmt.Printf("Area Function result: %d\n", (r.length * r.width))
					}
					func (r rectangle) area() {
						fmt.Printf("Area Method result: %d\n", (r.length * r.width))
					}
					func main() {
						r := rectangle{
							length: 10,
							width:  5,
						}
						area(r)
						r.area()

						p := &r
						/*
						   compilation error, cannot use p (type *rectangle) as type rectangle
						   in argument to area
						*/
						//area(p)
						p.area()//通过指针调用值接收器
					}
				把指针传递到只能接受一个值参数的函数 area，编译器将会报错。
				使用指针接收器 p 调用了只接受一个值接收器的方法 area，这是完全有效的。
				因为当 area 有一个值接收器时，为了方便 Go 语言把 p.area() 解释为 (*p).area()。

		在方法中使用指针接收器 与 在函数中使用指针参数：
			函数使用指针参数只接受指针，和值参数相类似；
			使用指针接收器的方法可以使用值接收器和指针接收器。
				例如：
					type rectangle struct {
						length int
						width  int
					}
					func perimeter(r *rectangle) {
						fmt.Println("perimeter function output:", 2*(r.length+r.width))
					}
					func (r *rectangle) perimeter() {
						fmt.Println("perimeter method output:", 2*(r.length+r.width))
					}
					func main() {
						r := rectangle{
							length: 10,
							width:  5,
						}
						p := &r //pointer to r
						perimeter(p)
						p.perimeter()
						/*
							cannot use r (type rectangle) as type *rectangle in argument to perimeter
						*/
						//perimeter(r)
						r.perimeter()//使用值来调用指针接收器
					}
				通过传入值参数 r 调用函数 perimeter，这是不被允许的，
					因为函数的指针参数不接受值参数。
				通过值接收器 r 来调用有指针接收器的方法 perimeter，这是被允许的，
					为了方便 Go 把代码 r.perimeter() 解释为 (&r).perimeter()。

		非结构体上的方法：
			可以在结构体类型上定义方法，也可以在非结构体类型上定义方法；
				为了在一个类型上定义一个方法，方法的接收器类型定义和方法的定义应该在同一个包中。
					反例：
						package main
						func (a int) add(b int) {
						}
						func main() {
						}
					试把一个 add 方法添加到内置的类型 int，这是不允许的；
					因为 add 方法的定义和 int 类型的定义不在同一个包中。
					该程序会抛出编译错误：cannot define new methods on non-local type int。
				让该程序工作的方法是为内置类型 int 创建一个类型别名，
				然后创建一个以该类型别名为接收器的方法。
					例如：
						type myInt int
						func (a myInt) add(b myInt) myInt {
							return a + b
						}
						func main() {
							num1 := myInt(5)
							num2 := myInt(10)
							sum := num1.add(num2)
							fmt.Println("Sum is", sum)
						}

	接口：
		接口：
			定义一个对象的行为。
				只指定对象应该做什么，如何实现这个行为（即实现细节），则由对象本身去确定。
			在 Go 中，接口就是方法签名（Method Signature）的集合。
				当一个类型定义了接口中的所有方法，我们称它实现了该接口。
			这与面向对象编程（OOP）的说法很类似：
				接口指定一个类型应该具有的方法，并由该类型决定如何实现这些方法。
			例如：
				WashingMachine 是一个含有 Cleaning() 和 Drying() 两个方法的接口。
				任何定义了 Cleaning() 和 Drying() 的类型，都称它实现了 WashingMachine 接口。

		接口的声明与实现：
			其他一些语言（如 Java）要求一个类使用 implement 关键字，来显式地声明该类实现了接口。
			在 Go 中，并不需要这样。
				如果一个类型包含了接口中声明的所有方法，那么它就隐式地实现了 Go 接口。
			例如：
				//interface definition
				type VowelsFinder interface {
					FindVowels() []rune
				}
				type MyString string
				//MyString implements VowelsFinder
				func (ms MyString) FindVowels() []rune {
					var vowels []rune
					for _, rune := range ms {
						if rune == 'a' || rune == 'e' || rune == 'i' || rune == 'o' || rune == 'u' {
							vowels = append(vowels, rune)
						}
					}
					return vowels
				}
				func main() {
					name := MyString("Sam Anderson")
					var v VowelsFinder
					v = name // possible since MyString implements VowelsFinder
					fmt.Printf("Vowels are %c", v.FindVowels())

				}
			如果使用 name.FindVowels()，而不是 v.FindVowels()，程序依然能够照常运行，
			但接口并没有体现出实际价值。

		接口的实际用途：
			根据公司员工的个人薪资，计算公司的总支出。
				例如：
					type SalaryCalculator interface {
						CalculateSalary() int
					}
					type Permanent struct {
						empId    int
						basicpay int
						pf       int
					}
					type Contract struct {
						empId  int
						basicpay int
					}
					//salary of permanent employee is sum of basic pay and pf
					func (p Permanent) CalculateSalary() int {
						return p.basicpay + p.pf
					}
					//salary of contract employee is the basic pay alone
					func (c Contract) CalculateSalary() int {
						return c.basicpay
					}
					/*
					total expense is calculated by iterating though the SalaryCalculator slice and summing
					the salaries of the individual employees
					*/
					func totalExpense(s []SalaryCalculator) {
						expense := 0
						for _, v := range s {
							expense = expense + v.CalculateSalary()
						}
						fmt.Printf("Total Expense Per Month $%d", expense)
					}
					func main() {
						pemp1 := Permanent{1, 5000, 20}
						pemp2 := Permanent{2, 6000, 30}
						cemp1 := Contract{3, 3000}
						employees := []SalaryCalculator{pemp1, pemp2, cemp1}
						totalExpense(employees)
					}
				SalaryCalculator 接口的切片（[]SalaryCalculator）作为参数，
				通过调用不同类型对应的 CalculateSalary 方法，totalExpense 可以计算得到支出。

		接口的内部表示：
			可以把接口看作内部的一个元组 (type, value)。
			type 是接口底层的具体类型（Concrete Type），而 value 是具体类型的值。
				例如：
					type Test interface {
						Tester()
					}

					type MyFloat float64

					func (m MyFloat) Tester() {
						fmt.Println(m)
					}

					func describe(t Test) {
						fmt.Printf("Interface type %T value %v\n", t, t)
					}

					func main() {
						var t Test
						f := MyFloat(89.7)
						t = f
						describe(t)
						t.Tester()
					}
				describe 函数打印出了接口的具体类型和值。

		空接口：
			没有包含方法的接口称为空接口。
			空接口表示为 interface{}。
			由于空接口没有方法，因此所有类型都实现了空接口。
				例如：
					func describe(i interface{}) {
						fmt.Printf("Type = %T, value = %v\n", i, i)
					}

					func main() {
						s := "Hello World"
						describe(s)
						i := 55
						describe(i)
						strt := struct {
							name string
						}{
							name: "Naveen R",
						}
						describe(strt)
					}
				describe(i interface{}) 函数接收空接口作为参数，因此，可以给这个函数传递任何类型。

		类型断言：
			类型断言：
				用于提取接口的底层值（Underlying Value）。

			语法：i.(T)
				接口 i 的具体类型是 T，该语法用于获得接口的底层值。
					例如：
						func assert(i interface{}) {
							s := i.(int) //get the underlying int value from i
							fmt.Println(s)
						}
						func main() {
							var s interface{} = 56
							assert(s)
						}
					如果具体类型不是 int：
						func assert(i interface{}) {
							s := i.(int) //get the underlying int value from i
							fmt.Println(s)
						}
						func main() {
							var s interface{} = "Steven Paul"
							assert(s)
						}
					程序会报错：panic: interface conversion: interface {} is string, not int.。
			要解决该问题，我们可以使用以下语法：
				v, ok := i.(T)
				如果 i 的具体类型是 T，那么 v 赋值为 i 的底层值，而 ok 赋值为 true。
				如果 i 的具体类型不是 T，那么 ok 赋值为 false，v 赋值为 T 类型的零值，此时程序不会报错。
					例如：
						func assert(i interface{}) {
							v, ok := i.(int)
							fmt.Println(v, ok)
						}
						func main() {
							var s interface{} = 56
							assert(s)
							var i interface{} = "Steven Paul"
							assert(i)
						}
					由于 i 的具体类型不是 int，ok 赋值为 false，而 v 赋值为 0（int 的零值）。

		类型选择（Type Switch）：
			类型选择用于将接口的具体类型与很多 case 语句所指定的类型进行比较。
				它与一般的 switch 语句类似；
				唯一的区别在于类型选择指定的是类型，而一般的 switch 指定的是值。

			类型选择的语法：
				i.(type)
				类似于类型断言，类型 T 由关键字 type 代替。
					例如：
						func findType(i interface{}) {
							switch i.(type) {
							case string:
								fmt.Printf("I am a string and my value is %s\n", i.(string))
							case int:
								fmt.Printf("I am an int and my value is %d\n", i.(int))
							default:
								fmt.Printf("Unknown type\n")
							}
						}
						func main() {
							findType("Naveen")
							findType(77)
							findType(89.98)
						}
				还可以将一个类型和接口相比较。
				如果一个类型实现了接口，那么该类型与其实现的接口就可以互相比较。
					例如：
						type Describer interface {
							Describe()
						}
						type Person struct {
							name string
							age  int
						}

						func (p Person) Describe() {
							fmt.Printf("%s is %d years old", p.name, p.age)
						}

						func findType(i interface{}) {
							switch v := i.(type) {
							case Describer:
								v.Describe()
							default:
								fmt.Printf("unknown type\n")
							}
						}

						func main() {
							findType("Naveen")
							p := Person{
								name: "Naveen R",
								age:  25,
							}
							findType(p)
						}

	接口（二）：
		实现接口：指针接收器与值接收器；
			上面的示例都是使用值接收器（Value Receiver）来实现接口的。
			也可以使用指针接收器（Pointer Receiver）来实现接口，
			只不过在用指针接收器实现接口时，还有一些细节需要注意。
				例如：
					type Describer interface {
						Describe()
					}
					type Person struct {
						name string
						age  int
					}
					func (p Person) Describe() { // 使用值接收器实现
						fmt.Printf("%s is %d years old\n", p.name, p.age)
					}
					type Address struct {
						state   string
						country string
					}
					func (a *Address) Describe() { // 使用指针接收器实现
						fmt.Printf("State %s Country %s", a.state, a.country)
					}
					func main() {
						var d1 Describer
						p1 := Person{"Sam", 25}
						d1 = p1
						d1.Describe()
						p2 := Person{"James", 32}
						d1 = &p2
						d1.Describe()
						var d2 Describer
						a := Address{"Washington", "USA"}

						/* 如果下面一行取消注释会导致编译错误：
						   cannot use a (type Address) as type Describer
						   in assignment: Address does not implement
						   Describer (Describe method has pointer
						   receiver)
						*/
						//d2 = a
						d2 = &a // 这是合法的
						// 因为在第 22 行，Address 类型的指针实现了 Describer 接口
						d2.Describe()
					}
				使用值接收器声明的方法，既可以用值来调用，也能用指针调用。
					不管是一个值，还是一个可以解引用的指针，调用这样的方法都是合法的。
				对于使用指针接收器的方法，用一个指针或者一个可取得地址的值来调用都是合法的。
					但接口中存储的具体值（Concrete Value）并不能取到地址，因此在第 45 行，对于编译器无法自动获取 a 的地址，于是程序报错。

		实现多个接口：
			类型可以实现多个接口。
				例如：
					type SalaryCalculator interface {
						DisplaySalary()
					}
					type LeaveCalculator interface {
						CalculateLeavesLeft() int
					}
					type Employee struct {
						firstName string
						lastName string
						basicPay int
						pf int
						totalLeaves int
						leavesTaken int
					}
					func (e Employee) DisplaySalary() {
						fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
					}
					func (e Employee) CalculateLeavesLeft() int {
						return e.totalLeaves - e.leavesTaken
					}
					func main() {
						e := Employee {
							firstName: "Naveen",
							lastName: "Ramanathan",
							basicPay: 5000,
							pf: 200,
							totalLeaves: 30,
							leavesTaken: 5,
						}
						var s SalaryCalculator = e
						s.DisplaySalary()
						var l LeaveCalculator = e
						fmt.Println("\nLeaves left =", l.CalculateLeavesLeft())
					}

		接口的嵌套：
			尽管 Go 没有提供继承机制，但可以通过嵌套其他的接口，创建一个新接口。
				例如：
					type SalaryCalculator interface {
						DisplaySalary()
					}
					type LeaveCalculator interface {
						CalculateLeavesLeft() int
					}
					type EmployeeOperations interface {
						SalaryCalculator
						LeaveCalculator
					}
					type Employee struct {
						firstName string
						lastName string
						basicPay int
						pf int
						totalLeaves int
						leavesTaken int
					}
					func (e Employee) DisplaySalary() {
						fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
					}
					func (e Employee) CalculateLeavesLeft() int {
						return e.totalLeaves - e.leavesTaken
					}
					func main() {
						e := Employee {
							firstName: "Naveen",
							lastName: "Ramanathan",
							basicPay: 5000,
							pf: 200,
							totalLeaves: 30,
							leavesTaken: 5,
						}
						var empOp EmployeeOperations = e
						empOp.DisplaySalary()
						fmt.Println("\nLeaves left =", empOp.CalculateLeavesLeft())
					}
				EmployeeOperations 嵌套了两个接口：SalaryCalculator 和 LeaveCalculator。
				如果一个类型定义了 SalaryCalculator 和 LeaveCalculator 接口里包含的方法，
					我们就称该类型实现了 EmployeeOperations 接口。

		接口的零值：
			接口的零值是 nil。
			对于值为 nil 的接口，其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。
				例如：
					type Describer interface {
						Describe()
					}
					func main() {
						var d1 Describer
						if d1 == nil {
							fmt.Printf("d1 is nil and has type %T value %v\n", d1, d1)
						}
					}
			对于值为 nil 的接口，由于没有底层值和具体类型，当我们试图调用它的方法时，程序会产生 panic 异常。
				例如：
					type Describer interface {
						Describe()
					}
					func main() {
						var d1 Describer
						d1.Describe()
					}
				程序产生运行时错误 panic：
					panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xc8527] 。

	并发入门：
		并发：
			立即处理多个任务的能力。

		并行：
			同时处理多个任务。

		并发和并行：
			并发的进程从不同的时间点开始，分别交替运行。
			并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。
			在并发系统上，这种通信开销很小。
			但在多核的并行系统上，组件间的通信开销就很高了。

		Go 对并发的支持：
			Go 原生支持并发。
			Go 使用 Go 协程（Goroutine） 和信道（Channel）来处理并发。

	Go 协程：
		Go 协程：
			Go 协程是与其他函数或方法一起并发运行的函数或方法。
			Go 协程可以看作是轻量级线程。
			与线程相比，创建一个 Go 协程的成本很小。
			因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。

		协程优势：
			相比线程而言，Go 协程的成本极低。
				堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。
				而线程必须指定堆栈的大小，其堆栈是固定不变的。
			Go 协程会复用（Multiplex）数量更少的 OS 线程。
				即使程序有数以千计的 Go 协程，也可能只有一个线程。
				如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），
				那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。
				所有这一切都在运行时进行，有一个简洁的 API 来处理并发。
			Go 协程使用信道（Channel）来进行通信。
				信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。
				信道可以看作是 Go 协程之间通信的管道。

		启动一个 Go 协程：
			调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。
				例如：
					func hello() {
						fmt.Println("Hello world goroutine")
					}
					func main() {
						go hello()
						fmt.Println("main function")
					}
				go hello() 启动了一个新的 Go 协程。现在 hello() 函数与 main() 函数会并发地执行。
			主函数会运行在一个特有的 Go 协程上，它称为 Go 主协程（Main Goroutine）。
			两个 Go 协程的主要性质：
				启动一个新的协程时，协程的调用会立即返回。
					与函数不同，程序控制不会去等待 Go 协程执行完毕。
					在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。
				如果希望运行其他 Go 协程，Go 主协程必须继续运行着。
					如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。
			Go 主协程终止，于是 hello 协程就没有机会运行了。
			信道可用于在其他协程结束执行之前，阻塞 Go 主协程。

		启动多个 Go 协程：
			例如：
				func numbers() {
					for i := 1; i <= 5; i++ {
						time.Sleep(250 * time.Millisecond)
						fmt.Printf("%d ", i)
					}
				}
				func alphabets() {
					for i := 'a'; i <= 'e'; i++ {
						time.Sleep(400 * time.Millisecond)
						fmt.Printf("%c ", i)
					}
				}
				func main() {
					go numbers()
					go alphabets()
					time.Sleep(3000 * time.Millisecond)
					fmt.Println("main terminated")
				}
			numbers 协程首先休眠 250 微秒，接着打印 1，然后再次休眠，打印 2，
			依此类推，一直到打印 5 结束。
			alphabete 协程同样打印从 a 到 e 的字母，并且每次有 400 微秒的休眠时间。
			Go 主协程启动了 numbers 和 alphabete 两个 Go 协程，休眠了 3000 微秒后终止程序。

	信道（channel）：
		信道：
			可以想像成 Go 协程之间通信的管道。
			如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。

		信道的声明：
			所有信道都关联了一个类型。
				信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。
			chan T 表示 T 类型的信道。
				信道的零值为 nil。
				信道的零值没有什么用，应该像对 map 和切片所做的那样，用 make 来定义信道。
					例如：
						func main() {
							var a chan int
							if a == nil {
								fmt.Println("channel a is nil, going to define it")
								a = make(chan int)
								fmt.Printf("Type of a is %T", a)
							}
						}
			简短声明通常也是一种定义信道的简洁有效的方法。
				例如：
					a := make(chan int)
					定义一个 int 类型的信道 a。

		通过信道进行发送和接收：
			语法：
				data := <- a // 读取信道 a
				a <- data // 写入信道 a
			信道旁的箭头方向指定了是发送数据还是接收数据。
				第一行，箭头对于 a 来说是向外指的，
					因此我们读取了信道 a 的值，并把该值存储到变量 data。
				第二行，箭头指向了 a，因此我们在把数据写入信道 a。

		发送与接收默认是阻塞的：
			当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，
				直到有其它 Go 协程从信道读取到数据，才会解除阻塞。
			与此类似，当读取信道的数据时，
				如果没有其它的协程把数据写入到这个信道，那么读取过程就会一直阻塞着。

		协程之间的信道通信：
			例如：
				func hello(done chan bool) {
					fmt.Println("Hello world goroutine")
					done <- true
				}
				func main() {
					done := make(chan bool)
					go hello(done)
					<-done
					fmt.Println("main function")
				}
			主协程会在 <-done 这一行发生阻塞，等待来自信道 done 的数据。
			<-done 这行代码通过协程（译注：原文笔误，信道）done 接收数据，
				但并没有使用数据或者把数据存储到变量中，这完全是合法的。

		计算一个数中每一位的平方和与立方和，然后把平方和与立方和相加并打印出来。
			在一个单独的 Go 协程计算平方和，而在另一个协程计算立方和，
			最后在 Go 主协程把平方和与立方和相加。
			例如：
				func calcSquares(number int, squareop chan int) {
					sum := 0
					for number != 0 {
						digit := number % 10
						sum += digit * digit
						number /= 10
					}
					squareop <- sum
				}
				func calcCubes(number int, cubeop chan int) {
					sum := 0
					for number != 0 {
						digit := number % 10
						sum += digit * digit * digit
						number /= 10
					}
					cubeop <- sum
				}
				func main() {
					number := 589
					sqrch := make(chan int)
					cubech := make(chan int)
					go calcSquares(number, sqrch)
					go calcCubes(number, cubech)
					squares, cubes := <-sqrch, <-cubech
					fmt.Println("Final output", squares + cubes)
				}

		死锁：
			使用信道需要考虑的一个重点是死锁。
			当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。
			如果没有的话，程序就会在运行时触发 panic，形成死锁。

		单向信道：
			双向信道：通过信道既能发送数据，又能接收数据。
			单向信道：只能发送或者接收数据。
				语法：
					make(chan<- int)
				例如：
					func sendData(sendch chan<- int) {
						sendch <- 10
					}

					func main() {
						sendch := make(chan<- int)
						go sendData(sendch)
						fmt.Println(<-sendch)
					}
				chan<- int 定义了唯送信道，因为箭头指向了 chan。
				试图通过唯送信道接收数据，编译器报错：
					main.go:11: invalid operation: <-sendch (receive from send-only type chan<- int)
			不能读取数据的唯送信道究竟有什么意义：
				这就需要用到信道转换（Channel Conversion）了。
				把一个双向信道转换成唯送信道或者唯收（Receive Only）信道都是行得通的，
				但是反过来就不行。
					例如：
						func sendData(sendch chan<- int) {
							sendch <- 10
						}
						func main() {
							cha1 := make(chan int)
							go sendData(cha1)
							fmt.Println(<-cha1)
						}
					函数 sendData 里的参数 sendch chan<- int 把 cha1 转换为一个唯送信道。
					于是该信道在 sendData 协程里是一个唯送信道，而在 Go 主协程里是一个双向信道。

		关闭信道：
			数据发送方可以关闭信道，通知接收方这个信道不再有数据发送过来。
			当从信道接收数据时，接收方可以多用一个变量来检查信道是否已经关闭。
				v, ok := <- ch
					如果成功接收信道所发送的数据，那么 ok 等于 true。
					而如果 ok 等于 false，说明我们试图读取一个关闭的通道。
					从关闭的信道读取到的值会是该信道类型的零值。
						例如：
							当信道是一个 int 类型的信道时，那么从关闭的信道读取的值将会是 0。
					例如：
						func producer(chnl chan int) {
							for i := 0; i < 10; i++ {
								chnl <- i
							}
							close(chnl)
						}
						func main() {
							ch := make(chan int)
							go producer(ch)
							for {
								v, ok := <-ch
								if ok == false {
									break
								}
								fmt.Println("Received ", v, ok)
							}
						}

		for range 遍历信道：
			for range 循环用于在一个信道关闭之前，从信道接收数据。
				例如：
					func producer(chnl chan int) {
						for i := 0; i < 10; i++ {
							chnl <- i
						}
						close(chnl)
					}
					func main() {
						ch := make(chan int)
						go producer(ch)
						for v := range ch {
							fmt.Println("Received ",v)
						}
					}
				for range 循环从信道 ch 接收数据，直到该信道关闭。
				一旦关闭了 ch，循环会自动结束。
			计算一个数中每一位的平方和与立方和，然后把平方和与立方和相加并打印出来。
				例如：
					func digits(number int, dchnl chan int) {
						for number != 0 {
							digit := number % 10
							dchnl <- digit
							number /= 10
						}
						close(dchnl)
					}
					func calcSquares(number int, squareop chan int) {
						sum := 0
						dch := make(chan int)
						go digits(number, dch)
						for digit := range dch {
							sum += digit * digit
						}
						squareop <- sum
					}

					func calcCubes(number int, cubeop chan int) {
						sum := 0
						dch := make(chan int)
						go digits(number, dch)
						for digit := range dch {
							sum += digit * digit * digit
						}
						cubeop <- sum
					}

					func main() {
						number := 589
						sqrch := make(chan int)
						cubech := make(chan int)
						go calcSquares(number, sqrch)
						go calcCubes(number, cubech)
						squares, cubes := <-sqrch, <-cubech
						fmt.Println("Final output", squares+cubes)
					}
				calcSquares 和 calcCubes 两个函数并发地调用了 digits。
				calcSquares 和 calcCubes 两个协程使用 for range 循环分别监听了它们的信道，直到该信道关闭。

	缓冲信道和工作池（Buffered Channels and Worker Pools）：
		缓冲信道：
			只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。
			只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。

		语法：
			ch := make(chan type, capacity)
				要让一个信道有缓冲，上面语法中的 capacity 应该大于 0；缓冲信道的容量默认为 0。

		创建：
			通过向 make 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。
				例如：
					func main() {
						ch := make(chan string, 2)
						ch <- "naveen"
						ch <- "paul"
						fmt.Println(<- ch)
						fmt.Println(<- ch)
					}
					该信道的容量为 2，因此可向它写入两个字符串，而且不会发生阻塞。
				例如：
					func write(ch chan int) {
						for i := 0; i < 5; i++ {
							ch <- i
							fmt.Println("successfully wrote", i, "to ch")
						}
						close(ch)
					}
					func main() {
						ch := make(chan int, 2)
						go write(ch)
						time.Sleep(2 * time.Second)
						for v := range ch {
							fmt.Println("read value", v,"from ch")
							time.Sleep(2 * time.Second)

						}
					}

		死锁：
			例如：
				func main() {
					ch := make(chan string, 2)
					ch <- "naveen"
					ch <- "paul"
					ch <- "steve"
					fmt.Println(<-ch)
					fmt.Println(<-ch)
				}
			没有并发协程来读取这个信道，因此这里会发生死锁（deadlock）。

		长度 vs 容量：
			缓冲信道的容量是指信道可以存储的值的数量。
			我们在使用 make 函数创建缓冲信道的时候会指定容量大小。
			缓冲信道的长度是指信道中当前排队的元素个数。
				例如：
					func main() {
						ch := make(chan string, 3)
						ch <- "naveen"
						ch <- "paul"
						fmt.Println("capacity is", cap(ch))
						fmt.Println("length is", len(ch))
						fmt.Println("read value", <-ch)
						fmt.Println("new length is", len(ch))
					}

		WaitGroup：
			WaitGroup 用于实现工作池（Worker Pools），要理解工作池，首先需要学习 WaitGroup。
			WaitGroup 用于等待一批 Go 协程执行结束。
				程序控制会一直阻塞，直到这些协程全部执行完毕。
					假设我们有 3 个并发执行的 Go 协程（由 Go 主协程生成）。
					Go 主协程需要等待这 3 个协程执行结束后，才会终止。
					这就可以用 WaitGroup 来实现。
				例如：
					func process(i int, wg *sync.WaitGroup) {
						fmt.Println("started Goroutine ", i)
						time.Sleep(2 * time.Second)
						fmt.Printf("Goroutine %d ended\n", i)
						wg.Done()
					}
					func main() {
						no := 3
						var wg sync.WaitGroup
						for i := 0; i < no; i++ {
							wg.Add(1)
							go process(i, &wg)
						}
						wg.Wait()
						fmt.Println("All go routines finished executing")
					}
				第 21 行里，传递 wg 的地址是很重要的。
					如果没有传递 wg 的地址，那么每个 Go 协程将会得到一个 WaitGroup 值的拷贝，
					因而当它们执行结束时，main 函数并不会知道。
			WaitGroup 是一个结构体类型，其初始值为零值。
			WaitGroup 使用计数器来工作。
				调用 WaitGroup 的 Add 并传递一个 int 时，WaitGroup 的计数器会加上 Add 的传参。
				要减少计数器，可以调用 WaitGroup 的 Done() 方法。
				Wait() 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。

		工作池的实现：
			缓冲信道的重要应用之一就是实现工作池。
			工作池就是一组等待任务分配的线程。
				一旦完成了所分配的任务，这些线程可继续等待任务的分配。
			计算所输入数字的每一位的和。
				例如：
					type Job struct {
						id       int
						randomno int
					}
					type Result struct {
						job         Job
						sumofdigits int
					}
					var jobs = make(chan Job, 10)
					var results = make(chan Result, 10)
					func digits(number int) int {
						sum := 0
						no := number
						for no != 0 {
							digit := no % 10
							sum += digit
							no /= 10
						}
						time.Sleep(2 * time.Second)
						return sum
					}
					func worker(wg *sync.WaitGroup) {
						for job := range jobs {
							output := Result{job, digits(job.randomno)}
							results <- output
						}
						wg.Done()
					}
					func createWorkerPool(noOfWorkers int) {
						var wg sync.WaitGroup
						for i := 0; i < noOfWorkers; i++ {
							wg.Add(1)
							go worker(&wg)
						}
						wg.Wait()
						close(results)
					}
					func allocate(noOfJobs int) {
						for i := 0; i < noOfJobs; i++ {
							randomno := rand.Intn(999)
							job := Job{i, randomno}
							jobs <- job
						}
						close(jobs)
					}
					func result(done chan bool) {
						for result := range results {
							fmt.Printf("Job id %d, input random no %d , sum of digits %d\n", result.job.id, result.job.randomno, result.sumofdigits)
						}
						done <- true
					}
					func main() {
						startTime := time.Now()
						noOfJobs := 100
						go allocate(noOfJobs)
						done := make(chan bool)
						go result(done)
						noOfWorkers := 10
						createWorkerPool(noOfWorkers)
						<-done
						endTime := time.Now()
						diff := endTime.Sub(startTime)
						fmt.Println("total time taken ", diff.Seconds(), "seconds")
					}
					
	Select：
		select 语句：
			用于在多个发送/接收信道操作中进行选择。
				select 语句会一直阻塞，直到发送/接收操作准备就绪。
				如果有多个信道操作准备完毕，select 会随机地选取其中之一执行。
				该语法与 switch 类似，所不同的是，这里的每个 case 语句都是信道操作。
					例如：
						select {
							case s1 := <-output1:
								fmt.Println(s1)
							case s2 := <-output2:
								fmt.Println(s2)
							default:
								fmt.Println("no value received")
						}
					
		死锁与默认情况：
			如果存在默认情况，就不会发生死锁，因为在没有其他 case 准备就绪时，会执行默认情况。
				反例：
					func main() {  
						ch := make(chan string)
						select {
							case <-ch:
						}
					}
				在 select 内部，试图读取信道 ch。
				由于没有 Go 协程向该信道写入数据，因此 select 语句会一直阻塞，导致死锁。
			如果 select 只含有值为 nil 的信道，也同样会执行默认情况。
				例如：
					func main() {  
						var ch chan string
						select {
							case v := <-ch:
								fmt.Println("received value", v)
							default:
								fmt.Println("default case executed")
						}
					}
				ch 等于 nil，而我们试图在 select 中读取 ch（第 8 行）。如果没有默认情况，select 会一直阻塞，导致死锁。
					
		随机选取：
			当 select 由多个 case 准备就绪时，将会随机地选取其中之一去执行。
					
		空 select：
			除非有 case 执行，select 语句就会一直阻塞着。
			如果 select 语句没有任何 case，它会一直阻塞，导致死锁。
					
	Mutex：
		临界区：
			临界区（Critical Section）：
				当程序并发地运行时，多个 Go 协程不应该同时访问那些修改共享资源的代码。
				这些修改共享资源的代码称为临界区。
			竞态条件（Race Condition）：
				程序的输出是由协程的执行顺序决定，这种不太理想的情况；
				根据上下文切换的不同情形，x 的最终值是 1 或者 2。
		Mutex：
			用于提供一种加锁机制（Locking Mechanism），可确保在某时刻只有一个协程在临界区运行，以防止出现竞态条件。
			Mutex 定义了两个方法：Lock 和 Unlock。
				所有在 Lock 和 Unlock 之间的代码，都只能由一个 Go 协程执行，于是就可以避免竞态条件。
					例如：
						mutex.Lock()  
						x = x + 1  
						mutex.Unlock()
				如果有一个 Go 协程已经持有了锁（Lock），当其他协程试图获得该锁时，这些协程会被阻塞，直到 Mutex 解除锁定为止。
			含有竞态条件的程序：
				例如：
					var x  = 0  
						func increment(wg *sync.WaitGroup) {  
							x = x + 1
							wg.Done()
						}
						func main() {  
							var w sync.WaitGroup
							for i := 0; i < 1000; i++ {
								w.Add(1)        
								go increment(&w)
							}
							w.Wait()
							fmt.Println("final value of x", x)
						}
		
		使用 Mutex：
			例如：
				var x  = 0  
				func increment(wg *sync.WaitGroup, m *sync.Mutex) {  
					m.Lock()
					x = x + 1
					m.Unlock()
					wg.Done()   
				}
				func main() {  
					var w sync.WaitGroup
					var m sync.Mutex
					for i := 0; i < 1000; i++ {
						w.Add(1)        
						go increment(&w, &m)
					}
					w.Wait()
					fmt.Println("final value of x", x)
				}
			传递 Mutex 的地址很重要。
			如果传递的是 Mutex 的值，而非地址，那么每个协程都会得到 Mutex 的一份拷贝，竞态条件还是会发生。
		
		使用信道处理竞态条件：
			例如：		
				var x  = 0  
				func increment(wg *sync.WaitGroup, ch chan bool) {  
					ch <- true
					x = x + 1
					<- ch
					wg.Done()
				}
				func main() {  
					var w sync.WaitGroup
					ch := make(chan bool, 1)
					for i := 0; i < 1000; i++ {
						w.Add(1)        
						go increment(&w, ch)
					}
					w.Wait()
					fmt.Println("final value of x", x)
				}
			该缓冲信道用于保证只有一个协程访问增加 x 的临界区。
			具体的实现方法是在 x 增加之前，传入 true 给缓冲信道。
			由于缓冲信道的容量为 1，所以任何其他协程试图写入该信道时，都会发生阻塞，直到 x 增加后，信道的值才会被读取（第 10 行）。
			实际上这就保证了只允许一个协程访问临界区。
		
		Mutex vs 信道：
			通过使用 Mutex 和信道，我们已经解决了竞态条件的问题。
			那么我们该选择使用哪一个？答案取决于你想要解决的问题。
				信道是 Go 语言很酷的特性，大多数 Go 新手处理每个并发问题时，使用的都是信道。这是不对的。
				Go 给了你选择 Mutex 和信道的余地，选择其中之一都可以是正确的。
			总体说来，当 Go 协程需要与其他协程通信时，可以使用信道。
				而当只允许一个协程访问临界区时，可以使用 Mutex。
			就上面解决的问题而言，推荐使用 Mutex，因为该问题并不需要协程间的通信。所以 Mutex 是很自然的选择。
					
					
三、提高：
	
	结构体取代类：
		Go 支持面向对象吗：
			虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。
			Go 中的“接口”概念提供了一种不同的方法，我们认为它易于使用，也更为普遍。
			Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。
			此外，Go 提供的特性，比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。
			这在结构体（类）中没有受到限制。
					
		使用结构体，而非类：
			Go 不支持类，而是提供了结构体。
			结构体中可以添加方法。这样可以将数据和操作数据的方法绑定在一起，实现与类相似的效果。
					
		使用 New() 函数，而非构造器：
			像 Java 这样的 OOP 语言中，是使用构造器来解决这种问题的。
				一个合法的对象必须使用参数化的构造器来创建。
			Go 并不支持构造器。
				如果某类型的零值不可用，需要程序员来隐藏该类型，避免从其他包直接访问。
				程序员应该提供一种名为 NewT(parameters) 的函数，按照要求来初始化 T 类型的变量。
				按照 Go 的惯例，应该把创建 T 类型变量的函数命名为 NewT(parameters)。这就类似于构造器了。
				如果一个包只含有一种类型，按照 Go 的惯例，应该把函数命名为 New(parameters)， 而不是 NewT(parameters)。
			虽然 Go 不支持类，但结构体能够很好地取代类，而以 New(parameters) 签名的方法可以替代构造器。
					
	组合取代继承：
		组合：
			组合(Composition)一般定义为“合并在一起”。
					
		通过嵌套结构体进行组合：
			Go 中，通过在结构体内嵌套结构体，可以实现组合。
					
		结构体切片的嵌套：
			结构体不能嵌套一个匿名切片。
					
	多态：
		使用接口实现多态：	
			在 Go 中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部方法，那它就实现了该接口。
			所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。
			在 Go 中，我们使用接口的这种特性来实现多态。
				根据接口的具体类型，程序会调用不同的方法，在调用函数中就实现了多态。
				
	Defer：
		defer 语句：
			含有 defer 语句的函数，会在该函数将要返回之前，调用另一个函数(延迟函数)。
			
		延迟函数(Deferred Function)；
			含有 defer 语句的函数，会在该函数将要返回之前，调用另一个函数；
					
		延迟方法(Deferred Method)；
			含有 defer 语句的函数，会在该函数将要返回之前，调用另一个方法；
					
		实参取值(Arguments Evaluation)：
			在 Go 语言中，并非在调用延迟函数的时候才确定实参，而是当执行 defer 语句的时候，就会对延迟函数的实参进行求值。
					
		defer 栈：
			当一个函数内多次调用 defer 时，Go 会把 defer 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。
					
		defer 的实际应用：
			wg.Done() 只在 area 函数返回的时候才会调用。
			wg.Done() 应该在 area 将要返回之前调用，并且与代码流的路径（Path）无关，因此我们可以只调用一次 defer，来有效地替换掉 wg.Done() 的多次调用。
			
	错误处理：
		错误：
			表示程序中出现了异常情况；
				比如当我们试图打开一个文件时，文件系统里却并没有这个文件。这就是异常情况，它用一个错误来表示。
			用内建的 error 类型来表示：
				错误值可以存储在变量里、作为函数的返回值等等。
			示例：
				func Open(name string) (file *File, err error);
				如果成功打开文件，Open 函数会返回一个文件句柄（File Handler）和一个值为 nil 的错误。
				而如果打开文件时发生了错误，会返回一个不等于 nil 的错误。
				惯例：在处理错误时，通常都是将返回的错误与 nil 比较。nil 值表示了没有错误发生，而非 nil 值表示出现了错误。
				实例：
					f, err := os.Open("/test.txt")
					if err != nil {
						fmt.Println(err)
						return
					}
					
		错误类型的表示：
			Go 标准库给出了各种提取错误相关信息的方法：
				1. 断言底层结构体类型，使用结构体字段获取更多信息；
					如果你阅读 Open 函数的文档，可以看见它返回的错误类型是 *PathError。
					*PathError 通过声明 Error() string 方法，实现了 error 接口。
					Error() string 将文件操作、路径和实际错误拼接，并返回该字符串。
					使用了类型断言（Type Assertion）来获取 error 接口的底层值（Underlying Value）。
					实例：
					    f, err := os.Open("/test.txt")
						if err, ok := err.(*os.PathError); ok {
							fmt.Println("File at path", err.Path, "failed to open")
							return
						}
				2. 断言底层结构体类型，调用方法获取更多信息：
					对底层类型进行断言，然后通过调用该结构体类型的方法，来获取更多的信息。
					实例：
					    addr, err := net.LookupHost("golangbot123.com")
						if err, ok := err.(*net.DNSError); ok {
							if err.Timeout() {
								fmt.Println("operation timed out")
							} else if err.Temporary() {
								fmt.Println("temporary error")
							} else {
								fmt.Println("generic error: ", err)
							}
							return
						}
				3. 直接比较
					与 error 类型的变量直接比较。
					实例：
					    files, error := filepath.Glob("[")
						if error != nil && error == filepath.ErrBadPattern {
							fmt.Println(error)
							return
						}
					
	自定义错误：
		使用 New 函数创建自定义错误：
			创建自定义错误最简单的方法是使用 errors 包中的 New 函数。
				实例：
					func circleArea(radius float64) (float64, error) {  
						if radius < 0 {
							return 0, errors.New("Area calculation failed, radius is less than zero")
						}
						return math.Pi * radius * radius, nil
					}
					
		使用 Errorf 给错误添加更多信息：
			Errorf 函数会根据格式说明符，规定错误的格式，并返回一个符合该错误的字符串。
				实例：
					func circleArea(radius float64) (float64, error) {  
						if radius < 0 {
							return 0, fmt.Errorf("Area calculation failed, radius %0.2f is less than zero", radius)
						}
						return math.Pi * radius * radius, nil
					}
					
		使用结构体类型和字段提供错误的更多信息：
			错误还可以用实现了 error 接口的结构体来表示。这种方式可以更加灵活地处理错误。
				第一步就是创建一个表示错误的结构体类型。错误类型的命名约定是名称以 Error 结尾。
				下一步是实现 error 接口。
					
		使用结构体类型的方法来提供错误的更多信息：
			第一步就是创建一个表示错误的结构体。	
			下一步是实现 error 接口，并给该错误类型添加两个方法，使它提供了更多的错误信息。
					
	panic 和 recover：
		panic：
			当程序发生异常，无法继续运行时，可以使用 panic 来终止程序。
			当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。
			这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。
			panic 和 recover：
				可以认为 panic 和 recover 与其他语言中的 try-catch-finally 语句类似，只不过一般我们很少使用 panic 和 recover。
				而当我们使用了 panic 和 recover 时，也会比 try-catch-finally 更加优雅，代码更加整洁。
					
		什么时候使用 panic：
			注意：
				应该尽可能地使用错误，而不是使用 panic 和 recover。
				只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。
			两个合理的用例：
				发生了一个不能恢复的错误，此时程序不能继续运行。
					例子：web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，就什么也做不了。
				发生了一个编程上的错误。 
					假如我们有一个接收指针参数的方法，而其他人使用 nil 作为参数调用了它。
					在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 nil 参数调用了一个只能接收合法指针的方法。
					
		panic 示例：
			内建函数 panic 的签名：
				func panic(interface{})
			实例：
				if lastName == nil {
					panic("runtime error: last name cannot be nil")
				}
					
		发生 panic 时的 defer：
			当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。
			这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪，最后程序终止。
			所以如果有延迟函数，会先调用它，然后程序控制返回到函数调用方。
			
		recover：
			recover 是一个内建函数，用于重新获得 panic 协程的控制。
			recover 函数的签名：
				func recover() interface{}
			只有在延迟函数的内部，调用 recover 才有用。
				在延迟函数内调用 recover，可以取到 panic 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。
				如果在延迟函数的外部调用 recover，就不能停止 panic 续发事件。
			在执行完 recover() 之后，panic 会停止，程序控制返回到调用方（在这里就是 main 函数），从这里开始会继续正常地运行。
					
		panic，recover 和 Go 协程：
			只有在相同的 Go 协程中调用 recover 才管用。recover 不能恢复一个不同协程的 panic。
					
		运行时 panic：
			运行时错误（如数组越界）也会导致 panic。这等价于调用了内置函数 panic，其参数由接口类型 runtime.Error 给出。
			runtime.Error 接口满足内建接口类型 error。
					
		恢复后获得堆栈跟踪：
			当我们恢复 panic 时，我们就释放了它的堆栈跟踪。实际上，在上述程序里，恢复 panic 之后，我们就失去了堆栈跟踪。
			有办法可以打印出堆栈跟踪，就是使用 Debug 包中的 PrintStack 函数。
			实例：
				func r() {  
					if r := recover(); r != nil {
						fmt.Println("Recovered", r)
						debug.PrintStack()
					}
				}
					
	函数是一等公民（头等函数）：
		头等函数(First Class Function)：
			支持头等函数的编程语言，可以把函数赋值给变量，也可以把函数作为其它函数的参数或者返回值。Go 语言支持头等函数的机制。
					
		匿名函数(Anonymous Function)：
			没有名称的函数。
				实例：
				    a := func() {
						fmt.Println("hello world first class function")
					}
				调用该函数的唯一方法就是使用变量 a，a() 调用这个函数；
				打印 a 的类型，会输出 func()。
				原理：
					func() {
						fmt.Println("hello world first class function")
					}()
			就像其它函数一样，还可以向匿名函数传递参数。
				实例：
					func(n string) {
						fmt.Println("Welcome", n)
					}("Gophers")
					
		用户自定义的函数类型：
			正如我们定义自己的结构体类型一样，我们可以定义自己的函数类型：
				type add func(a int, b int) int
			实例：
				func main() {  
					var a add = func(a int, b int) int {
						return a + b
					}
					s := a(5, 6)
					fmt.Println("Sum", s)
				}
					
		高阶函数：
			高阶函数(Hiher-order Function)：
				满足下列条件之一的函数：
					接收一个或多个函数作为参数；
					返回值是一个函数。
					
				把函数作为参数，传递给其它函数：
					实例：	
						func simple(a func(a, b int) int) {  
							fmt.Println(a(60, 7))
						}
						func main() {  
							f := func(a, b int) int {
								return a + b
							}
							simple(f)
						}
						
				在其它函数中返回函数：
					实例：
						func simple() func(a, b int) int {  
							f := func(a, b int) int {
								return a + b
							}
							return f
						}
						func main() {  
							s := simple()
							fmt.Println(s(60, 7))
						}
					
		闭包：
			闭包(Closure)：
				是匿名函数的一个特例。
				当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。
					每一个闭包都会绑定一个它自己的外围变量(Surrounding Variable)。
				js 中的闭包：
					能够读取其他函数内部变量的函数。
					可以把闭包简单理解成"定义在一个函数内部的函数"。
					作用：
						可以读取函数内部的变量；让这些变量的值始终保持在内存中。
			实例：
				func appendStr() func(string) string {  
					t := "Hello"
					c := func(b string) string {
						t = t + " " + b
						return t
					}
					return c
				}
				func main() {  
					a := appendStr()
					b := appendStr()
					fmt.Println(a("World"))
					fmt.Println(b("Everyone"))
					fmt.Println(a("Gopher"))
					fmt.Println(b("!"))
				}
				函数 appendStr 返回了一个闭包。这个闭包绑定了变量 t。
				变量 a 和 b 都是闭包，它们绑定了各自的 t 值。
					
		头等函数的实际用途：
			实例：
				func iMap(s []int, f func(int) int) []int {  
					var r []int
					for _, v := range s {
						r = append(r, f(v))
					}
					return r
				}
				func main() {  
					a := []int{5, 6, 7, 8, 9}
					r := iMap(a, func(n int) int {
						return n * 5
					})
					fmt.Println(r)
				}
					
	反射：
		反射：
			程序能够在运行时检查变量和值，求出它们的类型。
			检查变量，确定变量的类型：
					
		reflect 包：
			reflect 实现了运行时反射。
				reflect 包会帮助识别 interface{} 变量的底层具体类型和具体值。
			reflect.Type 和 reflect.Value：
				reflect.Type 表示 interface{} 的具体类型，而 reflect.Value 表示它的具体值。
				reflect.TypeOf() 和 reflect.ValueOf() 两个函数可以分别返回 reflect.Type 和 reflect.Value。
			relfect.Kind：
				在反射包中，Kind 和 Type 的类型可能看起来很相似；
				Type 表示 interface{} 的实际类型（在这里是 main.Order)，而 Kind 表示该类型的特定类别（在这里是 struct）。
			NumField() 和 Field() 方法：
				NumField() 方法返回结构体中字段的数量，
				Field(i int) 方法返回字段 i 的 reflect.Value。
			Int() 和 String() 方法：
				Int 和 String 可以帮助我们分别取出 reflect.Value 作为 int64 和 string。
					
		我们应该使用反射吗：
			清晰优于聪明。而反射并不是一目了然的。
			反射是 Go 语言中非常强大和高级的概念，我们应该小心谨慎地使用它。
			使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它，只在必须用到它时，才使用反射。
					
	读取文件：
		将整个文件读取到内存：
			将整个文件读取到内存是最基本的文件操作之一。需要使用 ioutil 包中的 ReadFile 函数。
				实例：
					data, err := ioutil.ReadFile("test.txt")
			Go 是编译型语言,go install 会根据源代码创建一个二进制文件。
				二进制文件独立于源代码，可以在任何位置上运行。
			由于在运行二进制文件的位置上没有找到 test.txt，因此程序会报错，提示无法找到指定的文件。	
				有三种方法可以解决这个问题：
					使用绝对文件路径；
					使用命令行标记来传递文件路径；
					将文件绑定在二进制文件中。
					
			1. 使用绝对文件路径：
				最简单的方法：传入绝对文件路径。
				缺点：文件必须放在程序指定的路径中，否则就会出错。
				实例：
					data, err := ioutil.ReadFile("/home/naveen/go/src/filehandling/test.txt")
					
			2. 使用命令行标记来传递文件路径：
				使用 flag 包，我们可以从输入的命令行获取到文件路径，接着读取文件内容。
				flag 包有一个名为 String 的函数。
					该函数接收三个参数：第一个参数是标记名，第二个是默认值，第三个是标记的简短描述。
				实例：
					fptr := flag.String("fpath", "test.txt", "file path to read from")
					flag.Parse()
					data, err := ioutil.ReadFile(*fptr)
					
			3. 将文件绑定在二进制文件中：
				虽然从命令行获取文件路径的方法很好，但还有一种更好的解决方法。
				将文本文件捆绑在二进制文件，有很多包可以帮助我们实现。我们会使用 packr，因为它很简单。
					第一步是安装 packr 包。
						go get -u github.com/gobuffalo/packr/...
						packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。
						packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。
						在开发过程中，当仅仅静态文件变化时，可以不必重新编译。
					实例：
					    box := packr.NewBox("../filehandling")
						data := box.String("test.txt")
						fmt.Println("Contents of file:", data)
					
		分块读取文件：
			分块读取文件，可以使用 bufio 包来完成：
				实例：
					r := bufio.NewReader(f)
					b := make([]byte, 3)
					_, err := r.Read(b)
					新建一个缓冲读取器(buffered reader)，创建了长度和容量为 3 的字节切片，把文件的字节读取到切片中。
					Read 方法会读取 len(b) 个字节（达到 3 字节），并返回所读取的字节数。
					当到达文件最后时，它会返回一个 EOF 错误。
					
		逐行读取文件：
			可以使用 bufio 来实现：
				步骤：
					打开文件；
					在文件上新建一个 scanner；
					扫描文件并且逐行读取。
				实例：
					s := bufio.NewScanner(f)
					for s.Scan() {
						fmt.Println(s.Text())
					}
					当 Scan 返回 false 时，除非已经到达文件末尾（此时 Err() 返回 nil），否则 Err() 就会返回扫描过程中出现的错误。
					
	写入文件：
		将字符串写入文件：
			步骤：
				创建文件
				将字符串写入文件
			实例：
				f, err := os.Create("test.txt")
				l, err := f.WriteString("Hello World")
				create 方法创建一个文件，如果文件名已经存在，那么 create 函数将截断这个文件，该方法返回一个文件描述符。
				WriteString 方法返回相应写入的字节数，如果有错误则返回错误。
					
		将字节写入文件：
			将字节写入文件和写入字符串非常的类似，使用 Write 方法将字节写入到文件。
			实例：
				f, err := os.Create("test.txt")	
				d2 := []byte{104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100}
				n2, err := f.Write(d2)
					
		将字符串一行一行的写入文件：
			实例：
				f, err := os.Create("test.txt")	
				d := []string{"Welcome to the world of Go1.", "Go is a compiled language.","It is easy to learn Go."}
				for _, v := range d {
					fmt.Fprintln(f, v)
				}
					
		追加到文件：
			文件以追加的方式打开，添加新的行到文件里。这些标志将通过 Open 方法实现。
			实例：
			    f, err := os.OpenFile("lines", os.O_APPEND|os.O_WRONLY, 0644)
			    newLine := "File handling is easy."
				_, err = fmt.Fprintln(f, newLine)
					
		并发写文件：
			当多个 goroutines 同时（并发）写文件时，我们会遇到竞争条件(race condition)。
			因此，当发生同步写的时候需要一个 channel 作为一致写入的条件。
			举例：
				创建 100 个 goroutinues，每个 goroutinue 将并发产生一个随机数，届时将有 100 个随机数产生。这些随机数将被写入到文件里面。
				我们将用下面的方法解决这个问题：
					创建一个 channel 用来读和写这个随机数。
					创建 100 个生产者 goroutine。每个 goroutine 将产生随机数并将随机数写入到 channel 里。
					创建一个消费者 goroutine 用来从 channel 读取随机数并将它写入文件。这样的话我们就只有一个 goroutinue 向文件中写数据，从而避免竞争条件。
					一旦完成则关闭文件。
			实例：
				func produce(data chan int, wg *sync.WaitGroup) {
					n := rand.Intn(999)
					data <- n
					wg.Done()
				}
				func consume(data chan int, done chan bool) {
					f, err := os.Create("concurrent")
					if err != nil {
						fmt.Println(err)
						return
					}
					for d := range data {
						_, err = fmt.Fprintln(f, d)
						if err != nil {
							fmt.Println(err)
							f.Close()
							done <- false
							return
						}
					}
					err = f.Close()
					if err != nil {
						fmt.Println(err)
						done <- false
						return
					}
					done <- true
				}
				func main() {
					data := make(chan int)
					done := make(chan bool)
					wg := sync.WaitGroup{}
					for i := 0; i < 100; i++ {
						wg.Add(1)
						go produce(data, &wg)
					}
					go consume(data, done)
					go func() {
						wg.Wait()
						close(data)
					}()
					d := <-done
					if d == true {
						fmt.Println("File written successfully")
					} else {
						fmt.Println("File writing failed")
					}
				}
					
					
					
					
					
					
完结