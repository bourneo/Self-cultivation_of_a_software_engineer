# MySQL

---

## 索引

---

### 索引是什么

**索引 / index：**

帮助 MySQL 高效获取数据的数据结构。

### 索引的作用

数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，要从 500 万行数据里面检索一条数据，只能依次遍历这张表的全部数据，直到找到这条数据。

有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。

### 为什么需要索引

数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。

有了索引，就不需要加载所有数据，因为 B + 树的高度一般在 2-4 层，最多只需要读取 2-4 次磁盘，查询速度大大提升。

### 索引的优点

1、加快数据查找的速度。

2、为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度。

3、加快表与表之间连接的速度。

### 索引的缺点

1、建立索引需要占用物理空间。

2、会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长。

### 什么情况下需要建索引

1、经常用于查询的字段。

2、经常用于连接的字段建立索引，可以加快连接的速度。

3、经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度。

### 什么情况下不建索引

1、where 条件中用不到的字段不适合建立索引。

2、表记录较少。

3、需要经常增删改。

4、参与列计算的列不适合建索引。

5、区分度不高的字段不适合建立索引，如性别等。

### 索引的分类

**1. 主键索引 / 主索引：**

即主索引，根据主键 pk_clolum（length）建立索引，不允许重复，不允许空值。

**2. 普通索引：**

用表中的普通列构建的索引，没有任何限制。

**3. 唯一索引：**

用来建立索引的列的值必须是唯一的，允许空值。

**4. 全文索引：**

针对比较大的数据，比如我们存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如
char、varchar、text。

**5. 联合索引：**

用多个列组合构建的索引，这多个列中的值不允许有空值。

### 前缀索引

**前缀索引：**

对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

创建前缀索引的关键在于选择足够长的前缀以保证较高的索引选择性。索引选择性越高查询效率就越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的数据行。

但是 MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引。

### 联合索引 / 组合索引 / 复合索引

**联合索引**：

两个或更多个列上的索引。

> 在使用组合索引的时候可能因为列名长度过长而导致索引的 key 太大，导致效率降低，在允许的情况下，可以只取 col1 和 col2 的前几个字符作为索引。

联合索引好处：

> 减少开销：建一个联合索引（col1,col2,col3），实际相当于建了（col1），（col1,col2），（col1,col2,col3）三个索引。减少磁盘空间的开销。
>
> 覆盖索引：对联合索引（col1,col2,col3），如果有如下的 sql: select col1,col2,col3 from test where col1=1 and col2=2。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。覆盖索引是主要的提升性能的优化手段之一。
>
> 效率高：索引列越多，通过索引筛选出的数据越少。

**最左前缀原则：**

> MySQL 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
>
> MySQL 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立（ a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a,b,d 的顺序可以任意调整。
>
> = 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立（a,b,c）索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

所以在建立联合索引的时候要把最常用的列放在最左边。

### 覆盖索引

**覆盖索引 / covering index：**

在覆盖索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用从索引中就能够取得，不必从数据区中读取，这时使用的索引就叫覆盖索引，避免了**回表**。

> 对联合索引（col1,col2,col3），如果有如下的 sql: select col1,col2,col3 from test where col1=1 and col2=2。
>
> 那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。覆盖索引是主要的提升性能的优化手段之一。

**回表：**

非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引里面没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。

### 索引下推

MySQL 服务层负责 SQL 语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。

索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。

我们来具体看一下，在没有使用 ICP 的情况下，MySQL 的查询：

> 存储引擎读取索引记录；
>
> 根据索引中的主键值，定位并读取完整的行记录；
>
> 存储引擎把记录交给 Server 层去检测该记录是否满足 WHERE 条件。

使用 ICP 的情况下，查询过程：

> 存储引擎读取索引记录（不是完整的行记录）；
>
> 判断 WHERE 条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
>
> 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
>
> 存储引擎把记录交给 Server 层，Server 层检测该记录是否满足 WHERE 条件的其余部分。

MySQL 5.6 引入了索引下推优化，默认开启，使用 SET optimizer_switch = ‘index_condition_pushdown=off’; 可以将其关闭。

> 有了索引下推优化，**可以减少回表次数**。
>
> 在 InnoDB 中只对二级索引有效。

官方文档中给的例子和解释如下：

> 在 people_table 中有一个二级索引（zipcode，lastname，address），查询是 SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘% etrunia%’ AND address LIKE ‘% Main Street%’;
>
> 如果没有使用索引下推技术，则 MySQL 会通过 zipcode=’95054’**从存储引擎中查询对应的数据，返回到 MySQL 服务端**，然后 MySQL 服务端基于 lastname LIKE ‘% etrunia%’ and address LIKE ‘% Main Street%’来判断数据是否符合条件。
>
> 如果使用了索引下推技术，则 MySQL 首先会返回符合 zipcode=’95054’的索引，然后根据 lastname LIKE ‘% etrunia%’ and address LIKE ‘% Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接 reject 掉。

总结：索引下推产生的条件有两个，index_condition_pushdown 不关，查询条件中的字段必须都在二级索引中。

### 聚簇索引、非聚簇索引的区别

**聚簇索引**：

聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多

InnoDB 存储引擎采用的是聚簇索引，聚簇索引的数据和主键索引存储在一起。

聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。

**非聚簇索引**：

非聚簇索引的数据表和索引表是分开存储的。

MyISAM 存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的 key 都存储指向键值对应的数据的物理地址。

### 主键索引、非主键索引的区别

**非主键索引**的叶子节点存放的是主键的值，而**主键索引**的叶子节点存放的是主键及其字段的数据。

其中非主键索引也被称为**二级索引**，而主键索引也被称为**聚簇索引**。


---

## 存储引擎

---

### 常见的存储引擎

**InnoDB：**

InnoDB 是 MySQL 默认的事务型存储引擎，使用最广泛，基于聚簇索引建立的。InnoDB 内部做了很多优化，如能够自动在内存中创建自适应 hash 索引，以加速读操作。

优点：支持事务和崩溃修复能力；引入了行级锁和外键约束。

缺点：占用的数据空间相对较大。

适用场景：需要事务支持，并且有较高的并发读写频率。

**MyISAM：**

数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用 MyISAM 引擎。MyISAM 会将表存储在两个文件中，数据文件.MYD 和索引文件.MYI。

优点：访问速度快。

缺点：MyISAM 不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。

适用场景：对事务完整性没有要求；表的数据都会只读的。

### MyISAM 和 InnoDB 的区别

是否支持行级锁 : MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。

是否支持事务和崩溃后的安全恢复：MyISAM 不提供事务支持。而 InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。

是否支持外键： MyISAM 不支持，而 InnoDB 支持。

是否支持 MVCC：MyISAM 不支持，InnoDB 支持。应对高并发事务，MVCC 比单纯的加锁更高效。

是否支持聚集索引：MyISAM 不支持聚集索引，InnoDB 支持聚集索引。




---

## 索引数据结构

---

### InnoDB 中的 B+Tree 索引

**B+Tree 索引：**

B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ 树中，节点中的 key 从左到右递增排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

进行查找操作时，首先在根节点进行二分查找，找到 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的数据项。

MySQL 数据库使用最多的索引类型是 BTREE 索引，底层基于 B + 树数据结构来实现。

InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，叶节点 data 域保存了完整的数据记录。

这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引，所以必须有主键。

如果没有显示定义，自动为生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。

B+Tree 索引的特点：

> 它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题是什么？（每个节点存储更多关键字；路数更多）
>
> 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+Tree 拿到所有的数据）
>
> B+Tree 的磁盘读写能力相对于 B Tree 来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
>
> 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
>
> 效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的）

### B 树、B+ 树的区别

视频讲解：[1. mysql 面试题 - 深入理解 B + 树原理](https://www.bilibili.com/video/BV15V411p7pi)

区别：

1、B 树的叶子节点是不相连的。B+ 树的叶子节点是通过链表串联的。

2、B 树因为节点存的是主键的地址，查找的过程过，在非叶子节点查到匹配的数据，不会继续查子节点。B+ 树的非叶子节点不存数据，只存值。

3、B 树的叶子节点存的全是地址。B+ 树的叶子节点存有字段和值，叶子节点的 key 还存了数据的物理地址。

**B Tree / B 树 / 多路平衡查找树：**

B 树在枝节点和叶子节点存储键值、数据地址、节点引用。

它有一个特点：分叉数（路数）永远比关键字数多 1。

假如树的度为 2d（d>1），高度为 h，那么 B Tree 要满足以下条件：

1. 每个叶子结点的高度一样，等于 h；
2. 每个非叶子结点由 n-1 个 key 和 n 个指针 point 组成，其中 d<=n<=2d,key 和 point 相互间隔，结点两端一定是 key；
3. 叶子结点指针都为 null；
4. 非叶子结点的 key 都是 [key,data] 二元组，其中 key 表示作为索引的键，data 为键值所在行的数据；

**B+Tree / B+ 树：**

B+Tree 是 BTree 的一个变种，设 d 为树的度数，h 为树的高度，B+Tree 和 BTree 的不同主要在于：

1. B+Tree 中的非叶子结点不存储数据，只存储键值；
2. B+Tree 的叶子结点没有指针，所有键值都会出现在叶子结点上，且 key 存储的键值对应 data 数据的物理地址；
3. B+Tree 的每个非叶子节点由 n 个键值 key 和 n 个指针 point 组成，键值数量和指针数量相同；
4. B+Tree 搜索到键值不会直接返回，会到最后一层的叶子节点；
5. B+Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数 据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。
6. 它是根据左闭右开的区间[和)来检索数据。

### InnoDB 为什么用 B+ 树不用跳表

视频讲解：[为什么 MySQL 要用 B + 树而不是用跳表呢](https://www.bilibili.com/video/BV1eY411p7bo)

1、B+ 树检索效率更高，数据分布更均匀。跳表的索引层级太深

2、B+ 树查多条记录的磁盘 IO 更少。B+ 树的叶子节点可以存储多条数据，所有的叶子节点构成了单向链表。

### Hash 索引

**Hash 索引：**

哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的 key
值，将指向数据行的指针作为哈希表的 value 值。这样查找一个数据的时间复杂度就是 O (1)，一般多用于精确查找。

Hash 结构由 Hash 表来实现的，是根据键值 <key，value> 存储数据的结构；Hash 索引可以方便的提供等值查询，对于范围查询就需要全表扫描；Hash 结构在 MySQL 中主要应用在
Memory 原生的 Hash 索引 、InnoDB 自适应哈希索引。

每插入一个元素会把我们的索引字段做一次 hash 计算，把运算的到的结果值和这一行的所在磁盘地址做一个映射。

对索引元素的值做一次 hash 运算就可以在 hash 映射表里快速找到这一行的磁盘文件地址，经过一次 hash 就可以快速定位到索引所在行的磁盘文件地址，hash
这么快，表有一亿个数据按这种算法，那也就可能经历一次 hash 运算就可以快速找到某页任意一行数据元素的所在的磁盘文件地址，那比 B+Tree 快的多啊。就是快的多，为啥 99.99 的都是
B+Tree 不是 hash 呢？

hash 的等值查询比 B+Tree 快，上亿依然很快，为啥很快却不使用？最主要的原因是，如果使用范围查找，hash 就没有用武之地了。

范围查找很常用，况且 B+Tree 还支持排序，所以基本就不怎么用 hash 这种数据结构做索引了。

### Hash 索引、B+ 树索引的区别

1、哈希索引不支持排序，因为哈希表是无序的。

2、哈希索引不支持范围查找。

3、哈希索引不支持模糊查询及多列索引的最左前缀匹配。

4、因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而 B + 树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。

### 有那些解决 Hash 冲突的方法

**1. 链地址法 / 拉链法：**

为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。

实际的哈希表实现中，使用最多的是链地址法。

**2. 再哈希法：**

同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值，直到冲突不再产生。

这种方法不易产生聚集，但增加了计算时间。

**3. 建立公共溢出区：**

将哈希表分为基本表和溢出表两部分，为所有发生 hash 冲突的关键字记录一个公共的溢出区来存放。

**4. 开放定址法：**

使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。

- 开放定址法实现方式：

> 线性探查：发生 hash 冲突时，顺序查找下一个位置，直到找到一个空位置（固定步长 1 探测）。
>
> 二次探查：在发生 hash 冲突时，在表的左右位置进行按一定步长跳跃式探测（固定步长 n 探测）。
>
> 伪随机探测：在发生 hash 冲突时，根据公式生成一个随机数，作为此次探测空位置的步长（随机步长 n 探测）。



---

## 索引优化

---

### 为什么官方建议使用自增长主键

索引树只能定位到某一页，每一页内的插入还是需要通过比较、移动插入的，**所以有序主键可以提升插入效率**。

结合 B+Tree 的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。

并且能减少数据的移动，每次插入都是插入到最后。**总之就是减少分裂和移动的频率**。

### 索引失效

1. 对于组合索引，不是使用组合索引最左边的字段，则不会使用索引。
2. 以 % 开头的 like 查询如 %abc，无法使用索引；非 % 开头的 like 查询如 abc%，相当于范围查询，会使用索引。
3. 查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效。
4. 判断索引列是否不等于某个值时。
5. 对索引列进行运算。
6. 查询条件使用 or 连接，也会导致索引失效。


1. 索引遇到范围查询就会失效，比如：>、<、between、like。
2. where 语句中包含 or 时，可能会导致索引失效
3. where 语句中索引列使用了负向查询，可能会导致索引失效
4. 索引字段可以为 null，使用 is null 或 is not null 时，可能会导致索引失效
5. 在索引列上使用内置函数，一定会导致索引失效 4.1 隐式类型转换导致的索引失效 4.2 隐式字符编码转换导致的索引失效
6. 对索引列进行运算，一定会导致索引失效
7. like 通配符可能会导致索引失效
8. 联合索引中，where 中索引列违背最左前缀原则，一定会导致索引失效
9. **MySQL 优化器**的最终选择，不走索引

### 如何做索引优化

1. 选择唯一性索引。唯一索引可以更快速的通过该索引来确定某条记录。
2. 为经常需要排序、分组和联合操作的字段建立索引。排序操作会浪费很多时间。
3. 为常作为查询条件的字段建立索引。
4. 限制索引的数目。越多的索引，会使更新表变得很浪费时间。
5. 尽量使用数据量少的索引。如果索引的值很长，那么查询的速度会受到影响。
6. 尽量使用前缀来索引。如果索引字段的值很长，最好使用值的前缀来索引。
7. 删除不再使用或者很少使用的索引，从而减少索引对更新操作的影响。
8. 建立联合索引，必须把区分度高的字段放在前面。

### 索引的设计原则

索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。

尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘 I/O 较少，查询速度更快。

索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。

利用联合索引和最左前缀原则。







---
