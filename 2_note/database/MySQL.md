# MySQL

---

## 基础部分

---

### 隔离级别

**1. 读未提交 / Read Uncommitted：**

可以读取到其他会话中未提交事务修改的数据。可能出现脏脏读。

**脏读：在事务中读到了其他会话未提交的数据。**

**2. 读已提交 / Read Committed：**

只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别。可能出现不可重复脏读。

**不可重复读：在事务中读到了其他会话已经提交的数据。**

**3. 可重复读 / Repeated Read：**

在同一个事务内的**查询**都是事务开始时刻一致的，InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，可能出现幻脏读。

幻读：事务 A 按条件读取数据时，事务 B 插入了相同条件的新数据，事务 A 再次按原先条件进行读取操作**修改**时，读取到了事务 B 插入的新数据。

如果事务中都是用快照读，那么不会产生幻读的问题，快照读和当前读一起使用的时候就会产生幻读。

**幻读：在事务中用当前读，读到了其他会话提交的新数据。**

**4. 串行化 / Serializable：**

完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。可以消除幻读，但是因为性能等原因，实际中不会采用这种级别。

### 事务特性

ACID：

1. 原子性（atomicity）
2. 一致性（consistency）
3. 隔离性（isolation）
4. 持久性（durability）

### mysql 如何实现原子性

### 覆盖索引

### 索引失效

### 聚簇索引与非聚簇索引的区别

### B+ 树和 hash

### 有那些解决 hash 冲突的方法

### 主键索引和非主键索引差别

    主键索引：唯一约束，数据排序
    非主键索：可以选择是否是唯一约束

### 索引的数据结构和 B 树的差别

B+ 树

- 平衡树

### 数据库锁

行锁

表锁

死锁

### InnoDB 中的锁

### 三个范式

每行数据都必须有主键

每列数据都能找到对应的主键

---

## 提高部分

---

### SQL 优化

避免子查询

分页的参数不应过大

where 字段加索引

### MVCC 快照读，当前读

### 覆盖索引

---










---

参考链接：

- [MySQL 官方文档——幻影行](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)
- [mysql 中幻读出现的原因及解决方案](https://blog.csdn.net/nandao158/article/details/116007366)
- [Innodb 中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
- []()
- []()

---












