# MySQL

---

## 基础部分

---

### 三大范式

**1NF / 第一范式：**

**要保证字段的原子性。**

数据库表中不能出现重复记录，每个字段是原子性的不能再分。

比如：在学生表中，联系方式这个字段出现了邮件和电话号码一起存，用逗号连接的情况。一个值里不能同时包含两种数据，因为会违反第一范式。

**2NF / 第二范式：**

**非主键字段完全依赖主键，不能产生部分依赖。**

第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖。

比如：在学生表中，增加老师名字这个字段，但是老师的名字信息不依赖于表的主键，违反了第二范式。

**3NF / 第三范式：**

**非主键字段和主键字段之间不能产生传递依赖。**

建立在第二范式基础上的，非主键字段不能传递依赖于主键字段。

比如：在学生表中，增加班级编号、班级名称这两个字段。班级名称依赖于班级编号，班级编号依赖于学生表的主键，产生了传递依赖。

**逆范式：**

**通过增加冗余或重复的数据来提高数据库的读性能**。

---

## 提高部分

---

### SQL 优化

尽量避免子查询。

分页的参数不应过大。

where 字段加索引。

---

## 事务

---

### 事务的特性 / ACID

**Atomicity / 原子性：**

保证每个事务都被视为一个单独的单元，要么完全成功，要么完全失败。一个事务中的所有操作，**要么全部执行成功，要么全部不执行**。

**Consistency / 一致性：**

事务执行结束后，**数据库的完整性约束**没有被破坏，**事务执行的前后都是合法的数据状态**。

数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。

**Isolation / 隔离性：**

事务内部的操作及使用的数据对正在进行的其他事务是隔离的，**并发执行的各个事务之间不能互相干扰**。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

**Durability / 持久性：**

事务一旦提交，**对数据库的改变就应该是永久性的**。接下来的其他操作或故障不应该对其有任何影响。

### 事务的隔离级别

**1. 读未提交 / Read Uncommitted：**

可以读取到其他会话中未提交事务修改的数据。读未提交可能出现脏读。

**脏读：在事务中读到了其他会话未提交的数据。**

**2. 读已提交 / Read Committed（RC）：**

只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别。读已提交可能出现不可重复读。

**不可重复读：在事务中读到了其他会话已经提交的数据。**

**3. 可重复读 / Repeated Read（RR）：**

在同一个事务内的**查询**都是事务开始时刻一致的，InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读。可重复读可能出现幻读。

**幻读：在事务中使用当前读，读到了其他会话提交的新数据。**

**4. 串行化 / Serializable：**

完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。串行化没有幻读，但实际中因为性能等原因不会采用这种级别。

### 幻读 / Phantom read

**幻读**：是幻影行 Phantom Rows 产生的负面结果，快照读和当前读一起使用就能复现。

幻读典型场景复现：

1. 事务 A 按条件读取数据时，事务 B 插入了相同条件的新数据，事务 A 再次按原先条件进行读取操作**修改**时，读取到了事务 B 插入的新数据。

2. 事务 C 查不出事务 D 新增的记录，但是自身插入相同主键的记录会报主键冲突。

出现的原因：如果事务中都是用快照读，就不会产生幻读，**快照读和当前读一起使用的时候可能产生幻读**。

解决办法：为了防止幻读，InnoDB 采用了 **Next-Key Lock** 算法，将记录锁与间隙锁相结合。

### MVCC 的快照读和当前读

**快照读**：读取开启事务时的版本数据。InnoDB 提供的非锁定读，不需要等待访问行上的锁释放，读取行的一个快照。

**当前读**：读取数据库当前版本数据。

例如：select 执行的是快照读（某个版本的数据，Read View）, 而 update 执行的是当前读（最新的数据，即最新的 Read View）。

### MySQL 的 InnoDB 如何实现 MVCC

**MVCC / Multiversion concurrency control / 多版本并发控制：**

MVCC 的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是 InnoDB 的 MVCC。

在 InnoDB 中，会在每行数据后添加两个额外的隐藏的值来实现 MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。
在实际操作中，存储的并不是时间，而是事务的版本号。

**每开启一个新事务，事务的版本号就会递增。**

**通过 MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用。**
大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

根据 MVCC 的定义，并发提交数据时会出现冲突。

在可重复读级别中，通过 MVCC 机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据。

事务的隔离级别实际上都是定义了当前读的级别，MySQL 为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得 select 不用加锁。

而 update、insert 这些 “当前读”，就需要另外的模块来解决了。 为了解决当前读中的幻读问题，MySQL 事务使用了 Next-Key Lock。

### MySQL 如何实现原子性

InnoDB 实现回滚，靠的是 undo log，回滚日志是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，。。

回滚日志 / undo log：

当事务对数据库进行修改时，InnoDB 会生成对应的 undo log；如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。

例如：

1. 当你 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据
2. 当你 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作
3. 当年 insert 一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操

### MySQL 如何实现持久性

InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。

为此，InnoDB 提供了缓存（Buffer Pool），Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：

当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool； 当向数据库写入数据时，会首先写入 Buffer
Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool 的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时 Buffer Pool
中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作；当事务提交时，会调用 fsync 接口对 redo
log 进行刷盘。如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。redo log 采用的是 WAL（Write-ahead
logging，预写式日志），所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。

既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘（即刷脏）要快呢？主要有以下两方面的原因：

（1）刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。

（2）刷脏是以数据页（Page）为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入；而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。

### MySQL 如何实现隔离性

隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。

锁机制的基本原理可以概括为：

事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

InnoDB 实现的 RR，通过锁机制（包含 next-key lock）、MVCC（包括数据的隐藏列、基于 undo log
的版本链、ReadView）等，实现了一定程度的隔离性，可以满足大多数场景的需要。

RR 虽然避免了幻读问题，但是毕竟不是 Serializable，不能保证完全的隔离。

如果在事务中第一次读取采用非加锁读，第二次读取采用加锁读，则如果在两次读取之间数据发生了变化，两次读取到的结果不一样，因为加锁读时不会采用 MVCC。

### MySQL 如何实现一致性

一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。

此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。

实现一致性的措施包括：

保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。

数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。

应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。


---

## 日志

---

### MySQL 的日志

MySQL 的日志有很多种，如：binlog / 二进制日志、error log / 错误日志、查询日志、慢查询日志等。

此外 InnoDB 存储引擎还提供了两种事务日志：**redo log（重做日志）**、**undo log（回滚日志）**。

其中 **redo log 用于保证事务持久性；undo log 则是事务原子性和隔离性实现的基础**。

### redo log 与 binlog 的区别

都可以记录写操作并用于数据的恢复。

**作用不同：**

redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性；

binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。

**层次不同：**

redo log 是 InnoDB 存储引擎实现的；

binlog 是 MySQL 的服务器层（可以参考文章前面对 MySQL 逻辑架构的介绍）实现的，同时支持 InnoDB 和其他存储引擎。

**内容不同：**

redo log 是物理日志，内容基于磁盘的 Page；

binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于 sql 语句、基于数据本身或者二者的混合。

**写入时机不同：**

binlog 在事务提交时写入；

redo log 的写入时机相对多元：

- 前面曾提到：当事务提交时会调用 fsync 对 redo log 进行刷盘；这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit
  参数可以改变该策略，但事务的持久性将无法保证。
- 除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。

---

---

## 锁

---

### MySQL 中的锁

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。

**行锁**：行锁则只锁定需要操作的数据，并发性能好。

**表锁**：表锁在操作数据时会锁定整张表，并发性能较差。

由于加锁本身需要消耗资源 (获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。

MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

死锁：

### InnoDB 中的锁

**1. Record Lock / 记录锁**：

**行锁，单行记录上的锁，作用于索引记录。**

**2. Gap Lock / 间隙锁**：

**锁定一个范围，但不包括记录本身。**
GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

**3. Next-Key Lock / 下键锁**：

是 Record Lock 和 Gap Lock 的结合。**锁定一个范围，并且锁定记录本身。**
对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

### 悲观锁和乐观锁

**悲观锁**：

指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。

悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。**读取数据时给加锁**，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

**乐观锁**：

乐观锁机制采取了更加宽松的加锁机制。**大多是基于数据版本（Version）记录机制实现**。

数据版本：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。

实现过程：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。



---

## 索引

---

### 覆盖索引

### 索引失效

### 聚簇索引、非聚簇索引的区别

### 主键索引、非主键索引的区别

主键索引：唯一约束，数据排序

非主键索：可以选择是否是唯一约束

### B+ 树、B 树的区别

B+ 树

- 平衡树

### B+ 树索引和 hash 索引的区别

### 有那些解决 hash 冲突的方法

---




---

参考链接：

- [MySQL 官方文档——幻影行](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)
- [深入学习 MySQL 事务：ACID 特性的实现原理](https://www.cnblogs.com/kismetv/p/10331633.html)
- [MySQL 中幻读出现的原因及解决方案](https://blog.csdn.net/nandao158/article/details/116007366)
- [Innodb 锁机制：Next-Key Lock 浅谈](https://www.cnblogs.com/zhoujinyi/p/3435982.html)
- [MySQL next-key lock 加锁范围是什么？](https://segmentfault.com/a/1190000040129107)
- [间隙锁和 next-key lock](https://www.jianshu.com/p/d1aba64b5c03)
- [MySQL 教程 (十)---MySQL ACID 实现原理](https://www.lixueduan.com/post/mysql/10-acid/)
- [Innodb 中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
- [MySQL 设计之三范式](https://segmentfault.com/a/1190000022843792)
- []()

---












