# Netty

---

## 基础部分

---

### BIO、NIO 和 AIO 的区别？

BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。 伪异步 IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。

NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。

AIO：一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理，

底层实现区别：

BIO 是面向流的，NIO 是面向缓冲区的；BIO 的各种流是阻塞的。而 NIO 是非阻塞的；BIO 的 Stream 是单向的，而 NIO 的 channel 是双向的。

NIO 的特点：事件驱动模型、单线程处理多任务、非阻塞 I/O，I/O 读写不再阻塞，而是返回 0、基于 block 的传输比基于流的传输更高效、更高级的 IO 函数 zero-copy、IO
多路复用大大提高了 Java 网络应用的可伸缩性和实用性。基于 Reactor 线程模型。

在 Reactor 模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在 Reactor
中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

### NIO 的组成

1、Buffer

一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。与 Channel
进行交互，数据是从 Channel 读入缓冲区，从缓冲区写入 Channel 中的。

2、Channel

NIO 的通道类似于流，但有些区别

    通道可以同时进行读写，而流只能读或者只能写
    通道可以实现异步读写数据
    通道可以从缓存读数据，也可以写数据到缓存

【博客大赛】Netty面试灵魂15问_Java channel 与 Buffer 关系

3、Selector

能够检测多个注册的通道上是否有事件发生 (注意：多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发

### Netty 的零拷贝

Netty 的零拷贝主要包含三个方面：

Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。

    如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。
    相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。

Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小
Buffer 合并成一个大的 Buffer。

Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。

### Netty 线程模型

Netty 线程模型主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。

内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的连接事件，当接收到连接事件的请求时，把对应的 socket 封装到一个
NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。

其本质将线程连接和具体的业务处理区分开来。

### Netty 中有哪种重要组件？

1、Bootstrap、ServerBootstrap：一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中
Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。

2、Future、ChannelFuture：Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过
Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。

3、Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等

4、Selector：基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件，Selector 内部的机制就可以自动不断地查询 (
Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等）

5、ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。

6、EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情

7、ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。

8、ChannelHandlerContext：包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时 ChannelHandlerContext 中也绑定了对应的
pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。

### 什么是拆包和粘包

TCP 是面向连接的，面向流的，提供高可靠性服务。

收发两端（客户端和服务器端）都要有一一成对的 socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle
算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，由于 TCP
无消息保护边界，需要在接收端处理消息边界问题。这就是拆包和粘包问题。

假设客户端同时发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，固可能存在以下四种情况：

    服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2 ，没有粘包和拆包
    服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为 TCP 粘包
    服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这称之为 TCP 拆包
    服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1 ，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包。

### Netty 如何解决拆包和粘包问题

主要思路：在数据包的前面加上一个固定字节数的数据长度，如加上一个 int（固定四个字节）类型的数据内容长度。

就算客户端同时发送两个数据包到服务端，当服务端接受时，也可以先读取四个字节的长度，然后根据长度获取消息的内容，这样就不会出现多读取或者少读取的情况了。

### Netty 主要采用了哪种设计模式

Netty 中利用到了众多的设计模式，有很多常见的设计模式，比如观察者模式、策略模式（在初始化 EventLoopGroup 时选择何种
DefaultEventExecutorChooserFactor-newChooser 时使用了），但是使用的最多的还是属于责任链模式，pipeline 就像一个责任链，ChannelHandler
就是其中处理逻辑的节点，通过自定义 Handler 来决定每个业务的执行逻辑。

### 什么是长连接

客户端和服务器之间定期发送的一种特殊的数据包，通知对方自己还在线，以确保 TCP 连接的有效性。但是由于网络不稳定性，有可能在 TCP 保持长连接的过程中，由于某些突发情况， 例如网线被拔出，
突然掉电等。 会造成服务器和客户端的连接中断。在这些突发情况下，如果恰好服务器和客户端之间没有交互的话，那么它们是不能在短时间内发现对方已经掉线的。

### Netty 如何保持长连接

利用心跳维护长连接信息。

在服务器和客户端之间一定时间内没有数据交互时，即处于 idle 状态时，客户端或服务器会发送一个特殊的数据包给对方，当接收方收到这个数据报文后， 也立即发送一个特殊的数据报文， 回应发送方， 此即一个
PING-PONG 交互。

当某一端收到心跳消息后， 就知道了对方仍然在线， 这就确保 TCP 连接的有效性。

Netty 有三种类型保持心跳类型

    readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）。
    writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）。
    allIdleTime：所有类型的超时时间。

### Netty 发送消息有几种方式？

Netty 有两种发送消息的方式：

直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；

写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。

### 序列化协议

序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。

影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU 资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。

Java 默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差

XML，

    优点：人机可读性好，可指定元素或特性的名称。
    缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。
    适用场景：当做配置文件存储数据，实时数据转换。

JSON，是一种轻量级的数据交换格式，

    优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与 XML 相比，其协议比较简单，解析速度比较快。
    缺点：数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开销比较大。
    适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于 Web browser 的 Ajax 请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。

Fastjson，采用一种 “假定有序快速匹配” 的算法。

    优点：接口简单易用、目前 java 语言中最快的 json 库。
    缺点：过于注重快，而偏离了 “标准” 及功能性、代码质量不高，文档不全。
    适用场景：协议交互、Web 输出、Android 客户端

Thrift，不仅是序列化协议，还是一个 RPC 框架。

    优点：序列化后的体积小，速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。
    缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如 HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。
    适用场景：分布式系统的 RPC 解决方案

Avro，Hadoop 的一个子项目，解决了 JSON 的冗长和没有 IDL 的问题。

    优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 RPC、支持跨编程语言实现。
    缺点：对于习惯于静态类型语言的用户不直观。
    适用场景：在 Hadoop 中做 Hive、Pig 和 MapReduce 的持久化数据格式。

Protobuf，将数据结构以.proto 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。

    优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON 等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。
    缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持 Java 、C++ 、python。
    适用场景：对性能要求高的 RPC 调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化

###

###

###

###

###

###

---

## 提高部分

---

###

---








---

参考链接：

- [Netty 灵魂 15 问](https://blog.51cto.com/u_12088995/2740328)
- [Netty 篇](https://itcn.blog/p/1649613222686952.html)
- []()
- []()
- []()
- []()

---















