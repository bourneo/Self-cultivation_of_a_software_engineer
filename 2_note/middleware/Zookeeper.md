# Zookeeper

---

## 基础部分

---

### Zookeeper 核心功能

- **数据发布和订阅**
- **负载均衡**
- **命名服务**
- **分布式锁**
- Master 选举
- 集群管理
- 分布式队列
- 分布式协调和通知

### Zookeeper 的节点类型

持久节点：

- 删除持久节点需要显式的调用 delete 方法。
- 适用场景：服务发布和订阅。

临时节点：

- 创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也在 ZooKeeper 服务器上删除。
- 适用场景：分布式锁。

有序节点：

- 适用场景：分布式锁、分布式 ID。

### Zookeeper 集群的角色

Leader：

- 主要工作是管理集群中其他的服务器，是工作的分配和调度者。
- 既可以为客户端提供写服务，又能提供读服务。

Follow：

- 主要工作是选举出 Leader 服务器。
- 在发生 Leader 服务器选举的时候，系统会根据多数投票原则,从 Follow 服务器，选举出一个服务器作为新的 Leader。
- 只能提供读服务。

Observer：

- 主要工作是处理来自客户端的获取数据等请求。
- 并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器。
- 只能提供读服务。

### ZAB 协议

ZooKeeper 最核心的作用就是保证分布式系统的数据一致性。

无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。

ZAB（Zookeeper Atomic Broadcast）：

- Zookeeper 原子广播协议，是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法。

ZAB 两个核心功能点：崩溃恢复、原子广播协议。

ZAB 核心思想：当多数 Server 写成功，则写成功。

当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。

操作过程：

- 当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。
- 当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。
- 然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。

为何采用奇数台节点：

- 可用节点数量 > 总节点数量 / 2。
- 节约服务器资源。

### Zookeeper 2PC 事务提交图

<div align="center">
<img width="600"  alt="Zookeeper 2PC 事务提交图" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/middleware/ZooKeeper-2PC.png"/></div>

### Zookeeper 实现分布式锁

分布式锁的目的：

- 在分布式部署的应用集群中，保证多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行。

Watch 机制：

- 客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知。

方案一：使用节点中的存储数据区域。

- ZK 中节点存储数据的大小不能超过 1M，但是只是存放一个标识是足够的。
- 线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识。
- 死锁风险：
    - 方案一看上去是没问题的，用的时候设置标识，用完清除标识。
    - 但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行。

方案二：使用子节点。

- 每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序。
- 默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可
    - 死锁风险：
        - 方案二也存在这个问题，但方案二可以利用 ZK 的临时顺序节点来解决这个问题。
        - 只要线程发生了异常导致程序中断，就会丢失与 ZK 的连接，ZK 检测到该链接断开，就会自动删除该链接创建的临时节点。
        - 这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的。


- 避免羊群效应：
    - 把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。
    - 如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。
    - 这就是羊群效应，为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。

### Zookeeper 分布式锁优点

- 有避免死锁的成熟方案。

### Zookeeper 分布式锁缺点

- 对并发量非常大的服务来说，难以保证性能。

### Zookeeper 实现分布式 ID

- 每个需要 ID 编码的业务服务器，可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。
- 实现原理：利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。
- 潜在问题：在定义编码的规则上强烈依赖于程序员自身的能力和对业务的深入理解。

### Zookeeper 的负载均衡算法

**轮询法**：

- 当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。

**随机法**：

- 负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。

**原地址哈希法**：

- 根据客户端的 IP 地址进行哈希计算，用计算结果进行取模，根据最终结果，选择服务器地址列表中的一台机器处理该条会话请求。

**最小连接数法**：

- 根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。

加权轮询法：

- 和轮询算法的方式很相似，不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。

加权随机法：

- 在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。

---

## 提高部分

---

###

---










---

参考链接：

- [ZooKeeper 核心知识总结](https://mp.weixin.qq.com/s/B2ngp0q5kdWsCNH8sw_5DA****)

---



