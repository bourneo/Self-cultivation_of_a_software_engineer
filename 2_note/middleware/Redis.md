# Redis

---

## 基础部分

---

### Redis 五大数据类型

**String**：

- redis 的 String 可以表示任何数据，比如 jpg 图像或者序列化的对象。
- String 的最大值能存储 512 MB。
- 常用命令：
    - set：往 redis 里输入 key-value。
    - get：输入 key 值，返回对应的 value 值。
    - incr：自增。
    - decr：自减。
    - mget：一次性获取多个 key 的 value。

**List**：

- 队列，List 的两端操作比较方便。
- 常用命令：
    - lpush：从列表 List 的左边插入一个元素。
    - lpop：从列表 List 的左边移出一个元素。
    - rpush：从列表 List 的右边插入一个元素。
    - rpop：从列表 List 的右边移出一个元素。
    - llen：打印当前列表 List 中的元素个数。

**Set**：

- 集合。
- 常用命令：
    - sadd：往 set 中添加数据。
    - srem：从 set 中删除数据。
    - scard：查看 set 中存在的元素个数。
    - sismember：查看 set 中是否存在某个数据。

**Hash**：

- 哈希。
- 比如：
    - hget：通过 key 值，从 hash 里取对应的 value。
    - hset：往 hash 里，添加 key-value。
    - hmget：一次性获取多个 key 的 value。

**ZSet**：

- 有序集合。
- 例如：
    - zadd：添加数据。
    - zrem：删除元素。
        - zrem 还可以一次性删除多个元素。
    - zcard：查询数据。
    - zrange：数据排序，根据分数从小到大。
    - zrevrange：数据排序， 根据分数从大到小。

### Redis 五大数据类型的使用场景

**String**：

- 普通的 key-value 键值对都可以用 String 来保存。
- 例如：
    - 访问量统计，每次访问博客和文章，都用 incr 命令加一。
    - 做缓存。
    - 限流。
    - 计数器。
    - 分布式所。
    - 分布式 Session。

**List**：

- 作为队列，因为 List 的两端操作比较方便，所以可以用于一些需要获取最新数据的场景。
- 例如：
    - 新闻类应用的最新新闻。
    - 简单队列。
    - 微博时间轴列表。

**Set**：

- 例如：
    - 好友推荐，根据 Set 的内容求交集，大于某个阈值就可以推荐。
    - 利用 Set 的唯一性，统计网站内所有独立 ip。
    - 点赞。
    - 点踩。
    - 标签。
    - 好友关系。

**Hash**：

- 用于存储、修改对象属性。
- 例如：
    - 用户（姓名、性别、爱好），文章（标题、发布时间、作者、内容）。
    - 其中用户相当于 key，（姓名、性别、爱好）相当于存储的 value。
    - 用户主页访问量。

**ZSet**：

- zSet 本来就是有序的，并且有排序功能。
- 例如：排行榜。

---

## 提高部分

---

### Redis 事务和 ACID 属性

**原子性（atomicity）**：

Redis 不支持回滚。

Redis 命令在事务执行时可能会失败，但仍会继续执行剩余命令而不是 Rollback（事务回滚）。如果你使用过关系数据库，这种情况可能会让你感到很奇怪。

来自官网的解释：

- Redis 作者认为发生事务回滚的原因大部分都是程序错误导致，这种情况一般发生在开发和测试阶段，而生产环境很少出现。
- 对于逻辑性错误，比如本来应该把一个数加 1 ，但是程序逻辑写成了加 2，那么这种错误也是无法通过事务回滚来进行解决的。
- Redis 追求的是简单高效，而传统事务的实现相对比较复杂，这和 Redis 的设计思想相违背。

**一致性（consistency）**：

一致性是事务执行前后的数据符合数据库的定义和要求。

这一点 Redis 中的事务是符合要求的，不论是发生语法错误还是运行时错误，错误的命令均不会被执行。

**隔离性（isolation）**：

事务中的所有命令都会按顺序执行。

在执行 Redis 事务的过程中，另一个客户端发出的请求不可能被服务，这保证了命令是作为单独的独立操作执行的。所以 Redis 当中的事务是符合隔离性要求的。

**持久性（durability）**：

- 如果 Redis 当中没有被开启持久化，那么就是纯内存运行的，一旦重启，所有数据都会丢失，此时可以认为 Redis 不具备事务的持久性；
- 而如果 Redis 开启了持久化，那么可以认为 Redis 在特定条件下是具备持久性的。

### Redis 是单线程还是多线程

Redis 不同版本之间采用的线程模型是不一样的，在 Redis4.0 版本之前使用的是单线程模型，在 4.0 版本之后增加了多线程的支持。

在 4.0 之前虽然我们说 Redis 是单线程，也只是说它的网络 I/O 线程以及 Set 和 Get 操作是由一个线程完成的。但是 Redis 的持久化、集群同步还是使用其他线程来完成。

4.0 之后添加了多线程的支持，主要是体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等。

### 为什么 Redis 在 4.0 之前会选择使用单线程？而且使用单线程还那么快？

选择单线程个人觉得主要是使用简单，不存在锁竞争，可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销，但同时单线程也不能完全发挥出多核 CPU 的性能。

至于为什么单线程那么快我觉得主要有以下几个原因：

> Redis 的大部分操作都在内存中完成，内存中的执行效率本身就很快，并且采用了高效的数据结构，比如哈希表和跳表。
>
> 使用单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。
>
> 采用 I/O 多路复用机制处理大量客户端的 Socket 请求，因为这是基于非阻塞的 I/O 模型，这就让 Redis 可以高效地进行网络通信，I/O 的读写流程也不再阻塞。

### Redis 是如何实现数据不丢失的

Redis 数据是存储在内存中的，为了保证 Redis 数据不丢失，那就要把数据从内存存储到磁盘上，以便在服务器重启后还能够从磁盘中恢复原有数据，这就是 Redis 的数据持久化。

Redis 数据持久化有三种方式：

> AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。
>
> RDB 快照（Redis DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。
>
> 混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。

### AOF 和 RDB 的实现原理

AOF：

采用的是写后日志的方式，Redis 先执行命令把数据写入内存，然后再记录日志到文件中。

AOF 日志记录的是操作命令，不是实际的数据，如果采用 AOF 方法做故障恢复时需要将全量日志都执行一遍。

RDB：

采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作，所以采用 RDB 方法做故障恢复时只需要直接把 RDB 文件读入内存即可，实现快速恢复。

### Redis 为什么要先执行命令，再把数据写入日志

主要是由于 Redis 在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，

而且在命令执行后再写日志不会阻塞当前的写操作。

### 后写日志有什么风险

后写日志主要有两个风险可能会发生：

> 数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。
>
> 可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。

### RDB 做快照时会阻塞线程吗

Redis 提供了两个命令来生成 RDB 快照文件，分别是 save 和 bgsave。

save 命令在主线程中执行，会导致阻塞。

而 bgsave 命令则会创建一个子进程，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置。

### RDB 做快照的时候数据能修改吗

save 是同步的会阻塞客户端命令，

bgsave 的时候是可以修改的。

### Redis 怎么解决在 bgsave 做快照的时候允许数据修改的

这里主要是利用 bgsave 的子线程实现的，具体操作如下：

> 如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响；
>
> 如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。

要注意，Redis 对 RDB 的执行频率非常重要，因为这会影响快照数据的完整性以及 Redis 的稳定性，所以在 Redis 4.0 后，增加了 AOF 和 RDB 混合的数据持久化机制：

把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。

### Redis 如何实现高可用

Redis 实现高可用主要有三种方式：主从复制、哨兵模式，以及 Redis 集群。

主从复制：

> 将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，这个跟 MySQL 主从复制的原理一样。

哨兵模式：

> 使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复，为了解决这个问题，Redis 增加了哨兵模式。
>
> 因为哨兵模式做到了可以监控主从服务器，并且提供自动容灾恢复的功能。

Redis Cluster（集群）：

> Redis Cluster 是一种分布式去中心化的运行模式，是在 Redis 3.0 版本中推出的 Redis 集群方案，
>
> 它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。

### 为什么需要使用集群模式

哨兵模式归根节点还是主从模式，在主从模式下我们可以通过增加 salve 节点来扩展读并发能力，但是没办法扩展写能力和存储能力，存储能力只能是 master 节点能够承载的上限。

所以为了扩展写能力和存储能力，我们就需要引入集群模式。

### 集群中那么多 Master 节点，redis cluster 在存储的时候如何确定选择哪个节点呢

Redis Cluster 采用的是类一致性哈希算法实现节点选择的，至于什么是一致性哈希算法你自己回去看看。

Redis Cluster 将自己分成了 16384 个 Slot（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。

> 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
>
> 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。



---

## Redis 底层原理

---

### redisObject 内部结构

Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value

redisObject 内部结构：

- type：
    - 用来表示这个 redisObject 是属于五种类型 (string、hash、list、set、zset) 的哪一种
    - 比如 type=string 代表 value 存储的是一个普通字符串


- encoding：
    - 用来表示 type 的底层数据结构是用什么实现的
    - 打个比方，就如 Java 中的 list ，可以由 ArrayList 来实现，也可以由 LinkedList 来实现


- ptr：
    - 指向底层数据结构的指针


- vm：
    - 只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的

<div align="center">
<img width="600"  alt="redisObject 内部结构" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/middleware/redisObject内部结构.bmp"/></div>

### redisObject 如何表示 string

字符串的编码方式有三种：

- int：
    - 当 string 对象的值全部是数字，就会使用 int 编码。


- raw：
    - 如果字符串 string 保存的是一个字符串值，并且这个字符串大于 39 个字节。
    - 那么字符串对象将使用一个简单动态字符串 (SDS) 来保存这个字符串值。
    - 并将 redisObject 的 encoding 设置为 raw。


- embstr：
    - 如果字符串 string 保存的是一个字符串值，并且这个字符串小于 39 个字节，那么字符串将使用 embstr 编码的方式来保存这个字符串。

### redisObject 如何表示 list

列表对象 list 的编码方式有两种：

- ziplist：
    - 压缩列表是节省内存而设计的内存结构（是 redis 创造的）。
    - 优点：节省内存。
    - 缺点：比其他结构要消耗更多的时间。
    - 所以 redis 在数据量少的时候使用压缩列表存储。


- linkedlist：
    - 当列表长度少于 512 且每个元素都少于 64 个字节，那么就用 ziplist 存储。
    - 否则就用 linkedlist 存储。

### redisObject 如何表示 hash

hash 的 encoding 编码方式有两种：

- ziplist：
    - 当哈希对象保存的键值对数量少于 512，且所有键值对的长度都少于 64 字节时，使用压缩列表保存。


- hashtable：
    - 当哈希对象保存的键值对个数大于 512，并且其中有键值对大于 64 个字节，就使用 hashtable 保存。

### redisObject 如何表示 set

set 的 encoding 编码方式有两种：

- intset：
    - 集合的长度少于 512 时，并且所有元素都是整数，使用 intset 存储。
    - 否则使用 hashtable。


- hashtable：
    - hashtable 编码的底层实现是字典，字典的每个键是字符串对象，只不过值都是空 (NULL)。

### redisObject 如何表示 zset

zset 的 encoding 编码方式有两种：

- ziplist：
    - 当 zset 的长度少于 128，并且所有元素的长度都少于 64 字节时，用 ziplist 存储。
    - 否则用 skiplist 存储。


- skiplist：
    - redis 的 skiplist 是由字典 dict 和跳表构成的。
        - dict 用于记录字符串对象和分数，即查询字符串对象对应分数。
        - 跳表则用来，根据分数查询对应字符串。

为什么 skiplist 编码要同时用字典和跳表来实现：

- 字典查询分值的时间复杂度是 O (1)，但是无序。
- 跳表的优点是有序，但是查询的时间复杂度为 O (logn)。
- 虽然采用两个结构，但是集合的元素成员和分值是共享的，两种结构都通过指针指向同一地址，所以不会存在内存浪费。

---








---

参考链接：

- [Redis 的五种数据类型及其底层原理](https://blog.csdn.net/u014453898/article/details/112292028)
- [不能回滚的 Redis 事务还能用吗](https://www.cnblogs.com/lonely-wolf/p/14435075.html)
- [Redis 夺命十二问，你能扛到第几问？](https://mp.weixin.qq.com/s/ItIHbYsR4xiu2psUniN-5g)
- []()

---















