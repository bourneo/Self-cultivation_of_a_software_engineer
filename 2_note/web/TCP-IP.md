# TCP-IP

---

## 基础部分

---

### TCP / IP 四层模型

记忆口诀：NITA（我**你他**）。

**网络访问（链接）层 / Network Access (link) layer**：

- 例如：以太网、 Wi-Fi、MPLS 等
- **主要负责转换数字信号和物理二进制信号**

**网络互连层 / internet layer**：

- 对于 TCP / IP 来说这是因特网协议（IP）
- ICMP 和 IGMP 这样的必须协议尽管运行在 IP 上，也仍然可以看作是网络互连层的一部分
- ARP 不运行在 IP 上
- **主要负责寻址（找到目标设备的位置）**

**传输层 / transport layer**：

- 例如：TCP、UDP、RTP、SCTP
- OSPF 这样的路由协议，尽管运行在 IP 上也可以看作是网络层的一部分
- **主要负责传输应用层的数据包**

**应用层 / application layer**：

- 例如：HTTP、FTP、DNS
- BGP 和 RIP 这样的路由协议，尽管由于各种各样的原因它们分别运行在 TCP 和 UDP 上，仍然可以将它们看作网络层的一部分）
- **主要：web 浏览器的 HTTP 协议，文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等**

### TCP / IP 四层网络协议的作用：

发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。

接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。

层层加密和解密后，应用层最终拿到了需要的数据。

### TCP / IP 协议族：

从字面意义上来讲，TCP / IP 是指传输层的 TCP 协议和网络层的 IP 协议。

实际上，TCP / IP 只是利用 IP 进行通信时所必须用到的协议群的统称。

具体来说，在网络层是 IP / ICMP 协议、在传输层是 TCP / UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。

他们都属于 TCP / IP 协议。

### TCP 协议属于哪一层、IP 协议呢

TCP 属于传输层，UDP 也属于传输层，传输层主要负责数据包的传输。

IP 属于网络层，网络层主要负责网络寻址。

在 TCP / IP 四层模型中，传输层下面是链路层，链路层主要负责转换数字信号和物理二进制信号。

- 网络层上面是应用层，应用层主要提供为应用软件而设计的接口，协议由发送方和接收方约定好。

在 OSI 7 层模型中，传输层的上面是会话层，会话层主要是负责会话的开启和关闭。

- 会话层上面是表示层，表示层负责数据格式的转换，数据格式的编码和解码。
- 最底层是物理层，主要负责比特流的传输，数模转换和模数转换。

### TCP 协议是单工还是双工

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。

双工 / 单工：

- 在任何一个时刻，如果数据只能单向发送，就是单工。
- 如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
- 如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
- TCP 是一个双工协议，数据任何时候都可以双向传输。
- 这就意味着客户端和服务端可以平等地发送、接收信息。

### TCP 协议的主要特点

- TCP 是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。
- 每一条 TCP 连接只能有两个端点（即两个套接字），只能是点对点的；
- TCP 提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；
- TCP 提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；
- 面向字节流。
    - 虽然应用程序与 TCP 交互是一次一个大小不等的数据块，但 TCP 把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，
    - 例如，发送方应用程序交给发送方的 TCP10 个数据块，接收方的 TCP 可能只用收到的 4 个数据块字节流交付给上层的应用程序

### TCP 协议报文段

TCP 虽面向字节流，但传送的数据单元为报文段： 报文段 = 首部 + 数据。

TCP 的全部功能体现在它首部中各字段的作用:

- 首部前 20 个字符固定、后面有 4n 个字节是根据需而增加的选项。
- 故 TCP 首部最小长度 = 20 字节。

### TCP 协议报文段首部

<div align="center">
<img width="600"  alt="TCP协议报文首部" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/TCP协议报文首部.webp"/></div>


TCP 协议报文首部字段：

端口：

- 源端口号和目地端口各占 16 位两个字节，也就是端口的范围是 2^16=65535。
- 另外 1024 以下是系统保留的，从 1024-65535 是用户使用的端口范围。

seq 序号：

- 占 4 字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。
- 例如：一段报文的序号字段值是 107，携带的数据是 100 个字段，下一个报文段序号从 107+100=207 开始。

ack 确认号：

- 4 个字节，是期望收到对方下一个报文段的第一个数据字节的序号。
- 例如：B 收到 A 发送的报文，其序号字段是 301，数据长度是 200 字节，表明 B 正确收到 A 发送的到序号 500 为止的数据（301+200-1=500），B 期望收到 A
  下一个数据序号是 501，B 发送给 A 的确认报文段中把 ack 确认号置为 501。

数据偏移：头部有可选字段，长度不固定，指出 TCP 报文段的数据起始处距离报文段的起始处有多远。

保留：保留今后使用的，被标为 1。

控制位： 由 8 个标志位组成。每个标志位表示一个控制功能。其中主要的 6 个：

- URG 紧急指针标志，为 1 表示紧急指针有效，为 0 忽略紧急指针。
- ACK 确认序号标志，为 1 表示确认号有效，为 0 表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。
- PSH 标志，为 1 表示带有 push 标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。
- RST 重置连接标志，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。
- SYN 同步序号，同步序号，用于建立连接过程，在连接请求中，SYN=1 和 ACK=0 表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即 SYN=1 和 ACK=1。
- FIN 终止标志，用于释放连接，为 1 时表示发送方没有发送了。

窗口：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。

校验和：奇偶校验，此校验和是对整个的 TCP 报文段（包括 TCP 头部和 TCP 数据），以 16 位进行计算所得，由发送端计算和存储，接收端进行验证。

紧急指针：只有控制位中的 URG 为 1 时才有效，指出本报文段中的紧急数据的字节数。

选项：其长度可变，定义其他的可选参数。

### TCP 粘包和拆包问题

TCP 是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP 协议也没有字段说明发送数据包的大小。

而且 TCP 不保证接受方应用程序收到的数据块和发送应用程序发送的数据块具有对应的大小关系。

比如发送方应用程序交给发送方 TCP 10 个数据块，接受方 TCP 可能只用了 4 个数据块就完整的把接受到的字节流交给了上层应用程序。

TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP。

拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。

### TCP 粘包和拆包的解决思路

由于 TCP 无法理解上一层的业务数据特点，所以 TCP 是无法保证发送的数据包不发生粘包和拆包，这个问题只能通过上层的协议栈设计来解决。

解决思路有一下几种：

1. 消息定长：每个发送的数据包大小固定，比如 100 字节，不足 100 字节的用空格补充，接受方取数据的时候根据这个长度来读取数据。
2. 消息末尾增加换行符来表示一条完整的消息：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。
3. 将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，例如 UDP 协议是这么设计的，用两个字节来表示消息长度，所以 UDP 不存在粘包。

### TCP 协议如何保证可靠传输

可靠传输有如下两个特点:

- 传输信道无差错，保证传输数据正确；
- 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。

首先，采用三次握手来建立 TCP 连接，四次握手来释放 TCP 连接，从而保证建立的传输信道是可靠的。

其次，TCP 采用了连续 ARQ 协议来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。

- ARQ 协议：回退 N (Go-back-N)；超时自动重传。

最后，TCP 使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。

### 什么是半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

补充一点关于SYN-ACK 重传次数的问题：

- 服务器发送完 SYN－ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，
- 如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

### TCP 协议三次握手的过程中可以携带数据吗

其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN
报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。

### 2MSL 的作用

### 为什么 TIME_WAIT 要等待 2MSL？

MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

有以下两个原因：

**保证 TCP 协议的全双工连接能够可靠关闭**：

- 由于 IP 协议的不可靠性或者是其它网络原因，导致了 Server 端没有收到 Client 端的 ACK 报文，那么 Server 端就会在超时之后重新发送 FIN，如果此时 Client
  端的连接已经关闭处于 CLOESD 状态，那么重发的 FIN 就找不到对应的连接了，从而导致连接错乱
- 所以，Client 端发送完最后的 ACK 不能直接进入 CLOSED 状态，而要保持 TIME_WAIT，当再次收到 FIN 的时候，能够保证对方收到 ACK，最后正确关闭连接

**保证这次连接的重复数据段从网络中消失**：

- 如果 Client 端发送最后的 ACK 直接进入 CLOSED 状态，然后又再向 Server
  端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了
- 那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达 Client 端，由于新老连接的端口号和 IP 都一样，TCP
  协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱
- 所以 TCP 连接需要在 TIME_WAIT 状态等待 2 倍 MSL，才能保证本次连接的所有数据在网络中消失

### Socket / 套接字

应用层与 TCP / IP 协议族通信的中间软件抽象层，表现为**一个封装了 TCP / IP 协议族的编程接口（API）**。

Socket **是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）**，不是一种协议。

对用户来说，只需调用 Socket 去组织数据，以符合指定的协议，即可通信。

Socket 套接字：

<div align="center">
<img width="600"  alt="Socket套接字" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/Socket套接字.webp"/></div>

### UDP 协议特点

1. UDP 是无连接的传输层协议。
2. UDP 使用尽最大努力交付，不保证可靠交付。
3. UDP 是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界。
4. UDP 没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率。
5. UDP 支持一对一一对多多对多的交互通信。
6. UDP 的首部开销小，只有８字节。

### UDP 协议报文段

UDP 的报文段共有 2 个字段：数据字段 + 首部字段。

UDP 报文中每个字段的含义如下：

- 源端口：
    - 这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，
    - 这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。
- 目的端口：
    - 接收端计算机上 UDP 软件使用的端口，占据 16 位。
- 长度：
    - 该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。
- 校验值：
    - 该字段占据 16 位，可以检验数据在传输过程中是否被损坏。

UDP 协议报文段：

<div align="center">
<img width="600"  alt="UDP协议报文段" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/UDP协议报文段.webp"/></div>

### IP 地址

IP 地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机。

本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。

IP 地址对应于 OSI 参考模型的第三层网络层，工作在网络层的路由器根据目标 IP 和源 IP 来判断是否属于同一网段，如果是不同网段，则转发数据包。 。

### IP 地址格式和表示

IP 地址 (IPv4) 由 32 位二进制数组成，分为 4 段（4 个字节），每一段为 8 位二进制数（1 个字节）。

每一段 8 位二进制，中间使用英文的标点符号. 隔开。

由于二进制数太长，为了便于记忆和识别，把每一段 8 位二进制数转成十进制，大小为 0 至 255。

IP 地址的这种表示法叫做点分十进制表示法。

IP 地址表示为：xxx.xxx.xxx.xxx。

计算机的 IP 地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不能同时重复出现。

路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的是同一网段的计算机。

通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的 IP 地址不会互相重叠，即 IP 地址具有了唯一性。

### IP 地址分类详解

IP 地址分 A、B、C、D、E 五类，其中 A、B、C 这三类是比较常用的 IP 地址，D、E 类为特殊地址。

IP 地址分类：
<div align="center">
<img width="600"  alt="IP地址分类" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/IP地址分类.webp"/></div>

---

## 提高部分

---

### 什么是三次握手与四次挥手

视频讲解：[《一条视频讲清楚 TCP 协议与 UDP 协议——什么是三次握手与四次挥手》——掌芝士 zzs](https://www.bilibili.com/video/BV1kV411j7hA?from=search&seid=17424179872667418942)

视频讲解：[三分钟了解 TCP 的四次挥手 | 平均 0.75 秒了解一次挥手](https://www.bilibili.com/video/BV1C5411Y7dG)

视频讲解：[你是否也曾疑惑 TCP 三次握手的连接过程 | 以及它为什么是三次](https://www.bilibili.com/video/BV1vA411i7rs)

### TCP 协议的三次握手

第一次握手：

- 客户端将 TCP 报文标志位 SYN 置为 1，随机产生一个序号值 seq=J，保存在 TCP 首部的序列号字段里，指明客户端打算连接的服务器的端口，
- 并将该数据包发送给服务器端，发送完毕后，客户端进入 SYN_SENT 状态，等待服务器端确认。

第二次握手：

- 服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将 TCP 报文标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个序号值 seq=K，
- 并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态

第三次握手：

- 客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，
- 并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，
- 如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

上面写的 ack 和 ACK，不是同一个概念：

- 小写的 ack 代表的是头部的确认号 Acknowledge number，缩写 ack，是对上一个包的序号进行确认的号，ack=seq+1。
- 大写的 ACK，则是我们上面说的 TCP 首部的标志位，用于标志的 TCP 包是否对上一个包进行了确认操作，如果确认了，则把 ACK 标志位设置成 1。

TCP 三次握手：

<div align="center">
<img width="600"  alt="TCP三次握手" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/TCP三次握手.webp"/></div>

### TCP 协议为什么是三次握手，而不是两次握手

为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。

三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。

如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。

《计算机网络》中是这样说的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

### TCP 协议的四次挥手

挥手请求可以是 Client 端，也可以是 Server 端发起的，我们假设是 Client 端发起：

- 第一次挥手：Client 端发起挥手请求，向 Server 端发送标志位是 FIN 报文段，设置序列号 seq，此时，Client 端进入 FIN_WAIT_1 状态，这表示 Client
  端没有数据要发送给 Server 端了


- 第二次挥手：Server 端收到了 Client 端发送的 FIN 报文段，向 Client 端返回一个标志位是 ACK 的报文段，ack 设为 seq 加 1，Client 端进入
  FIN_WAIT_2 状态，Server 端告诉 Client 端，我确认并同意你的关闭请求


- 第三次挥手：Server 端向 Client 端发送标志位是 FIN 的报文段，请求关闭连接，同时 Client 端进入 LAST_ACK 状态


- 第四次挥手 ：Client 端收到 Server 端发送的 FIN 报文段，向 Server 端发送标志位是 ACK 的报文段，然后 Client 端进入 TIME_WAIT 状态，Server
  端收到 Client 端的 ACK 报文段以后，就关闭连接，此时，Client 端等待 2MSL 的时间后依然没有收到回复，则证明 Server 端已正常关闭，那好，Client
  端也可以关闭连接了

TCP 四次挥手：

<div align="center">
<img width="600"  alt="TCP四次挥手" src="https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/7_image/web/TCP四次挥手.webp"/></div>

### TCP 协议为什么连接的时候是三次握手，关闭的时候却是四次挥手

建立连接时因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。

其中 ACK 报文是用来应答的，SYN 报文是用来同步的。所以建立连接只需要三次握手。

由于 TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP 是全双工模式。

这就意味着，关闭连接时，当 Client 端发出 FIN 报文段时，只是表示 Client 端告诉 Server 端数据已经发送完毕了。

当 Server 端收到 FIN 报文并返回 ACK 报文段，表示它已经知道 Client 端没有数据发送了，但是 Server 端还是可以发送数据到 Client 端的，所以 Server
很可能并不会立即关闭 SOCKET，直到 Server 端把数据也发送完毕。

当 Server 端也发送了 FIN 报文段时，这个时候就表示 Server 端也没有数据要发送了，就会告诉 Client 端，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。

### TCP 和 UDP 的区别

视频讲解：[TCP 对决 UDP](https://www.bilibili.com/video/BV1rf4y1R7n3)

1. TCP 是可靠传输，UDP 是不可靠传输。
2. TCP 面向连接，UDP 无连接。
3. TCP 传输数据有序，UDP 不保证数据的有序性。
4. TCP 不保存数据边界，UDP 保留数据边界。
5. TCP 传输速度相对 UDP 较慢。
6. TCP 有流量控制和拥塞控制，UDP 没有。
7. TCP 是重量级协议，UDP 是轻量级协议。
8. TCP 首部较长 20 字节，UDP 首部较短８字节。
9. HTTP、HTTPS、FTP、TELNET、SMTP (简单邮件传输协议) 协议基于可靠的 TCP 协议。
10. TFTP、DNS、DHCP、TFTP、SNMP (简单网络管理协议)、RIP 基于不可靠的 UDP 协议。

### 三握四挥的状态变化

---








---

参考链接：

- [互联网协议套件](https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F)
- [地址解析协议](https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE)
- [计算机网络常用知识总结](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247486942&idx=1&sn=547fc2f0586a0e5e0003549afc50022e)

---












