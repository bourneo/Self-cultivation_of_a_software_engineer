# HTTP-HTTPS

---

## 基础部分

---

### HTTP 请求报文的组成

- 请求行：
    - 请求方法。
    - 请求 URL。
    - HTTP 协议及版本。
- 请求头：
    - Header 里的属性和值。
    - 比如：Content-Type，指定请求体格式。
- 请求体：
    - 常用的有一下三种类型：
    - 任意类型：服务器不会解析请求体，请求体的处理需要自己解析。
        - application/json 格式文本。
        - text/xml 格式文本。
    - 表单类型：application/x-www-form-urlencoded。
    - 文件：multipart/form-data; boundary。

### HTTP 请求报文的属性

常见的 HTTP 报文头属性：

- Accept：
    - 告诉服务端，客户端接收什么类型的响应。
- Referer：
    - 表示这是请求是从哪个 URL 进来的。
- Cache-Control：
    - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置。
- Accept-Encoding：
    - 例如: Accept-Encoding: gzip, deflate (这两种都是压缩格式)。
    - 告诉服务器能接受什么编码格式，包括字符编码，压缩形式 (一般都是压缩形式)。
- Host：
    - 指定要请求的资源所在的主机和端口。
- User-Agent：
    - 告诉服务器，客户端使用的操作系统、浏览器版本和名称。
- Connection：
    - 决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。
    - 持久连接，事务完成后不关闭网络连接 ：Connection: keep-alive。
    - 非持久连接，事务完成后关闭网络连接：Connection: close。

### HTTP 响应报文的组成

- 响应行：
    - HTTP 协议及版本。
    - 状态码及状态描述。
- 响应头：
- 响应体：

### HTTP 响应报文的属性

- Cache-Control：
    - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存。
- ETag：
    - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变。
- Location：
    - 在重定向中或者创建新资源时使用。
- Set-Cookie：
    - 服务端可以设置客户端的 cookie。

### HTTP 协议状态码

1XX：

- 指示信息，表示**请求已接收**，继续处理。

2XX：

- 成功，表示请求已经被**成功接收**、理解、接受。
- **200 OK** 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：

- 状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。
- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
    - 搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    - 搜索引擎会抓取新的内容而保存旧的网址。
- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：

- 状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。
- **400 Bad Request** 表示客户端请求的报文有错误。
- 401 Unauthorized 缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- **403 Forbidden** 表示服务器禁止访问资源，并不是客户端的请求出错。
- **404 Not Found** 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：

- 状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。
- 501 Not Implemented 表示客户端请求的功能还不支持。
- **502 Bad Gateway** 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- **504 Gateway Timeout** 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

### 数据加密的方式

HTTPS 协议会对传输的数据进行加密，而加密过程是使用了**非对称加密**。

**非对称加密：客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密**。

HTTPS 的整体过程分为：证书验证和数据传输。

具体的交互过程：

1. Client 发起一个 HTTPS 的请求。
2. Server 把事先配置好的公钥证书返回给客户端。
3. Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL
   吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
4. Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
5. Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
6. Server 使用对称密钥加密明文内容 A，发送给 Client。
7. Client 使用对称密钥解密响应的密文，得到明文内容 A。
8. Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

如何保证公钥不被篡改和信任度：

- 借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
- 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

### SSL 层的主要作用是什么

**TLS（Transport Layer Security）：传输层安全性协议**。

**SSL（Secure Sockets Layer）：安全套接层**。

- 一种安全协议，目的是为互联网通信提供安全及数据完整性保障。
- 是 TLS 的前身。
- SSL 包含记录层（Record Layer）和传输层。
- 记录层协议确定传输层数据的封装格式。
- 传输层安全协议使用 X.509 认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。
- 这个会谈密钥是用来将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。

### SSL 层的主要对什么进行加密

### HTTP 1.0、HTTP 1.1、HTTP 2.0、HTTP 3.0

HTTP 1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。

HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

HTTP 1.1：

- 长连接
    - HTTP 1.1 支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP
      请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
    - HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive
      时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接
- 管道网络传输
    - 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间
    - 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求，要是前面的回应特别慢，后面就会有许多请求排队等着
- Host 字段
    - HTTP 1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）
- 100Status
    - HTTP 1.1 加入了一个新的状态码 100
    - 客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）
    - 如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了
    - 100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request
      body，再决定要不要发 request body
- Chunked Transfer Coding
    - HTTP 1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志
    - 这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载
- Cache
    - HTTP 1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable
      对象，而是与源服务器进行重新激活

HTTP 2.0：

- 新的二进制格式。
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request
  可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份
  header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。
- 服务端推送。
- 数据流。
    - HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
    - 因此，必须要对数据包做标记，指出它属于哪个回应。
    - 每个请求或回应的所有数据包，称为一个数据流（Stream）。

HTTP 3.0：

- 使用 UDP 协议。
- 一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

### Cookie 和 Session

Session 是基于 Cookie 实现的另一种记录服务端和客户端会话状态的机制

Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中

Session 的认证过程：

- 客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID。
- 客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名。
- 当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的
  Session，如果有对应的 Session 则通过，继续执行请求，否则就中断。

### Cookie 和 Session 的区别

安全性：因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态。

适用性：Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据。

有效期：Cookie 可以设置任意时间有效，而 Session 一般失效时间短。

---

## 提高部分

---

### HTTP 和 HTTPS 的区别

HTTP **是明文传输协议**。

HTTPS **是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议**。

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO。
- HTTPS 需要用到 SSL 证书，而 HTTP 不用。
- HTTPS 标准端口 443，HTTP 标准端口 80。
- HTTPS 基于传输层，HTTP 基于应用层。
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示。

### 在浏览器地址栏键入 URL

1、**DNS 解析**：浏览器会依据 URL 逐层查询 DNS 服务器缓存，解析 URL 中的域名对应的 IP 地址，DNS 缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS
服务器缓存、域名服务器缓存、顶级域名服务器缓存。 从哪个缓存找到对应的 IP 直接返回，不再查询后面的缓存。

2、**TCP 连接**：结合三次握手。

3、**发送 HTTP 请求**：浏览器发出读取文件的 HTTP 请求，该请求发送给服务器。

4、**服务器处理请求并返回 HTTP 报文**：服务器对浏览器请求做出响应，把对应的带有 HTML 文本的 HTTP 响应报文发送给浏览器。

5、**浏览器解析渲染页面**。

6、**连接结束**：浏览器释放 TCP 连接，该步骤即四次挥手。 第 5 步和第 6 步可以认为是同时发生的，哪一步在前没有特别的要求。

### 输入 url 后发生的事，过程怎么优化

### HTTP 协议的工作过程

---







---

参考链接：

- [传输层安全性协议](https://zh.wikipedia.org/zh-cn/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)
- [计算机网络常用知识总结](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247486942&idx=1&sn=547fc2f0586a0e5e0003549afc50022e)
- []()

---













