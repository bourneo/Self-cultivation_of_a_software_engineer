# Design Pattern / 设计模式

---

## 小结

---

### 常用的设计模式

工厂模式：

> 可以把对象的创建和使用过程分割开来。
>
> 把对象创建的具体逻辑给隐藏起来了，交给工厂统一管理，这样不仅减少了代码量，以后如果想改代码的话，只需要改一处即可，也方便我们日常的维护。

代理模式：

> 不用改动原有代码，而去添加一些特定的业务功能；
>
> 公共的功能交给了代理角色，实现了业务的分工；
>
> 公共的功能发生扩展的时候，可以使用代理类集中管理；

适配器模式：

> 将目标类和适配者类解耦。
>
> 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
>
> 灵活性和扩展性都非常好，符合开闭原则。

### 简单的设计模式

单例模式：

> 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。
>
> 因为类控制了实例化过程，所以类可以灵活更改实例化过程。

策略模式：

> 策略模式避免了使用多重条件 if-else 语句，提高了项目的可维护性
>
> 策略模式完美支持开闭原则，可以在不修改原代码的情况下，灵活增加新的算法策略

### 讨巧的设计模式

观察者模式：

> 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
>
> 目标与观察者之间建立了一套触发机制。

装饰器模式：

> 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
>
> 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
>
> 装饰器模式完全遵守开闭原则

责任链模式：

> 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
>
> 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
>
> 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
>
> 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
>
> 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

原型模式：

> 性能优良，Java自带的 原型模式 是基于内存二进制流的拷贝，比直接new一个对象性能上提升了许多。
>
> 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用(例如恢复到历史某一状态)，可辅助实现撤销操作。


---

## 基础

---

### 设计模式的定义

设计模式：是众多软件开发人员经过长时间的试错和应用总结出来的，解决特定问题的一系列方案。

### 策略模式

视频讲解：[改善丑陋的代码 —— 并列 if-else 语句优化 (策略模式)](https://www.bilibili.com/video/BV11Q4y1a7ig)

策略模式：定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。

策略模式通常包含以下角色：

> 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
>
> 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
>
> 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

### 适配器模式

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

适配器模式包含以下主要角色：

> 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
>
> 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
>
> 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

### 单例模式

单例模式：属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 状态模式

状态模式：对有状态的对象，把复杂的 “判断逻辑” 提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

状态模式包含以下主要角色：

> 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
>
> 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
>
> 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。

### 观察者模式

观察者模式：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布 - 订阅模式、模型 - 视图模式，它是对象行为型模式。

观察者模式的主要角色如下：

> 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
>
> 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
>
> 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
>
> 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

### 建造者模式

建造者模式：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

建造者模式的主要角色如下:

> 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
>
> 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult ()。
>
> 具体建造者 (Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
>
> 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

### 装饰器模式

装饰器模式：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

装饰器模式主要包含以下角色：

> 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
>
> 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
>
> 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
>
> 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。







---



---

参考链接：

- [设计模式二三事](https://mp.weixin.qq.com/s/H2toewJKEwq1mXme_iMWkA)
- [行为型模式之策略模式解析，策略模式的使用场景和优缺点总结](https://www.jianshu.com/p/1df62fb687b4)
- [【设计模式】观察者模式](https://zhuanlan.zhihu.com/p/465018459)
- [看完起飞的装饰者模式](https://zhuanlan.zhihu.com/p/466905489)
- [大厂都在使用的责任链模式](https://zhuanlan.zhihu.com/p/466598525)
- [原型模式](https://www.jianshu.com/p/f42ab8785982)
- []()
- []()

---

