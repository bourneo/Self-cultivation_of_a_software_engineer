@startmindmap

+[#OrangeRed] Redis

++[#yellow] 数据类型

+++[#Pink] 五大类型
++++[#MediumSpringGreen] String / 字符串
+++++[#LightGreen]_ 分布式 Session
+++++[#GhostWhite]_ 分布式锁
+++++[#GhostWhite]_ 访问量统计

++++[#AliceBlue] List / 队列
+++++[#GhostWhite]_ 时间轴列表
+++++[#GhostWhite]_ 最新新闻

++++[#AliceBlue] Set / 集合
+++++[#GhostWhite]_ 好友推荐
+++++[#GhostWhite]_ 好友关系
+++++[#GhostWhite]_ 点赞

++++[#AliceBlue] Hash / 哈希

++++[#MediumSpringGreen] ZSet / 有序集合
+++++[#GhostWhite]_ 排行榜
+++++[#LightGreen] Skip List / 跳表
+++++[#LightGreen] Zip List / 压缩表


++[#yellow] 常见问题

+++[#Pink] 特性
++++[#MediumSpringGreen] Redis 为什么这么快
+++++[#MediumSpringGreen]_ 内存没有磁盘 IO 开销
+++++[#MediumSpringGreen]_ 单线程，没有锁竞争开销，不需要考虑线程安全问题
+++++[#MediumSpringGreen]_ 数据结构的底层优化，比如编码、跳表、压缩表
+++++[#MediumSpringGreen]_ IO 多路复用，实现零拷贝

++++[#AliceBlue] 为什么使用单线程
+++++[#AliceBlue]_ 单线程，没有锁竞争开销，不需要考虑线程安全问题
+++++[#AliceBlue]_ 同时，单线程不能完全发挥多核 CPU 的性能

+++[#Pink] 三剑客
++++[#AliceBlue] 缓存雪崩
+++++[#AliceBlue]_ 同时大面积失效
++++[#MediumSpringGreen] 缓存击穿
+++++[#MediumSpringGreen]_ 热点 key 失效
++++[#AliceBlue] 缓存穿透
+++++[#AliceBlue]_ 同时大量无效的 key（恶意请求）

+++[#Pink] key
++++[#MediumSpringGreen] 过期 key 的清理策略
+++++[#MediumSpringGreen]_ 被动删除，访问时顺便删除
+++++[#MediumSpringGreen]_ 主动删除，定时遍历清理
+++++[#MediumSpringGreen]_ 内存不够时清理（设置的最大内存）

++++[#MediumSpringGreen] 热 key 问题
+++++[#MediumSpringGreen]_ 利用二级缓存（ehcache）
+++++[#MediumSpringGreen]_ 备份热 key（多台分流）

++++[#MediumSpringGreen] 大 key 问题
+++++[#MediumSpringGreen]_ 删除大 key（如果不是热 key）
+++++[#MediumSpringGreen]_ 压缩和拆分 key（集合类型可以分片）

++++[#AliceBlue] 内存不够用的优化
+++++[#MediumSpringGreen]_ 有条件先增加内存
+++++[#MediumSpringGreen]_ 内存淘汰策略，删除过期数据，再使用 LRU 算法进行淘汰，酌情使用 LFU 算法
+++++[#MediumSpringGreen]_ 转码压缩


++[#yellow] ACID

+++[#Pink] ACID 属性
++++[#MediumSpringGreen] Atomicity / 原子性
+++++[#AliceBlue]_ 不支持，需要 lua 脚本实现
+++++[#AliceBlue]_ 传统事务比较复杂，Redis 追求简单高效
++++[#AliceBlue] Consistency / 一致性
+++++[#AliceBlue]_ 支持，数据和命令都符合要求
++++[#AliceBlue] Isolation / 隔离性
+++++[#AliceBlue]_ 支持，命令独立操作
++++[#MediumSpringGreen] Durability / 持久性
+++++[#AliceBlue]_ 开启持久化之后才支持


+++[#Pink] 持久性
++++[#MediumSpringGreen] 如何实现数据不丢失的（持久化）
+++++[#LightGreen] AOF 日志（Append Only File）
++++++[#AliceBlue]_ 文件追加方式，数据完整，但是需要把命令全部重写执行一遍
+++++[#LightGreen] RDB 快照（Redis DataBase）
++++++[#AliceBlue]_ 可快速恢复，数据可能不完整
+++++[#LightGreen] 混合持久化方式
++++++[#AliceBlue]_ 集成了 RDB 和 AOF 的优点


++[#yellow] 集群

+++[#Pink] 高可用
++++[#AliceBlue] 主从复制
+++++[#AliceBlue]_ 从一台主服务器同步数据到多台伺服务器
++++[#AliceBlue] 哨兵模式
+++++[#AliceBlue]_ 监控主从服务器，可以自动容灾恢复
++++[#MediumSpringGreen] Redis Cluster
+++++[#AliceBlue]_ 去中心化，数据分布在不同的服务器
+++++[#AliceBlue]_ 采用类一致性哈希算法实现存储节点选择

++++[#MediumSpringGreen] 主从复制原理（五）
+++++[#LightGreen]_ 从节点发出同步请求
+++++[#LightGreen]_ 主节点后台生成快照（第一次同步会触发全量）
+++++[#LightGreen]_ 主节点将新命令缓存在内存
+++++[#LightGreen]_ 主节点把快照发送给从节点，从节点写入磁盘后加载到内存
+++++[#LightGreen]_ 主节点把缓存的新命令发给从节点，从节点同步快照中缺失的数据


++[#yellow] 其他

+++[#Pink] 分布式锁

++++[#MediumSpringGreen] CAP
+++++[#LightGreen] Consistency / 一致性
+++++[#GhostWhite] Availability / 可用性
+++++[#LightGreen] Partition Tolerance / 分区容错性

++++[#AliceBlue] Redis 实现
+++++[#LightGreen] 使用 redisson

+++[#Pink] 集成 SpringBoot
++++[#AliceBlue] 依赖 spring-boot-starter-data-redis
++++[#AliceBlue] 配置 RedisTemplate

+++[#Pink] 和 MySQL 的一致性问题
++++[#LightGreen] 延迟双删


@endmindmap