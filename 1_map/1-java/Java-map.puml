@startmindmap

+[#OrangeRed] Map

++[#yellow] 2

+++[#Pink] 常用实现

++++[#MediumSpringGreen] HashMap

+++++[#LightGreen] 数据结构
++++++[#Aquamarine] 数组
+++++++[#Aquamarine]_ 初始值为 16
++++++[#Aquamarine] 单向链表
+++++++[#Aquamarine]_ 头节点是数组元素
++++++[#Aquamarine] 红黑树
+++++++[#Aquamarine]_ 数组长度大于 64，链表长度大于等于 8 时转化

+++++[#LightGreen] JDK7 和 JDK8
++++++[#Aquamarine] JDK8
+++++++[#Aquamarine]_ 数组、链表 / 红黑树
+++++++[#Aquamarine]_ 使用的尾插法，扩容后位置与原链表相同
++++++[#Aquamarine] JDK7
+++++++[#Aquamarine]_ 数组、链表
+++++++[#Aquamarine]_ 使用的是头插入法，扩容后与原位置相反 (resize会导致环形链表)


++++[#MediumSpringGreen] ConcurrentHashMap
+++++[#MediumSpringGreen]_ 在 HashMap 的基础上，加入分段锁，解决线程安全和性能问题

++++[#MediumSpringGreen] TreeMap
+++++[#LightGreen] 通过红黑树（R-B tree）实现


+++[#Pink] 常见问题

++++[#MediumSpringGreen] HashMap 的 Hash 冲突

+++++[#LightGreen] 原因
++++++[#Aquamarine]_ Hash 算法
++++++[#Aquamarine]_ Hash 表
++++++[#Aquamarine]_ Hash 算法对不同的数据，输出相同的散列值，导致 Hash 表中 key 冲突

+++++[#LightGreen] 解决
++++++[#Aquamarine] 开放定值寻址，线性探测法
++++++[#Aquamarine] 链式寻址：加单向链表
++++++[#Aquamarine] 再 Hash 法：加 Hash 函数，直到 key 不再冲突
++++++[#Aquamarine] 公共溢出区：分基本表和溢出表

+++++[#LightGreen] HashMap
++++++[#Aquamarine]_ 通过红黑树和链式寻址法解决冲突



++[#yellow] 2

+++[#Pink] 3

++++[#MediumSpringGreen] 4
+++++[#LightGreen] 5
++++++[#Aquamarine] 6
+++++++[#Aquamarine]_ 7


@endmindmap