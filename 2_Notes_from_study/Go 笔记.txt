		
Go 笔记
	
一、介绍：
	
	特点：
		Go 也叫 Golang；
			按照 Rob Pike 说法，语言叫做 Go，Golang 只是官方网站的网址；
		是开源的编译型的静态语言，源代码会编译为二进制机器码；
		支持静态链接，Go 代码可以静态链接为一个大的二进制文件；
		Go 使得高可用性和可扩展性的 Web 应用的开发变得简便容易；
			Go 的定位是系统编程语言，只是对 Web 开发支持较好。
		
	工作区：
		Go 源文件都应该放置在工作区里的 src 目录下。
		
	基本命令：
		run：后面加 Go 格式的文件名，编译运行文件中的代码；
		install：后面加包名，创建一个同包名的二进制文件；
		
	文件结构：
		例如：
			package main
			import "fmt"
			func main() {  
				fmt.Println("Hello World")
			}
		package：每一个 Go 文件都应该在开头进行 package name 的声明；
			只有可执行程序的包名应当为 main：package main。
		import ""：引入了外部的包，多个包可以用圆括号括起来。
		func main()：main 是一个特殊的函数，是程序的入口，main 函数必须放置在 main 包中。
			
	目录结构：
		src：源码文件夹；
		bin：二进制文件。
		
二、基础：

	变量：
		变量：指定了某存储单元（Memory Location）的名称，
			该存储单元会存储特定类型的值。
		
		声明单个变量：
			语法：var name type
				例如：
					func main() {
						var age int // 变量声明
					}
			如果变量未被赋值，Go 会自动地将其初始化，
				赋值该变量类型的零值（Zero Value）。
		
		声明变量并初始化：
			语法：var name type = initialvalue
				例如：
					func main() {
						var age int = 29 // 声明变量并初始化
					}
		
		类型推断（Type Inference）：
			如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。
				如果变量有初始值，就可以在变量声明中省略 type。
			语法：var name = initialvalue
				Go 能够根据初始值推断变量的类型。
				例如：
					func main() {
						var age = 29 // 可以推断类型
					}
		
		声明多个变量：
			语法：var name1, name2 type = initialvalue1, initialvalue2
				例如：
					func main() {
						var width, height int = 100, 50 // 声明多个变量
					}
			在一个语句中声明不同类型的变量：
				语法：
					var (  
						name1 = initialvalue1,
						name2 = initialvalue2
					)
				例如：
					func main() {
						var (
							name   = "naveen"
							age    = 29
							height int
						)
					}
		
		简短声明：
			Go 也支持一种声明变量的简洁形式，称为简短声明（Short Hand Declaration），
				该声明使用了 := 操作符。
			语法：name := initialvalue
				例如：
					func main() {  
						name, age := "naveen", 29 // 简短声明
					}
			要求：
				:= 操作符左边的所有变量都有初始值。
					例如：
						func main() {  
							name, age := "naveen" //error
						}
				:= 操作符的左边至少有一个变量是尚未声明的。
					例如：
						func main() {
							a, b := 20, 30 // 声明变量a和b
							b, c := 40, 50 // b已经声明，但c尚未声明
							b, c = 80, 90 // 给已经声明的变量b和c赋新值
						}
					如果:= 操作符的左边没有尚未声明的变量，
						会抛出 no new variables on left side of := 的错误。
						例如：
							func main() {  
								a, b := 20, 30 // 声明a和b
								a, b := 40, 50 // 错误，没有尚未声明的变量
							}
			变量也可以在运行时进行赋值；
				例如：
					func main() {  
						a, b := 145.8, 543.8
						c := math.Min(a, b)
						fmt.Println("minimum value is ", c)
					}
			Go 是强类型（Strongly Typed）语言，
				不允许某一类型的变量赋值为其他类型的值。
					例如：
						func main() {  
							age := 29      // age是int类型
							age = "naveen" // 错误，尝试赋值一个字符串给int类型变量
						}
		
	类型：
		基本类型：
			bool (布尔型)；
				例如：
					func main() {  
						a := true
						b := false
						c := a && b
						d := a || b
					}
			
			数字类型：
				int8, int16, int32, int64, int (有符号整型)：
					通常应该使用 int 表示整型；
					大小：32 位系统下是 32 位，64 位系统下是 64 位；
					范围：32 位系统下是 -2147483648～2147483647，
						64 位系统是 -9223372036854775808～9223372036854775807。
					例如：
						func main() {  
							var a int = 89
							b := 95
							// a 的类型和大小
							fmt.Printf("type of a is %T, size of a is %d", a, unsafe.Sizeof(a)) 
							// b 的类型和大小
							fmt.Printf("\ntype of b is %T, size of b is %d", b, unsafe.Sizeof(b)) 
						}
				uint8, uint16, uint32, uint64, uint (无符号整型)：
					范围：32 位系统下是 0～4294967295，
						64 位系统是 0～18446744073709551615。
				float32, float64 (浮点型)：
					float64 是浮点数的默认类型。
					例如：
						func main() {  
							a, b := 5.67, 8.97
							fmt.Printf("type of a %T b %T\n", a, b)
							sum := a + b
							diff := a - b
							fmt.Println("sum", sum, "diff", diff)
						}
				complex64, complex128 (复数类型)：
					实部和虚部都是 float32 或者 float64 类型的的复数；
					内建函数 complex 用于创建一个包含实部和虚部的复数：
						func complex(r, i FloatType) ComplexType
					使用简短语法来创建复数：
						c := 6 + 7i
				byte (字节)：
					是 uint8 的别名。
				rune (如尼)：
					是 int32 的别名。
			
			string (字符串)：
				Go 中，字符串是字节的集合。
		
		类型转换：
			Go 有着非常严格的强类型特征，没有自动类型提升或类型转换。
				例如：
					func main() {  
						i := 55      //int
						j := 67.8    //float64
						sum := i + j //不允许 int + float64
					}
			类型强行转换：
				T(v)。
				例如：
					func main() {  
						i := 55      //int
						j := 67.8    //float64
						sum := i + int(j) //j is converted to int
					}
			把一个变量赋值给另一个不同类型的变量，需要显式的类型转换。
				例如：
					func main() {  
						i := 10
						var j float64 = float64(i) // 若没有显式转换，该语句会报错
					}
		
	常量：
		定义：固定的值。
			关键字 const 被用于表示常量；
				例如：
					func main() {  
						const a = 55；
						var b string = "I love Go"
					}
			常量不能再重新赋值为其他的值。
				例如：
					func main() {  
						const a = 55 // 允许
						a = 89       // 不允许重新赋值
					}
			常量的值会在编译的时候确定，所以不能将函数的返回值赋值给常量。
				例如：
					func main() {  
						fmt.Println("Hello, playground")
						var a = math.Sqrt(4)   // 允许
						const b = math.Sqrt(4) // 不允许
					}
		
		字符串常量：
			双引号中的任何值都是 Go 中的字符串常量。
				例如：
					const hello = "Hello World"
				像 Hello World 这样的字符串常量是没有任何类型的。
			Go 是一门强类型语言，所有的变量必须有明确的类型。
				无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。
				在声明中 var name = "Sam" ， name 需要一个类型，它从字符串常量 Sam 的默认类型中获取。
			创建一个带类型的常量：
				const typedhello string = "Hello World"
			创建一个新类型 myString：
				type myString string
					myString 是 string 的别名。
				即使我们知道这个 myString 是 string 类型的别名。
					Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。
			Go 是一个强类型的语言，在分配过程中混合类型是不允许的。
				例如：
					func main() {  
						var defaultName = "Sam" // 允许
						type myString string
						var customName myString = "Sam" // 允许
						customName = defaultName // 不允许
					}
				因此将 defaultName 赋值给 customName 是不允许的，编译器会抛出一个错误。
		
		布尔常量：
			布尔常量和字符串常量没有什么不同。
			他们是两个无类型的常量 true 和 false。
			字符串常量的规则适用于布尔常量。
				例如：
					func main() {  
						const trueConst = true
						type myBool bool
						var defaultBool = trueConst // 允许
						var customBool myBool = trueConst // 允许
						defaultBool = customBool // 不允许
					}
		
		数字常量：
			数字常量包含整数、浮点数和复数的常量。数字常量中有一些微妙之处。
			const a = 5
			上面的常量 a 是没有类型的；
			常量的默认类型可以被认为是根据上下文在运行中生成的。
				例如：
					func main() {  
						const a = 5
						var intVar int = a
						var int32Var int32 = a
						var float64Var float64 = a
						var complex64Var complex64 = a
						fmt.Println("intVar",intVar, "\nint32Var", int32Var, "\nfloat64Var", float64Var, "\ncomplex64Var",complex64Var)
					}
		
		数字表达式：
			数字常量可以在表达式中自由混合和匹配，
			只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。
				例如：
					func main() {  
						var a = 5.9/8
						fmt.Printf("a's type %T value %v",a, a)
					}
				5.9/8 是允许的，因为两个都是数字常量。
				除法的结果是 0.7375 是一个浮点型，所以 var a = 5.9/8 中，a 的类型是浮点型。
		
	函数：
		函数（Function）：
			是一块执行特定任务的代码。
			一个函数是在输入源基础上，通过执行一系列的算法，生成预期的输出。
			
		函数声明：
			语法：
				func functionname(parametername type) returntype {  
					// 函数体（具体实现的功能）
				}
			解析：
				func：函数的声明以关键词 func 开始，
				函数名：后面紧跟自定义的函数名 functionname；
				参数列表：函数的参数列表定义在 ( 和 ) 之间，
					参数：声明一个参数的语法采用 参数名 参数类型 的方式，
						任意多个参数采用类似 (parameter1 type, parameter2 type)，
						即(参数1 参数1的类型,参数2 参数2的类型)的形式指定。
				返回值类型：定义在之后的 returntype 处。
				函数体：之后包含在 { 和 } 之间的代码。
			函数中的参数列表和返回值并非是必须的。
				例如：
					func functionname() {  
						// 译注: 表示这个函数不需要输入参数，且没有返回值
					}
					
		函数示例：
			输入参数是单件商品的价格和商品的个数，两者的乘积为商品总价，作为函数的输出值。
				func calculateBill(price int, no int) int {  
					var totalPrice = price * no // 商品总价 = 商品单价 * 数量
					return totalPrice // 返回总价
				}
			如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。
				例如：
					func calculateBill(price, no int) int {  
						var totalPrice = price * no
						return totalPrice
					}
				price int, no int 可以简写为 price, no int。
				
		函数调用：
			语法：functionname(parameters)。
				例如：
					calculateBill(10, 5)
					
		多返回值：
			Go 语言支持一个函数可以有多个返回值。
			如果一个函数有多个返回值，那么这些返回值必须用圆括号括起来。
				例如：
					func rectProps(length, width float64)(float64, float64) {  
						var area = length * width
						var perimeter = (length + width) * 2
						return area, perimeter
					}
					
		命名返回值：
			从函数中可以返回一个命名值。一旦命名了返回值，可以认为这些值在函数第一行就被声明为变量了。
				例如：
					func rectProps(length, width float64)(area, perimeter float64) {  
						area = length * width
						perimeter = (length + width) * 2
						return // 不需要明确指定返回值，默认返回 area, perimeter 的值
					}
				上面函数中的 return 语句没有显式返回任何值。
					由于 area 和 perimeter 在函数声明中指定为返回值, 
					因此当遇到 return 语句时, 它们将自动从函数返回。
					
		空白符：
			_ 在 Go 中被用作空白符，可以用作表示任何类型的任何值。
				例如：
					func main() {  
						area, _ := rectProps(10.8, 5.6) // 返回值周长被丢弃
						fmt.Printf("Area %f ", area)
					}
				在 area, _ := rectProps(10.8, 5.6) 这一行中，_ 用来跳过不要的计算结果。
				
		常用函数：
			Printf()：
				格式化打印；
				格式说明符（Format Specifier）：
					%T 可以打印变量的类型；
					%d 可以打印数值型变量的值；
					%.2f 可以将浮点数截断到小数点两位。
			Sizeof()：
				变量的字节大小；
				unsafe 包提供的函数，该函数接收变量并返回它的字节大小。
				unsafe 包应该小心使用，因为使用 unsafe 包可能会带来可移植性问题。
		
	包：
		包（Package）：
			用于组织 Go 源代码，提供了更好的可重用性与可读性。
			
		main 函数和 main 包：
			所有可执行的 Go 程序都必须包含一个 main 函数；
				这个函数是程序运行的入口；
				main 函数应该放置于 main 包中。
			package packagename 这行代码指定了某一源文件属于一个包；
				应该放在每一个源文件的第一行。
				例如：
					// geometry.go
					package main 
					import "fmt"
					func main() {  
						fmt.Println("Geometrical shape properties")
					}
				package main 这一行指定该文件属于 main 包。
				import "packagename" 语句用于导入一个已存在的包。
					
		创建自定义的包：
			属于某一个包的源文件都应该放置于一个单独命名的文件夹里。
				按照 Go 的惯例，应该用包名命名该文件夹。
				例如：
					// rectprops.go
					package rectangle
					import "math"
					func Area(len, wid float64) float64 {  
						area := len * wid
						return area
					}
					func Diagonal(len, wid float64) float64 {  
						diagonal := math.Sqrt((len * len) + (wid * wid))
						return diagonal
					}
				注意：函数 Area 和 Diagonal 都是以大写字母开头的。
				
		导入自定义包：
			为了使用自定义包，我们必须要先导入它。导入自定义包的语法为 import path。
			我们必须指定自定义包相对于工作区内 src 文件夹的相对路径。
				例如：
					// geometry.go
					package main 
					import (  
						"fmt"
						"geometry/rectangle" // 导入自定义包
					)
					func main() {  
						var rectLen, rectWidth float64 = 6, 7
						/*Area function of rectangle package used*/
						fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
						/*Diagonal function of rectangle package used*/
						fmt.Printf("diagonal of the rectangle %.2f ", rectangle.Diagonal(rectLen, rectWidth))
					}
					
		导出名字（Exported Names）：
			在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。
				其它包只能访问被导出的函数和变量。
				如果想在包外访问一个函数，它应该首字母大写。
					
		init 函数：
			所有包都可以包含一个 init 函数。
				init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。
				init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。
			包的初始化顺序：
				首先初始化包级别（Package Level）的变量；
				紧接着调用 init 函数。
					包可以有多个 init 函数（在一个文件或分布于多个文件中），
					它们按照编译器解析它们的顺序进行调用。
			项目级别的初始化顺序：
				如果一个包导入了另一个包，会先初始化被导入的包。
				尽管一个包可能会被导入多次，但是它只会被初始化一次。
					
		使用空白标识符（Blank Identifier）：	
			导入了包，却不在代码中使用它，这在 Go 中是非法的。
				当这么做时，编译器是会报错的。
				原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。
					例如：
						package main 
						import (
							"geometry/rectangle" // 导入自定的包
						)
						func main() {
						}
					上面的程序将会抛出错误 geometry.go:6: imported and not used: "geometry/rectangle"。
			
			在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。
				遇到这种情况就可以使用空白标识符 _。
					例如：
						package main
						import (  
							"geometry/rectangle" 
						)
						var _ = rectangle.Area // 错误屏蔽器
						func main() {
						}
				我们应该了解错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们。
				建议在 import 语句下面的包级别范围中写上错误屏蔽器。
					
			有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。
				例如，我们或许需要确保调用了 rectangle 包的 init 函数，而不需要在代码中使用它。
				这种情况也可以使用空白标识符。
					例如：
						package main 
						import (
							_ "geometry/rectangle" 
						)
						func main() {
						}
					
	if-else 语句：
		if 条件语句：
			语法：
				if condition {  
				}
		
		if-else 语句：
			有可选的 else if 和 else 部分：
			语法：
				if condition {  
				} else if condition {
				} else {
					}
			注意：
				if-else 语句之间可以有任意数量的 else if。
				条件判断顺序是从上到下。
				如果 if 或 else if 条件判断的结果为真，则执行相应的代码块。
				如果没有条件为真，则 else 代码块被执行。
			例如：
				func main() {  
					num := 10
					if num % 2 == 0 { //checks if number is even
						fmt.Println("the number is even") 
					}  else {
						fmt.Println("the number is odd")
					}
				}
		
		if 还有另外一种形式，它包含一个 statement 可选语句部分，该组件在条件判断之前运行。
			语法：
				if statement; condition {  
				}
			例如：
				func main() {  
					if num := 10; num % 2 == 0 { //checks if number is even
						fmt.Println(num,"is even") 
					}  else {
						fmt.Println(num,"is odd")
					}
				}
				num 在 if 语句中进行初始化，num 只能从 if 和 else 中访问。
				也就是说 num 的范围仅限于 if else 代码块。
				如果我们试图从其他外部的 if 或者 else 访问 num,编译器会不通过。
					
		一个注意点：
			else 语句应该在 if 语句的大括号 } 之后的同一行中。
			如果不是，编译器会不通过。
				例如：
					func main() {  
						num := 10
						if num % 2 == 0 { //checks if number is even
							fmt.Println("the number is even") 
						}  
						else {
							fmt.Println("the number is odd")
						}
					}
					编译器会输出错误：main.go:12:5: syntax error: unexpected else, expecting }
			因为 Go 语言的分号是自动插入：
				如果 } 是该行的最终标记， } 之后会被插入一个分号。
					
	循环：
		for：是 Go 语言唯一的循环语句。
			语法：
				for initialisation; condition; post {  
				}
			执行顺序：
				初始化语句只执行一次。
				循环初始化后，将检查循环条件。
				如果条件的计算结果为 true ，则 {} 内的循环体将执行，接着执行 post 语句。
				post 语句将在每次成功循环迭代后执行。
				在执行 post 语句后，条件将被再次检查。
					如果为 true, 则循环将继续执行，否则 for 循环将终止。
				这是典型的 for 循环三个表达式：
					第一个为初始化表达式或赋值语句；
					第二个为循环条件判定表达式；
					第三个为循环变量修正表达式，即此处的 post。
				这三个组成部分，即初始化，条件和 post 都是可选的。
			例如：	
				func main() {  
					for i := 1; i <= 10; i++ {
						fmt.Printf(" %d",i)
					}
				}
		
		break：		
			break 语句，用于在完成正常执行之前突然终止 for 循环，
				之后程序将会在 for 循环下一行代码开始执行。
			例如：
				func main() {  
					for i := 1; i <= 10; i++ {
						if i > 5 {
							break //loop is terminated if i > 5
						}
						fmt.Printf("%d ", i)
					}
					fmt.Printf("\nline after for loop")
				}
		
		continue：
			continue 语句，用来跳出 for 循环中当前循环。
				在 continue 语句后的所有的 for 循环语句都不会在本次循环中执行。
				循环体会在一下次循环中继续执行。	
			例如：
				func main() {  
					for i := 1; i <= 10; i++ {
						if i%2 == 0 {
							continue
						}
						fmt.Printf("%d ", i)
					}
				}
					
		for 循环的多样性：
			for 循环的三部分，初始化语句、条件语句、post 语句都是可选的。
				例如：
					func main() {  
						i := 0
						for ;i <= 10; { // initialisation and post are omitted
							fmt.Printf("%d ", i)
							i += 2
						}
					}
			上面 for 循环中的分号也可以省略。
				例如：
					func main() {  
						i := 0
						for i <= 10 { //semicolons are ommitted and only condition is present
							fmt.Printf("%d ", i)
							i += 2
						}
					}
			在 for 循环中可以声明和操作多个变量。	
				例如：
					func main() {  
						for no, i := 10, 1; i <= 10 && no <= 19; i, no = i+1, no+1 { //multiple initialisation and increment
							fmt.Printf("%d * %d = %d\n", no, i, no*i)
						}

					}
					
		无限循环：
			语法：
				for {  
				}
			例如：
				func main() {  
					for {
						fmt.Println("Hello World")
					}
				}
			这里还有一个 range 结构，它可以被用来在 for 循环中操作数组对象。
					
	switch 语句：	
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					