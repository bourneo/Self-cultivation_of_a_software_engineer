
集合


集合核心

	是什么：
		对数据结构的封装；
	为什么使用：
		操作方便；
	基本原理：
		
	怎么使用：
		List：
			LinkedList
			ArrayList
			Stack
		Set：
			HashSet
			TreeSet
		Map：
			HashMap
			TreeMap

集合

	集合框架
	
		集合框架：数据结构的实现和封装。
		
		常用集合类：
			1) Set (集) ：不照特定方式进行排序；不允许重复。
			2) List (列表) ：按照索引位置排序；允许元素重复。
			3) Map (映射) ：集合中每一个元素都包含一对 key 和 value 对象，key 不能重复，值可以重复。

		List 接口

			ArrayList 类

			LinkedList 类

			Vector 类

			Stack 类

		Set 接口

			HashSet 类

				equals 方法和 hashCode 方法：
				HashSet 中判断两个对象是否相同 (两者缺一不可) ：
					1) 两个对象的 equals 比较相等，返回 true，说明对象相同；
					2) 两个对象的 hashCode 方法返回值相等。	
						对象的 hashCode 值决定了在哈希表中存储的位置。
						往 HashSet 集合中添加新的对象的时候，先会判断该对象和集合对象中的 hashCode 值。
						1) 不等：直接把该新的对象存储到 hashCode 指定的位置；
						2) 相等：再继续判断新对象和集合对象中的 equals 做比较：
							a) hashCode 相同，equals 为 true：则视为同一个对象，并且不保存在哈希表中。
							b) hashCode 相同，equals 为 false：非常麻烦，存储在之前对象同槽位的链表上。
								 (拒绝，操作麻烦) 
						如果两个元素通过 equals 方法比较返回 true，但它们的 hashCode 值不等，
						HashSet 会把两个元素存储在不同的位置。

			TreeSet 类

			LinkedHashSet 类

				Comparable 接口 (自然排序)
					comparableTo (Object o) 方法

				Comparator 接口 (定制排序)
					compare (Object o1, Object o2) 方法


		Map 接口

			HashMap
			
				HashMap 操作：
					get			
					put
					putAll
					remove
				EntrySet
					getKey
					getValue
				KeySet
					get

			LinkedHashMap

			TreeMap


		Arrays 类
		
		Collections 类
			集合帮助类

		foreach 和 Iterator
			foreach：
				for (类型 变量：数组名 / Iterator 的实例) { //TODO }；
				1) foreach 可以操作数组：底层依然采用 for 循环 + 索引来获取数组元素。
				2) foreach 可以操作 Iterator 的实例：底层其实采用的 Iterator 迭代器。	
			Iterator：
				迭代器对象；可以把集合的元素一个一个遍历出来。
				需要边迭代集合元素边删除制定的元素时，只能用迭代器；而且只能使用迭代器的 remove 方法。
					因为迭代的时候，当前线程 A 会创建新的线程 B，A 负责迭代，B 负责删除。
					B 每次都会检查和 A 元素个数是否相同，不同就报错：ConcurrentModificationException。
					解决并发异常：不要使用集合对象的删除方法；使用 Iterator 中的 remove 方法，来保证两个线程的同步。

		泛型类
			GenericType
			泛型其实也是语法糖；编译后会被擦除；
			泛型方法：在方法上声明泛型。


	Java 提供了数种持有对象的方式，包括语言内置的 Array，
	还有就是 utilities 中提供的容器类 (container classes)，又称群集类 (collection classes)。

	集合在 java 中非常重要，在讨论之前，先来看几个面试中的经典问题。
		1. Collection 和 Collections 的区别。
			Collections 是个 java.util 下的类，它包含有各种有关集合操作的静态方法。
			Collection 是个 java.util 下的接口，它是各种集合结构的父接口 		
		2. List, Set, Map 是否继承自 Collection 接口。
			List，Set 是 Map 不是。	
		3. ArrayList 和 Vector 的区别。
			同步性：Vector 是线程安全的，也就是说是同步的，而 ArrayList 是线程序不安全的，不是同步的 
			数据增长：当需要增长时,Vector 默认增长为原来一培，而 ArrayList 却是原来的一半 	
		4. HashMap 和 Hashtable 的区别。
			历史原因：Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口的一个实现 
			同步性：Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的 
			值：只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value			


	集合 Collection 接口 
		Collection 是任何对象组，元素各自独立，通常拥有相同的套用规则。Set List 由它派生。
		基本操作 
			增加元素 add(Object obj); addAll(Collection c); 
			删除元素 remove(Object obj); removeAll(Collection c); 
			求交集 retainAll(Collection c); 
			删除元素 remove(Object obj); removeAll(Collection c); 
			求交集 retainAll(Collection c); 
		访问/遍历集合元素的好办法是使用 Iterator 接口 (迭代器用于取代 Enumeration) 
			Public interface Iterator{ 
				Public Boolean hasNext(}; 
				Public Object next(}; 
				Public void remove(}; 
			}
	集 set 
		没有重复项目的集合 
		有三种特定类型的集可用 
			HashSet：基于散列表的集，加进散列表的元素要实现 hashCode() 方法 
			LinkedHashSet：对集迭代时，按增加顺序返回元素 
			TreeSet：基于 (平衡) 树的数据结构 
	清单 List 
		位置性集合。加进清单的元素可以加在清单中特定位置或加到末尾 
		有两个特定版本 
			ArrayList(数组表)：类似于 Vector，都用于缩放数组维护集合。区别：
				同步性：Vector 是线程安全的，也就是说是同步的，而 ArrayList 是线程序不安全的，不是同步的 
				数据增长：当需要增长时,Vector 默认增长为原来一培，而 ArrayList 却是原来的一半 
			LinkedList(链表)：是双向链表，每个节点都有两个指针指向上一节点和下一节点。
				用在 FIFO，用 addList() 加入元素 removeFirst() 删除元素
				用在 FILO, 用 addFirst()/removeLast() 
				ListIterator 提供双向遍历 next() previous()，可删除、替换、增加元素 
	映射表 Map
		用于关键字/数值对，像个 Dictionary 
		处理 Map 的三种集合：
			关键字集 KeySet()
			数值集 value()
			项目集 enrySet()
		四个具体版本 
			HashMap：散列表的通用映射表 
				LinkedHashMap：扩展 HashMap，对返回集合迭代时，维护插入顺序 
				WeakHashMap：基于弱引用散列表的映射表，
					如果不保持映射表外的关键字的引用，则内存回收程序会回收它 
			TreeMap：基于平衡树的映射表 

	Collections 类，用于同步集合，还能改变集合只读方式的类 
		e.g.：
			Map mp=new HashMap();
			mp=Collections.synchronizedMap(mp); //生成线程安全的映射表 
			mp=Collections.unmodifiableMap(mp); //生成只读映射表 
		Comparable 自然顺序的排序类 Comparator 面向树的集合排序类 
	
	容器分类学 (Container taxonomy) 
	集合接口：Collection List Set Map Iterator ListIterator。
	抽象类：AbstractCollection AbstractList AbstractSet AbstractMap AbstractSequentiaList。
	
	老版本中的集合类型 
		Vector 类 
			Vector，就是向量。
			一种异构的混合体，可以动态增加容量。
			对它的操作简要如下 ：
				比如我们有一个 Vector：Vector myVec=new Vector(a_Array.length) 
				取得 vector 的长度：myVec.size(); 
				赋值：set(int position,Object obj) / setElementAt(Object obj, int position)：不支持动态增长 
					add(Object obj )/ addElement(Object obj) 在 Vector 末尾加入对象 
					e.g.：myVec.add(new a_Array[0]); 
				取出元素：get(int position) / getElement(int position) 
		Stack 类 
			是 Vector 的子类。
			就是数据结构里讲滥了的堆栈 (这个词可简称栈，不要混淆于 heap：堆) 。
			后进先出的存取方式。
				Stack() 构造空栈 
				Empty() 叛空 
				Search() 检查堆栈是否有元素 
				Peek() 取得栈顶元素 
				Pop() 弹栈 
				Push() 入栈 
		Enumeration 接口 
		Dictionary 类 
			字典。关键字/数值方式存取数据，如果映射没有此关键字，取回 null。
		Hashtable 类 
			是 Dictionary 结构的具体实现。

		
	Collection
		List
			LinkedList 非同步
			ArrayList 非同步，实现了可变大小的元素数组
			Vector 同步
			Stack
		Set 不允许有相同的元素
	Map
		HashTable 同步，实现一个 key--value 映射的哈希表
		HashMap 非同步，
		WeakHashMap 改进的 HashMap，实现了“弱引用”，如果一个 key 不被引用，则被 GC 回收



Iterator：
	如果在循环的过程中调用集合的 remove() 方法，就会导致循环出错，
		例如：
			for(int i=0;i<list.size();i++){
				list.remove(...);
			}
	循环过程中 list.size() 的大小变化了，就导致了错误。
	所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器 iterator 的 remove() 方法，
	因为它的 remove() 方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，
	例如，你不能连续两次调用它的 remove() 方法，调用之前至少有一次 next() 方法的调用。

	Iterator 支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。
	这样做的好处是可以避免 ConcurrentModifiedException，当打开 Iterator 迭代集合时，同时又在对集合进行修改。
	有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的 remove() 方法是个安全的做法。



“HashMap 实现 Map 接口，它允许任何类型的键对象”，这句话是有前提条件的。
	这需要查看 HashMap 底层源码，在计算 hashcode 的过程中会用到 equals () 和 hashCode () 这两个函数；
	所以键的对象类型必须遵守这两个函数的规则，保证键的不变性，即：
		1. 若两对象 equals，则它两 hashcode 一定相等；
		2. 若两对象不 equals，则它两 hashcode 有可能相等；
		3. 若两对象 hashcode 相等，则它两不一定 equals；
		4. 若两对象 hashcode 不相等，则它两一定 不 equals；
	
	HashMap 的底层是由数组加链表实现的，
		对于每一个 key 值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，
		因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序。
		最开始有 Hashtable，Hashtable 是不允许 key 和 value 的值为空的，
			但后来开发者认为有时候也会有 key 值为空的情况，因为可以允许 null 为空，
		通过查看 HashMap 的源代码就知道：if(key = null) {putForNullKey(value);};
		Map 底层都是用 key/value 键值对的形式存放的
	
	
	
	
	
	
	
	
	
	
	
	