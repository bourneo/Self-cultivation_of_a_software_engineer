
分布式事务


分布式事务解决方案：
	
	两种思路：
		
		CAP 理论: CAP(Consistency，Availability，Partition Tolerance)：
			一致性、可用性、分区容忍性；
			阐述了一个分布式系统的三个主要方面，只能同时择其二进行实现；
			常见的有 CP 系统，AP 系统。
		
		BASE 理论：(Basically avaliable，soft state，eventually consistent): 
			基本可达，柔性状态，事件持久；
			是分布式事务实现的一种理论标准。
		
	三种方式：
			
		2PC (Two Phase Commit)：两阶段提交；
			一种 CP 系统的典型实现；
			两阶段提交，常见的标准是 XA，JTA 等；
				例如 Oracle 的数据库支持 XA。
			
			XA 三阶段提交：
				XA 三阶段提交在两阶段提交的基础上增加了 CanCommit 阶段，并且引入了超时机制。
				一旦事物参与者迟迟没有接到协调者的 commit 请求，会自动进行本地 commit。
				这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。
			
		TCC (Try-Confirm-Cancle)：补偿型提交；
			尝试确认取消；
			一种基于补偿型事务的 AP 系统实现；
			逻辑模式类似于 XA 两阶段提交，但是实现方式是在代码层面来人为实现。
		
		
		异步确保型：
			消息事务和最终一致性的方案：
				异步确保型通过将一系列同步的事务操作变为基于消息执行的异步操作，
				避免了分布式事务中的同步阻塞操作的影响。
				这个方案真正实现了两个服务的解耦，解耦的关键就是异步消息和补偿性事务。
			支持事务的消息中间件 MQ 事务：
				利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。
				这个方式避免了像 XA 协议那样的性能问题。
		
		
		
		
		
		
		

微服务–分布式事务的实现方法及替代方案：

	概念澄清
	
		事务补偿机制: 
			在事务链中的任何一个正向事务操作，都必须存在一个完全符合回滚规则的可逆事务。
		CAP 理论: CAP(Consistency，Availability，Partition Tolerance)：
			阐述了一个分布式系统的三个主要方面，只能同时择其二进行实现；常见的有 CP 系统，AP 系统。
		幂等性: 
			简单的说，业务操作支持重试，不会产生不利影响；
			常见的实现方式: 为消息额外增加唯一 ID。
		BASE 理论：(Basically avaliable，soft state，eventually consistent): 
			是分布式事务实现的一种理论标准。

	柔性事务 vs 刚性事务

		刚性事务是指严格遵循 ACID 原则的事务，例如单机环境下的数据库事务。

		柔性事务是指遵循 BASE 理论的事务，通常用在分布式环境中，
		常见的实现方式有: 两阶段提交 (2PC)，TCC 补偿型提交，基于消息的异步确保型，最大努力通知型。

		通常对本地事务采用刚性事务，分布式事务使用柔性事务。

	最佳实践

		先上结论，再分别介绍分布式事务的各种实现方式。
		如果业务场景需要强一致性，那么尽量避免将它们放在不同服务中，也就是尽量使用本地事务，避免使用强一致性的分布式事务。
		如果业务场景能够接受最终一致性，那么最好是使用基于消息的最终一致性的方案 (异步确保型) 来解决。
		如果业务场景需要强一致性，并且只能够进行分布式服务部署，那么最好是使用 TCC 方案而不是 2PC 方案来解决。
		注意: 以下每种方案都有不同的适用场合，需要根据实际业务场景来选择。

	两阶段提交 (2PC)

		两阶段提交 (Two Phase Commit，2PC)，具有强一致性，是 CP 系统的一种典型实现。

		两阶段提交，常见的标准是 XA，JTA 等. 例如 Oracle 的数据库支持 XA。

		下图是两阶段提交的示意图:

			图的上半是两阶段提交成功的演示，下半是两阶段提交失败的演示；
			关于两阶段提交网上有很多经典的讲解，这里就不细说了，可以参考前面的链接。

		缺点：
			
			两阶段提交中的第二阶段，协调者需要等待所有参与者发出 yes 请求，
			或者一个参与者发出 no 请求后，才能执行提交或者中断操作；
			这会造成长时间同时锁住多个资源，造成性能瓶颈，如果参与者有一个耗时长的操作，性能损耗会更明显。
			实现复杂，不利于系统的扩展，不推荐。

	TCC (Try-Confirm-Cancle)
		TCC 是基于补偿型事务的 AP 系统的一种实现，具有最终一致性。
		TCC 流程：
			下面以客户购买商品时的付款操作为例进行讲解:
				Try: 
					完成所有的业务检查 (一致性), 预留必须业务资源 (准隔离性); 
					体现在本例中，就是确认客户账户余额足够支付 (一致性)，锁住客户账户，商户账户 (准隔离性)。
				Confirm: 
					使用 Try 阶段预留的业务资源执行业务 (业务操作必须是幂等的)，如果执行出现异常，要进行重试. 
					在这里就是执行客户账户扣款，商户账户入账操作。
				Cancle: 
					释放 Try 阶段预留的业务资源，在这里就是释放客户账户和商户账户的锁; 
					如果任一子业务在 Confirm 阶段有操作无法执行成功，会造成对业务活动管理器的响应超时，此时要对其他业务执行补偿性事务。
					如果补偿操作执行也出现异常，必须进行重试，
					若实在无法执行成功，则事务管理器必须能够感知到失败的操作，进行 log
					(用于事后人工进行补偿性事务操作或者交由中间件接管在之后进行补偿性事务操作)。
		优点：
			对比与前面提到的两阶段提交法，有两大优势:
				TCC 能够对分布式事务中的各个资源进行分别锁定，分别提交与释放，
				例如，假设有 AB 两个操作，假设 A 操作耗时短，那么 A 就能较快的完成自身的 try-confirm-cancel 流程，释放资源. 无需等待 B 操作；
				如果事后出现问题，追加执行补偿性事务即可。
				TCC 是绑定在各个子业务上的 (除了 cancle 中的全局回滚操作)，也就是各服务之间可以在一定程度上”异步并行”执行。
		注意事项：
			事务管理器 (协调器) 这个节点必须以带同步复制语义的高可用集群 (HAC) 方式部署。
			事务管理器 (协调器) 还需要使用多数派算法来避免集群发生脑裂问题。
		适用场景：
			严格一致性
			执行时间短
			实时性要求高
			举例: 红包，收付款业务。
		
	异步确保型
		
		通过将一系列同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响。
		这个方案真正实现了两个服务的解耦，解耦的关键就是异步消息和补偿性事务。

		这里以一个例子作为讲解:
			执行步骤如下:
				MQ 发送方发送远程事务消息到 MQ Server;
				MQ Server 给予响应，表明事务消息已成功到达 MQ Server。
				MQ 发送方 Commit 本地事务。
				若本地事务 Commit 成功，则通知 MQ Server 允许对应事务消息被消费; 若本地事务失败，则通知 MQ Server 对应事务消息应被丢弃。
				若 MQ 发送方超时未对 MQ Server 作出本地事务执行状态的反馈，那么需要 MQ Servfer 向 MQ 发送方主动回查事务状态，以决定事务消息是否能被消费。
				当得知本地事务执行成功时，MQ Server 允许 MQ 订阅方消费本条事务消息。
		需要额外说明的一点，就是事务消息投递到 MQ 订阅方后，并不一定能够成功执行，需要 MQ 订阅方主动给予消费反馈 (ack)
			如果 MQ 订阅方执行远程事务成功，则给予消费成功的 ack，那么 MQ Server 可以安全将事务消息移除;
			如果执行失败，MQ Server 需要对消息重新投递，直至消费成功。
		注意事项：
			消息中间件在系统中扮演一个重要的角色，所有的事务消息都需要通过它来传达，
			所以消息中间件也需要支持 HAC 来确保事务消息不丢失。
			根据业务逻辑的具体实现不同，还可能需要对消息中间件增加消息不重复，不乱序等其它要求。
		适用场景：
			执行周期较长
			实时性要求不高
		例如:
			跨行转账/汇款业务 (两个服务分别在不同的银行中)
			退货/退款业务
			财务，账单统计业务 (先发送到消息中间件，然后进行批量记账)
		
	最大努力通知型：
		这是分布式事务中要求最低的一种，也可以通过消息中间件实现，与前面异步确保型操作不同的一点是，
		在消息由 MQ Server 投递到消费者之后，允许在达到最大重试次数之后正常结束事务。

		适用场景：
			交易结果消息的通知等。
		
		小结
			不管是同步事务中的事务管理器 (协调者)，还是异步事务中使用的消息中间件，若要达到一致性保证，都需要使用带有同步复制语义的 HAC 提供的高可用和高可靠特性，这些都是以性能为代价的，无疑成为了 SOA 架构中的典型性能瓶颈之一
	
	
分布式事务 (DTS) 

	目前云计算、大数据、互联网领域的大部分系统都采用了 SOA、微服务化的架构。
	一个涉及端到端全链路的业务操作往往会由多个服务和数据库实例共同完成。
	因此，在一致性要求较高的业务场景中，如何保证多个服务之间 RPC 调用后的数据一致将成为关键点。

	一、分布式系统/SOA/微服务架构的特点：
		在大型分布式系统中要同时能够满足，分布式一致性 (Consistency)、可用性 (Availability) 和分区容忍性 (Partitiontolerance)，是不存在的。在大多数情况下只能满足其中的 2 项，而实现系统的最终一致性 (Base 理论)。

		(1) CAP 特点：
			a. 一致性 (Consistency):( 同样数据在分布式系统的各个节点上都是一致的)
			b. 可用性 (Availability):( 所有在分布式系统活跃的节点都能够处理操作且能响应查询)
			c. 分区容忍性 (Partition Tolerance) :(如果出现了网络故障、一部分节点无法通信，但是系统仍能够工作)

		(2) ACID 特点：
			
			a. 原子性 (Atomicity)
				一个事务 (transaction) 中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
				事务在执行过程中发生错误，会被回滚 (Rollback) 到事务开始前的状态，就像这个事务从来没有执行过一样。

			b. 一致性 (Consistency)
				事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。]
				如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。
				如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

			c. 隔离性 (Isolation)
				指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。
				由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
				事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，
				事务不会查看到中间状态的数据。

			d. 持久性 (Durability)
				指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。
				即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

	二、分布式事务的基本介绍
		分布式事务服务 (Distributed Transaction Service，DTS) ：
			是一种分布式事务框架，用来确保在大规模分布式/微服务环境下端到端业务操作的最终一致性。

			由 CAP 定理可知，任何大型的分布式系统/微服务在一致性、可用性和分区容忍这三点上只能保证其中的两点。
			由于在分布式系统中经常发生丢包、网络故障，分区容忍性是必须要满足的，
			同时为了兼顾高可用性，绝大部分系统都将强一致性需求转化成最终一致性需求，并通过幂等机制保证了数据的最终一致性。

	三、常用的分布式技术介绍
		(1) 本地消息表 (经典的 ebay 模式) 
			该方案的核心思想在于分布式系统在处理任务时通过消息日志的方式来异步执行。
			消息日志可以存储至本地文本、数据库或消息队列，然后再通过业务规则定时任务或人工自动重试。
			以在线支付系统的跨行转账为例：

				第一步，伪代码如下，对用户 id 为 A 的账户扣款 1000 元，通过本地事务将事务消息 (包括本地事务 id、支付账户、收款账户、金额、状态等) 插入至消息表：
					Begin transaction
						 update user_account set amount = amount - 1000 where userId = 'A'
						 insert into trans_message(xid,payAccount,recAccount,amount,status) values(uuid(),'A','B',1000,1);
					end transaction
					commit;
				第二步，通知对方用户 id 为 B，增加 1000 元，通常通过消息 MQ 的方式发送异步消息，对方订阅并监听消息后自动触发转账的操作；
				这里为了保证幂等性，防止触发重复的转账操作，需要在执行转账操作方新增一个 trans_recv_log 表用来做幂等，
				在第二阶段收到消息后，通过判断 trans_recv_log 表来检测相关记录是否被执行，
				如果未被执行则会对 B 账户余额执行加 1000 元的操作，并会将该记录增加至 trans_recv_log，
				事件结束后通过回调更新 trans_message 的状态值。

		(2) 消息中间件
			a. 非事务消息中间件

				这里仍然以上面跨行转账为例，我们很难保证在扣款完成之后对 MQ 投递消息的操作就一定能成功。
				这样一致性似乎很难保证。
				以下伪代码说明了消息投递的异常：
					try{
						boolean result = dao.update(model);//更新数据库失败抛出异常
						if(result){
								 mq.send(model);//如果 MQ 超时或者接收方处理失败, 抛出异常
						}
					}catch(Exception ex){
								 rollback();//如果异常回滚
					}
				对于以上的运行情况主要有以下几种：

					操作数据库成功，向 MQ 中投递消息也成功，该属于正常情况，一切都 OK。
					操作数据库失败，不会向 MQ 中投递消息了。
					操作数据库成功，但是向 MQ 中投递消息时失败，向外抛出了异常，刚刚执行的更新数据库的操作将被回滚。
					从上面分析的几种情况来看，基本上能确保, 发送消息的可靠性。我们再来分析下消费者端的问题：

				接收者取出消息后，消费者对应的业务操作要执行成功。
				如果业务执行失败，消息不能失效或者丢失。需要保证消息与业务操作一致。
				尽量确保消息的幂等性。如果出现重复消息投递，能够进行幂等而不对业务产生影响。
			
			b. 支持事务的消息中间件

				Apache 开源的 RocketMQ 中间件能够支持一种事务消息机制，确保本地操作和发送消息的异步处理达到本地事务的结果一致。

					第一阶段，RocketMQ 在执行本地事务之前，会先发送一个 Prepared 消息，并且会持有这个消息的接口回查地址。

					第二阶段，执行本地事物操作。

					第三阶段，确认消息发送，通过第一阶段拿到的接口地址 URL 执行回查，并修改状态，
						如果本地事务成功，则修改状态为已提交，否则修改状态为已回滚。

					其中，如果第三阶段的确认消息发送失败后，RocketMQ 会有定时任务扫描集群中的事务消息，
					如果发现还是处于 prepare 状态的消息，它会向消息发送者确认本地事务是否已执行成功。
					RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。
					这样就保证了消息的发送与本地事务同时成功或同时失败。

				再回到上面转账的例子，如果用户 A 的账户余额已经减少，且消息已经发送成功，作为消费者用户 B 开始消费这条消息，
				这个时候就会出现消费失败和消费超时两个问题，解决超时问题的思路就是一直重试，直到消费端消费消息成功，
				整个过程中有可能会出现消息重复的问题，就需要采用前面说的幂等方案来进行处理。

	
	
分布式事务—2PC 协议
		为了解决大型分布式/微服务系统中的一致性问题，业界比较流行的做法是采用比较著名的有：
		二阶提交协议 (2 Phase Commitment Protocol) 、
		三阶提交协议 (3 PhaseCommitment Protocol) 。
		考虑到性能问题，三阶段提交协议目前较少被采用。本文也主要介绍二阶段协议。

	2PC 协议
		二阶段提交协议是分布式系统中较为经典的处理数据一致性的解决方案。
		在大型的集群环境中，对于单体微服务本身而言虽然能够通过代码质量、Mock 测试等方法来确保自身服务的可用性，
		但是无法能够保证其他服务的可用性。
		当一个全链路的端到端业务操作，常常会跨多个节点、多个应用，
		为了能够保证全局事务的 ACID 特性，需要引入一个协调组件 (这里称之为 TM) 来控制所有服务参与者 (这里称之为 RM) 的操作结果，
		根据所有参与者的反馈结果来决定整个分布式事务究竟是提交还是回滚的结果。

	第一阶段：称为准备 (prepare) 阶段。
		事务协调者向各个服务应用发送 prepare 请求，服务应用在得到请求后做预处理操作，
		预处理可能是做预检查，也可能是把请求临时存储，可以理解为是一种试探性地提交。
		下面是一般的步骤：
			a. 事务协调者会问所有的参与者服务，是否可以提交操作。
			b. 各个参与者开始事务执行的准备工作：如资源上锁，预留资源，写回滚/重试的 log。
			c. 参与者响应协调者，如果事务准备工作成功，则回应“可以提交”，否则回应拒绝提交。

	第二阶段：称为提交 (commit)/回滚 (rollback) 阶段。
		是指事务真正提交或者回滚的阶段。
		如果事务协调者发现事务参与者有一个在 prepare 阶段出现失败，则会要求所有的参与者进行回滚。
		如果协调者发现所有的参与者都 prepare 操作都是成功，那么他将向所有的参与者发出提交请求，这时所有参与者才会正式提交。
		由此保证了要求全部提交成功，要么全部失败。
		下面是具体步骤：
			a. 如果所有的参与者都回应“可以提交”，那么协调者向所有参与者发送“正式提交”的命令。
				参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各个服务的“完成”回应后结束事务。
			b. 如果有一个参与者回应“拒绝提交”，那么协调者向所有的参与者发送“回滚操作”，并释放所有的资源，
				然后回应“回滚完成”，协调者收集各个服务应用的“回滚”返回后，取消整体的分布式事务。

	下图为二阶段的成功和失败示例图：

		二阶段提交协议解决的是分布式系统/微服务架构中数据强一致性的问题，其原理简单，但缺点也是存在，主要缺点如下：

			a. 单点问题：协调者在整个二阶段中的作用非常重要，
				一旦部署协调者组件服务的节点出现不可用宕机情况，那么会影响整个分布式系统的正常运行。
			b. 同步阻塞：二阶段提交执行过程中，所有服务参与者需要服从协调者的统一调度，期间处于阻塞状态，
				会一定程度上影响整个系统的效率。




分布式事务


	假如没有分布式事务

		在一系列微服务系统当中，假如不存在分布式事务，会发生什么呢？让我们以互联网中常用的交易业务为例子：
		上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。
		在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。
		正常情况下，两个数据库各自更新成功，两边数据维持着一致性。
		但是，在非正常情况下，有可能库存的扣减完成了，随后的订单记录却因为某些原因插入失败。
		这个时候，两边数据就失去了应有的一致性。

	什么是分布式事务

		分布式事务用于在分布式系统中保证不同节点之间的数据一致性。
		分布式事务的实现有很多种，最具有代表性的是由 Oracle Tuxedo 系统提出的 XA 分布式事务协议。
		XA 协议包含两阶段提交 (2PC) 和三阶段提交 (3PC) 两种实现，这里我们重点介绍两阶段提交的具体过程。
			在魔兽世界这款游戏中，副本组团打 BOSS 的时候，为了更方便队长与队员们之间的协作，队长可以发起一个“就位确认”的操作：
			当队员收到就位确认提示后，如果已经就位，就选择“是”，如果还没就位，就选择“否”。
			当队长收到了所有人的就位确认，就会向所有队员们发布消息，告诉他们开始打 BOSS。
			相应的，在队长发起就位确认的时候，有可能某些队员还并没有就位：
			以上就是魔兽世界当中组团打 BOSS 的确认流程。这个流程和 XA 分布式事务协议的两阶段提交非常相似。


	那么 XA 协议究竟是什么样子呢？在 XA 协议中包含着两个角色：事务协调者和事务参与者。让我们来看一看他们之间的交互流程：

		第一阶段：

			在 XA 分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送 Prepare 请求。
			在接到 Prepare 请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入 Undo Log 和 Redo Log。
			如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。
			当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

		第二阶段：

			在 XA 分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出 Commit 请求。
			接到 Commit 请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。
			当本地事务完成提交后，将会向事务协调者返回“完成”消息。
			当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。
			以上所描述的是 XA 两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：

		在 XA 的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。

		于是在第二阶段，事务协调节点向所有的事务参与者发送 Abort 请求。
		接收到 Abort 请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照 Undo Log 来进行。


	XA 两阶段提交的不足

		1. 性能问题

			XA 协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，
			只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。
			这样的过程有着非常明显的性能问题。

		2. 协调者单点故障问题

			事务协调者是整个 XA 模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。

		3. 丢失消息导致的不一致问题。

			在 XA 协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，
			那么就导致了节点之间数据的不一致。

	如果避免 XA 两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：

		1.XA 三阶段提交
			
			XA 三阶段提交在两阶段提交的基础上增加了 CanCommit 阶段，并且引入了超时机制。
			一旦事物参与者迟迟没有接到协调者的 commit 请求，会自动进行本地 commit。
			这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。

		2.MQ 事务

			利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像 XA 协议那样的性能问题。

		3.TCC 事务

			TCC 事务是 Try、Commit、Cancel 三种指令的缩写，其逻辑模式类似于 XA 两阶段提交，但是实现方式是在代码层面来人为实现。




分布式事务的解决方案

	1、什么是分布式事务
	
		分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
		简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，
		分布式事务需要保证这些小操作要么全部成功，要么全部失败。
		本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

	2、分布式事务的产生的原因
		
		2.1、数据库分库分表
			当数据库单表一年产生的数据超过 1000W，那么就要考虑分库分表，
			简单的说就是原来的一个数据库变成了多个数据库。
			这时候，如果一个操作既访问 01 库，又访问 02 库，而且要保证数据的一致性，那么就要用到分布式事务。
		
		2.2、应用 SOA 化
			所谓的 SOA 化，就是业务的服务化。
			比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。
			对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。
			这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。
		以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！

	3、事务的 ACID 特性
	
		3.1、原子性 (A) 
			所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。
			对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。

		3.2、一致性 (C) 
			事务的执行必须保证系统的一致性，
			就拿转账为例，A 有 500 元，B 有 300 元，如果在一个事务里 A 成功转给 B50 元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后 A 账户一定是 450 元，B 账户一定是 350 元。

		3.3、隔离性 (I) 
			所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。

		3.4、持久性 (D) 
			所谓的持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。

	4、分布式事务的应用场景
	
		4.1、支付
			最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，
			这些操作必须在一个事务里执行，要么全部成功，要么全部失败。
			而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，
			对不同数据库的操作必然需要引入分布式事务。

		4.2、在线下单
			买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，
			库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。

	5、常见的分布式事务解决方案

		5.1、基于 XA 协议的两阶段提交

			XA 是一个分布式事务协议，由 Tuxedo 提出。
			XA 中大致分为两部分：事务管理器和本地资源管理器。
			其中本地资源管理器往往由数据库实现，比如 Oracle、DB2 这些商业数据库都实现了 XA 接口，
			而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

			XA 实现分布式事务的原理如下：

			总的来说，XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较低。
			但是，XA 也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景。
			XA 目前在商业数据库支持的比较理想，在 mysql 数据库中支持的不太理想，
			mysql 的 XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。
			许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。
	
	
		5.2、消息事务+ 最终一致性

			所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，
			它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，
			开源的 RocketMQ 就支持这一特性，具体原理如下：

				1. A 系统向消息中间件发送一条预备消息
				2. 消息中间件保存预备消息并返回成功
				3. A 执行本地事务
				4. A 发送提交消息给消息中间件
			
			通过以上 4 步完成了一个消息事务。对于以上的 4 个步骤，每个步骤都可能产生错误，下面一一分析：

				步骤一出错，则整个事务失败，不会执行 A 的本地操作
				步骤二出错，则整个事务失败，不会执行 A 的本地操作
				步骤三出错，这时候需要回滚预备消息，怎么回滚？
				答案是 A 系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查 A 事务执行是否执行成功，如果失败则回滚预备消息
				步骤四出错，这时候 A 的本地事务是成功的，那么消息中间件要回滚 A 吗？
				答案是不需要，其实通过回调接口，消息中间件能够检查到 A 执行成功了，这时候其实不需要 A 发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务
				基于消息中间件的两阶段提交往往用在高并发场景下，
				将一个分布式事务拆成一个消息事务 (A 系统的本地操作+ 发消息) +B 系统的本地操作，其中 B 系统的操作由消息驱动，
				只要消息事务成功，那么 A 操作一定成功，消息也一定发出来了，这时候 B 会收到消息去执行本地操作，
				如果本地操作失败，消息会重投，直到 B 操作成功，这样就变相地实现了 A 与 B 的分布式事务。原理如下：

				虽然上面的方案能够完成 A 和 B 的操作，但是 A 和 B 并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。
				当然，这种玩法也是有风险的，如果 B 一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。

		5.3、TCC 编程模式

			所谓的 TCC 编程模式，也是两阶段提交的一个变种。
			TCC 提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm 和 Cancel 三个操作。
			以在线下单为例，Try 阶段会去扣库存，Confirm 阶段则是去更新订单状态，
			如果更新订单失败，则进入 Cancel 阶段，会去恢复库存。
			总之，TCC 就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，
			因此，这种模式并不能很好地被复用。

	6、总结

		分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。
		不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，
		包括上面提到的消息事务+ 最终一致性、TCC 模式，而完全控制就是完全实现两阶段提交。
		部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，
		具体用哪种方式，最终还是取决于业务场景。
		作为技术人员，一定不能忘了技术是为业务服务的，不要为了技术而技术，针对不同业务进行技术选型也是一种很重要的能力
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	