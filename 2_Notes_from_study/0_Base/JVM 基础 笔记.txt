
JVM 


JVM 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		类装载器：用来装载.class 文件；
			类装载器类型：
				启动类装载器：是 JVM 实现的一部分，
				用户自定义类装载器：是 Java 程序的一部分，必须是 ClassLoader 类的子类。
		类加载机制
		
		
		
		GC
			G1
			
			CMS
		
		内存模型
			运行时数据区：
				堆：
				虚拟机栈：
				方法区：
				运行时常量池：
				程序计数器；
				本地方方法栈。
		
	怎么使用：
	
	

	
JVM 内存

	运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、Java 堆、方法区以及方法区中的运行时常量池
	
	1、程序计数器： 
		线程私有，是当前线程所执行的字节码的行号指示器，如果线程正执行一个 Java 方法，
		计数器记录正在执行的虚拟机字节码指令的地址，如果线程正在执行的是 Native 方法，则计数器值为空；
	
	2、虚拟机栈： 
		即栈区，线程私有，为虚拟机执行 Java 方法 (字节码) 服务，
		每个方法在执行的时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，
		每个方法的调用直至执行完成对应于栈帧的入栈和出栈；
	
	3、本地方法栈： 
		为虚拟机使用的 Native 方法服务，也是线程私有；
	
	4、Java 堆： 
		在虚拟机启动时创建，线程共享，
		唯一目的是存放对象实例，是垃圾收集器管理的主要区域——”GC 堆“，
		可以细分为新生代和老年代，
		新生代又可以细分为 Eden 空间、 From Survivor 空间和 To Survivor 空间；
		物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展；
	
	5、方法区： 
		线程共享，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
		被称为“永久代”，是因为 H otSpot 虚拟机的设计团队把 GC 分代收集扩展到方法区，
		即使用永久代来实现方法区，像 GC 管理 Java 堆一样管理方法区，从而省去专门为方法区编写内存管理代码，
		内存回收目标是针对常量池的回收和堆类型的卸载；
		
		方法区在 JVM 中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。
		在方法区中，存储了每个类的信息 (包括类的名称、方法信息、字段信息) 、静态变量、常量以及编译器编译后的代码等。
	
	6、运行时常量池： 
		线程共享，是方法区的一部分，
		C lass 文件中存放编译期生成的各种字面量和符号引用，类加载后进入方法区的运行时常量池中。
	
	
	
JVM 运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器

	虚拟机栈区 ：
		也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress，在编译期间完成分配。

	堆区，JAVA 堆，也称 GC 堆，
		所有线程共享，存放对象的实例和数组，JAVA 堆是垃圾收集器管理的主要区域。

	方法区 ：
		所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
		这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。

	程序计数器 ：
		线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。

JVM 内存分区：
	1. 栈区：存放函数的参数、局部变量等
	2. 堆区：存放对象
	3. 全局区 (静态区)：存放全局变量和静态变量
	4. 常量区：存放常量字符串
	5. 代码区：存放函数体的二进制代码
	
JVM 内存：
	一条进程的栈区、堆区、数据区和代码区在内存中的映射 
		1. 栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp 的值越小。
		2. 堆区：用于存放动态分配的对象, 
			当你使用 malloc 和 new 等进行分配时, 所得到的空间就在堆中。
			动态分配得到的内存区域附带有分配信息, 所以可以 free 和 delete 它们。
		3. 数据区：全局，静态和常量是分配在数据区中的，数据区包括 bss (未初始化数据区) 和初始化数据区。
	
JVM 内存：
	1. 方法区 (Method Area) ：
		存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
	2. 堆 (Heap) ：
		存放对象实例，几乎所有对象实例都在这里分配内存；
	3. 虚拟机栈 (VM Stack) ：
		描述的是 Java 方法执行的内存模型；
		每个方法在执行的同时会创建一个 Stack Frame (方法运行时的基础数据结构) 
		用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
	4. 本地方法栈 (Native Method Stack) ：
		与虚拟机栈了类似，不过则为虚拟机使用的到的 Native 方法服务
		 (有的虚拟机譬如 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一) 。
	5. 程序计数器 (Program Counter Register) ：
		可看作当前线程所执行的字节码的行号的标识器。



JVM 内存：
		
	栈：存放基本类型的数据和对象的引用；但对象本身不存放在栈中，而是存放在堆中；
	堆：存放用 new 产生的数据，和对象本身；
	静态域：存放在对象中用 static 定义的静态成员；
	常量池：存放常量；
	非 RAM 存储：硬盘等永久存储空间。
	
JVM 内存：
	用 new 创建的对象，在堆区；
	函数中的临时变量，在栈区；
	Java 中的字符串，在字符串常量区，常量池。
	
	
	
	
	
	
	
	
String：
	
	基于广泛使用的 Oracle HotSpot 虚拟机：
		首先，String str1 =“abc”编译为字节码后，实际上相当于：String str1 =“abc”.intern()
		对于 JDK 1.6，intern() 方法是这样的：如果“abc”是首次遇到，则字符串“abc”本身会被复制到字符串常量池中，
		且以后如果再遇到“abc”，直接返回常量池的引用。
		注意，JDK 1.6 的常量池存在于 JVM 的永久代中，而对于 Hotspot 虚拟机的实现，永久代事实上对应 Java 虚拟机规范中的方法区！
		对于 JDK 1.7，intern() 方法不会对字符串实例进行复制，而只是在字符串常量池中记录首次出现的实例引用。
		当然，最关键的是，JDK 1.7 中的字符串常量池是在堆中的！
		具体请参考“深入理解 JAVA 虚拟机”一书中 第 42 页 和 第 57 页 的讨论


	Java 中 String 是 immutable 的，也就是不可变，一旦初始化，其引用指向的内容是不可变的。
		String str =“aa”；str=“bb”；第二句不是改变“aa”所存储地址的内容，而是另外开辟了一个空间用来存储“bb”；
		同时由 str 指向原来的“aa”，现在已经不可达，GC 时会自动回收。
		因此 String 作为参数传进来时候，str= "test ok"; 实际给副本引用 str 指向了新分配的地址，该地址存储“test ok”。
		因此，原先的 str 仍然指向“good”。
	
	
	
	
	
	
	
	
值传递机制：
	1. 基本类型和基本类型变量被当作参数传递给方法时，是值传递。
		在方法实体中，无法给原变量重新赋值，也无法改变它的值。

	2. 对象和引用型变量被当作参数传递给方法时，是引用传递。
		在方法实体中，无法给原变量重新赋值，但是可以改变它所指向对象的属性。

Boolean 是引用类型，不是基本数据类型。
	Java 中的基本数据类型都对应一个引用类型，如 Float 是 float 的引用类型，Integer 是 int 的引用类型。
	
	
	
	
	
	
	
	
	
	
	
堆内存：
	Java 的堆内存分为两块：permantspace (持久带) 和 heap space。
	持久代：
		主要用于存放静态类型数据，如 Java Class, Method 等，与垃圾收集器要收集的 Java 对象关系不大。
	heap space：
		分为年轻代和年老代：
		年轻代：Young GC ；
		年老代：Full GC。
	在年轻代中经历了 N 次 (可配置) 垃圾回收后仍然存活的对象，就会被复制到年老代中。
	因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	年老代溢出原因有：
		循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百 M 甚至上 G 的内存；
	持久代溢出原因：
		动态加载了大量 Java 类而导致溢出。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
类装载器：
	用来装载 .class 文件；
	类装载器类型：
		启动类装载器：是 JVM 实现的一部分，
		用户自定义类装载器：是 Java 程序的一部分，必须是 ClassLoader 类的子类。
		
类加载机制：
	
		静态代码块：用 static 申明，JVM 加载类时执行，仅执行一次，且按声明顺序执行
		构造代码块：类中直接用 {} 定义，每一次创建对象时执行
		执行顺序优先级：静态块 > main() > 构造块 > 构造方法
	
	执行顺序：1. 静态代码块；2. 构造代码块；3. 构造方法；
		1. 静态代码块：
			是在类的加载过程的第三步初始化的时候进行的，主要目的是给类变量赋予初始值。
		2. 构造代码块：
			是独立的，必须依附载体才能运行；
			Java 会把构造代码块放到每种构造方法的前面，用于实例化一些共有的实例变量，减少代码量。
		3. 构造方法：
			用于实例化变量。
		注意：1 是类级别的，2 和 3 是实例级别的，自然 1 要优先 2 和 3。
	
	
	在继承中代码的执行顺序：
		1. 父类静态对象，父类静态代码块；
		2. 子类静态对象，子类静态代码块；
		3. 父类非静态对象，父类非静态代码块；
		4. 父类构造函数；
		5. 子类非静态对象，子类非静态代码块；
		6. 子类构造函数。
		
		
	类加载的属性：
		1、虚拟机在首次加载 Java 类时，会对静态初始化代码块、静态成员变量、静态方法进行一次初始化。
			我们不要去纠结这里的顺序，一般来说我们只需要知道，静态方法一般在最后。
		2、只有在调用 new 方法时才会创建类的实例；
		3、类实例创建过程：
			按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；
			再执行本类继承的子类的初始化块，最后是子类的构造方法。
		4、类实例销毁时候，首先销毁子类部分，再销毁父类部分
	
	类的加载顺序：
		1) 父类静态代码块；(包括静态初始化块，静态属性，但不包括静态方法)
		2) 子类静态代码块；(包括静态初始化块，静态属性，但不包括静态方法)
		3) 父类非静态代码块；(包括非静态初始化块，非静态属性)
		4) 父类构造函数；
		5) 子类非静态代码块；(包括非静态初始化块，非静态属性)
		6) 子类构造函数。
		其中：类中静态块按照声明顺序执行，并且 (1) 和 (2) 不需要调用 new 类实例的时候就执行了 (在类加载到方法区的时候执行的)

		
		
	初始化过程： 
		1. 首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 
		2. 然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 
		3. 其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法；
		4. 最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法； 
	
	初始化过程：
		1. 初始化父类中的静态成员变量和静态代码块 ； 
		2. 初始化子类中的静态成员变量和静态代码块 ； 
		3. 初始化父类的普通成员变量和代码块，再执行父类的构造方法；
		4. 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 
		
		1) 初始化父类的普通成员变量和代码块；
		2) 再执行父类的构造方法；
		3) 初始化子类的普通成员变量和代码块；
		4) 再执行子类的构造方法。
		
		1. 父类静态代码块； (Java 虚拟机加载类时，就会执行该块代码，故只执行一次) 
		2. 子类静态代码块； (Java 虚拟机加载类时，就会执行该块代码，故只执行一次) 
		3. 父类属性对象初始化；
		4. 父类普通代码块； (每次 new, 每次执行) 
		5. 父类构造函数； (每次 new, 每次执行) 
		6. 子类属性对象初始化；
		7. 子类普通代码块； (每次 new, 每次执行) 
		8. 子类构造函数； (每次 new, 每次执行) 
		
		
		
	子类的构造方法总是先调用父类的构造方法，
		如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。
		而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。

		如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认 (没有参数) 的构造器。
		如果超类没有不带参数的构造器，并且在子类的构造器中有没有显示地调用超类的其他构造器，则 Java 编译器将报告错误。
		使用 super 调用构造器的语句必须是子类构造器的第一条语句。
	
	当类加载时，static 静态方法随着类加载而初始化，此时实例对象还未被创建，
	但是非静态成员变量需要等到实例对象创建才会被初始化，故无法被引用。
	
	
	构造方法不需要同步化，
		一个子类可以覆盖掉父类的同步方法，
		定义在接口中的方法默认是 public 的，
		容器保存的是对象的引用，
		构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步。
		如果父类中的某个方法使用了 synchronized 关键字，而子类中也覆盖了这个方法，
		默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized 关键字才可。
		当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，
		但子类调用了父类中的同步方法，也就相当子类方法也同步了。

接口：
	接口里面的变量为常量，其实际是 public static final ；
	接口里面的方法为抽象方法，其实际是 public abstract。
	
子类覆盖父类方法：
	子类覆盖父类方法的问题，也就是方法重写实现多态问题。
		Base b = new Sub();
		它为多态的一种表现形式，声明是 Base，实现是 Sub 类，
		理解为 b 编译时表现为 Base 类特性，运行时表现为 Sub 类特性。
		当子类覆盖了父类的方法后，意思是父类的方法已经被重写。
		题中父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的 baseName 为子类中的私有属性。

	
	
	
	
	

GC 
	
	G1 收集器，基于标记清理。
	
	CMS 收集器：整体上是基于标记整理，局部采用复制。
	
	Minor GC：
	Full GC：
	
	PS GC：
		
	复制算法和标记清理算法：最基本的 Java 回收算法
		
		复制算法：
			两个区域 A 和 B，初始对象在 A，继续存活的对象被转移到 B。此为新生代最常用的算法；
		标记清理算法：
			一块区域，标记可达对象 (可达性分析) ，然后回收不可达对象，会出现碎片，那么引出标记-整理算法；
		标记-整理算法：
			比标记清理算法多了碎片整理，整理出更大的内存放更大的对象
		
	新生代、年老代和持久代：
		
		新生代：初始对象，生命周期短的；
		年老代：长时间存在的对象；
		持久代：要用于存放静态类型数据。
	
		整个 Java 的垃圾回收是新生代和年老代的协作，这种叫做分代回收。
			P.S：
				Serial New 收集器是针对新生代的收集器，采用的是复制算法
				Parallel New (并行) 收集器，新生代采用复制算法，老年代采用标记整理
				Parallel Scavenge (并行) 收集器，针对新生代，采用复制收集算法
				Serial Old (串行) 收集器，新生代采用复制，老年代采用标记整理
				Parallel Old (并行) 收集器，针对老年代，标记整理
		
		1. 新生代：
			a. 所有对象创建在新生代的 Eden 区，
				当 Eden 区满后触发新生代的 Minor GC，
				将 Eden 区和非空闲 Survivor 区存活的对象复制到另外一个空闲的 Survivor 区中。
			b. 保证一个 Survivor 区是空的，
				新生代 Minor GC 是在两个 Survivor 区之间相互复制存活对象，直到 Survivor 区满为止。
		2. 老年代：
			当 Survivor 区也满了之后就通过 Minor GC 将对象复制到老年代。
			老年代也满了的话，就将触发 Full GC，针对整个堆 (包括新生代、老年代、持久代) 进行垃圾回收。
		3. 持久代：
			持久代如果满了，将触发 Full GC。
		
	除直接调用 System.gc 外，触发 Full GC 执行的情况有如下四种：
		
		1. 老生代空间不足：		
			旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，
			当执行 Full GC 后空间仍然不足，则抛出如下错误：
				java.lang.OutOfMemoryError: Java heap space 
			为避免以上两种状况引起的 FullGC，调优时应尽量做到：
				让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
		
		2. 持久代 (Permanet Generation) 空间满：
			PermanetGeneration 中存放的为一些 class 的信息等，
			当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，
			在没有配置成采用 CMS GC 的情况下会执行 Full GC。
			如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：
				java.lang.OutOfMemoryError: PermGen space 
			为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。
		
		3. CMS GC 时出现 promotion failed 和 concurrent mode failure：
			对于采用 CMS 进行旧生代 GC 的程序而言，
			尤其要注意 GC 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，
			当这两种状况出现时可能会触发 Full GC。
				promotionfailed 是在进行 Minor GC 时，
					survivor space 放不下、对象只能放入老生代，
					而此时老生代也放不下造成的；
				concurrent mode failure 是在执行 CMS GC 的过程中，
					同时有对象要放入旧生代，而此时旧生代空间不足造成的。
				应对措施为：增大 survivorspace、旧生代空间或调低触发并发 GC 的比率，
				但在 JDK 5.0+、6.0+ 的版本中有可能会由于 JDK 的 bug29 导致 CMS 在 remark 完毕后很久才触发 sweeping 动作。
				对于这种状况，可通过设置 -XX:CMSMaxAbortablePrecleanTime=5 (单位为 ms) 来避免。
				
		4. 统计得到的 Minor GC 晋升到老生代的平均大小大于老生代的剩余空间：
			这是一个较为复杂的触发情况，
			Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断，
			如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。
				例如程序第一次触发 MinorGC 后，有 6MB 的对象晋升到旧生代，
				那么当下一次 Minor GC 发生时，首先检查旧生代的剩余空间是否大于 6MB，
				如果小于 6MB，则执行 Full GC。
			当新生代采用 PS GC 时，方式稍有不同，
				PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于 6MB，如小于，则触发对旧生代的回收。
		
		
		
	Java 的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。
		所以 Java 的垃圾收集算法使用的是分代回收。
			一般 Java 的对象首先进入新生代的 Eden 区域，当进行 GC 的时候会回收新生代的区域；
			新生代一般采用复制收集算法，将活着的对象复制到 survivor 区域中。
		如果 survivor 区域装在不下，就查看老生代是否有足够的空间装下新生代中的对象，
		如果能装下就装下，否则老生代就执行 FULL GC 回收自己，
		如果老生代还是装不下，就会抛出 OUtOfMemory 的异常内存泄露问题，
			可能原因：访问资源文件，流不关闭，访问数据库等连接不关闭。
	
	System.gc()：
		其实这个 gc() 函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。
		但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策.	
		释放掉占据的内存空间是由 gc 完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，
		这取决于 GC 本身，无法由程序员通过代码控制。
	
	Java 把内存划分成两种：
		一种是栈内存，另一种是堆内存。
			栈内存中分配：在函数中定义的一些基本类型的变量和对象的引用变量；
				当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，
				当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
			数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用；
				但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走 (释放掉) 。
			这也是 Java 比较占内存的原因。
	
	
	
	
Java类加载机制总结
	
	类的生命周期与加载时机
	
		1. 类的生命周期
			一个类从被加载到虚拟机内存中开始，到被卸载出内存为止，整个生命周期包括了 加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中 验证、准备、解析 3部分统称为链接，如下图：
			整个顺序并不是完全固定的，其中解析阶段可以在初始化之后再开始，这样便可以实现Java的运行时绑定（动态绑定）机制。
		2. 类的加载时机
			JVM虚拟机规范并没有对类的加载时机做出严格的要求，只规定了以下五种情况需要立刻触发类的初始化：

				1. 遇到new,getstatic,putstatic和invokestatic这四个字节码指令时，
					如果类没有进行过初始化，则需要先触发其初始化。
				2. 使用反射机制对类进行调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
				3. 当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化。
				4. 虚拟机启动时，用户需要指定一个要执行的主类（包含main方法），此时会先初始化这个类
				5. 使用JDK1.7的动态语言支持时，
					如果一个MethodHandle实例最后的解析结果
					包含REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，
					且这个方法句柄对应的类没有初始化，则需要先对其进行初始化。
			其余条件下，可以由JVM虚拟机自行决定何时去加载一个类。
		3. 主动引用和被动引用
			上面五种条件也被称为对类的主动引用，除此之外其他引用类的方式都不会触发初始化，即类的被动引用，举个例子：
			publicclassFather{ static { System.out.println("father init."); } publicstaticint val = 123; } publicclassSonextendsFather{ static { System.out.println("son init."); } } 复制代码
			当我们访问Son.val时，会发现并没有输出son init.
			对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类的静态字段，子类相当于是被动引用，也就不会被初始化了。

	类的加载过程
		下面简单的介绍一下整个加载过程中，每个阶段JVM都执行了什么操作：
		加载(Loading)
			加载过程是Java的一大特点，类的来源可以多种多样，压缩包、网络字节流、运行时动态计算生成(reflect)等等...这也造就了Java语言强大的动态特性。

				1. 通过一个类的完整限定名来获取定义此类的二进制字节流（注意，字节流的来源非常灵活）
				2. 将这个字节流所代表的静态储存结构转换成为方法区的运行时数据结构
				3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

		验证(Verification)
			这一过程主要是为了确保Class的字节流中包含的信息符合虚拟机标准，以免造成破坏

				1. 文件格式验证
				2. 元数据验证
				3. 字节码验证，通过数据流和控制流分析确定程序的语义是合法的
				4. 符号引用验证，确保解析动作能够正常执行

		准备(Preparation)
			这一阶段将会为类变量分配内存并设置其初始值，注意此时进行内存分配的仅包括类变量(static修饰)，并且初始值通常情况下是数据类型的零值而不是设定值，如下例
			public static int val = 123; 复制代码
			在这一阶段变量val的赋值是0而不是123，因为此时尚未执行任何Java方法，而对val复制的putstatic指令在初始化阶段后才会执行。
			当然也有特殊情况，如下
			public static final int val = 123; 复制代码
			加上final关键字修饰后，Java编译时会为val生成ConstantValue属性，这时准备阶段就会根据设置将其值设置为123。
			
		解析(Resolution)
			此阶段虚拟机将常量池内的符号替换为直接引用，主要包含以下动作：

				1. 类或接口的解析
				2. 字段解析
				3. 类方法解析
				4. 接口方法解析

		初始化(Initialization)
			这时类加载过程的最后一步，这部分开始真正的执行Java代码，也就是说，这个阶段可以由程序员参与。
			此阶段其实就是执行类构造器<clinit>()方法的过程。
	
	类加载器
			类加载器(Class Loader)是Java虚拟机的一大创举，它将“获取类的二进制字节流”这个过程交给了开发人员自己去实现，
			只要编写不同的Class Loader，应用程序本身就可以用相应的方式来获取自己需要的类。
		类与加载器的关系
			对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性。
			通俗的讲，就是即便同一个Class文件，被不同的类加载器加载之后，得到也不是同一个“类”（equals方法返回false）。
		双亲委派模型
			从虚拟机角度讲，只有两种类加载器，一种是启动类加载器(Bootstrap ClassLoader)，在hotpot上使用C++实现，属于虚拟机的一部分；另一种则是所有其他类的加载器，这些加载器是独立于虚拟机的，由Java语言实现的，从开发者角度看，可以分为以下两类：

				1. 扩展类加载器(Extension ClassLoader)
				2. 应用程序类加载器(Appliaction ClassLoader)

			当然开发人员也可以自己编写类加载器，最终不同的类加载器之间的层次关系如下图所示：
			这就是Java中著名的双亲委派模型，它要求除了顶级的BootStrap加载器之外，其他类加载器都必须有父类加载器，工作流程如下：
			如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成，只有当父加载器反馈自己无法完成加载请求时，子加载器才会自己去尝试加载这个类。
			这样做的好处是，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。举个例子，比如java.lang.Object这个类，无论哪个类加载器加载时，最终都会委派给Bootstrap加载器去加载，这就保证了整个系统运行过程中的Object都是同一个类。
			否则，如果用户自己编写了一个java.lang.Object类，并放在程序的classpath中，最终系统将会出现多个不同的Object类，整个Java体系就变得一团混乱了。

		
		
	
	