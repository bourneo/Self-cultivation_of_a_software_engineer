
JVM 


JVM 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		类装载器：用来装载.class文件；
			类装载器类型：
				启动类装载器：是JVM实现的一部分，
				用户自定义类装载器：是Java程序的一部分，必须是ClassLoader类的子类。
		类加载机制
		
		
		
		GC
			G1
			
			CMS
		
		内存模型
			运行时数据区：
				堆：
				虚拟机栈：
				方法区：
				运行时常量池：
				程序计数器；
				本地方方法栈。
		
	怎么使用：
	
	

	
JVM 内存

	运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区以及方法区中的运行时常量池
	
	1、程序计数器： 
		线程私有，是当前线程所执行的字节码的行号指示器，如果线程正执行一个 Java 方法，
		计数器记录正在执行的虚拟机字节码指令的地址，如果线程正在执行的是Native方法，则计数器值为空；
	
	2、虚拟机栈： 
		即栈区， 线程私有 ，为虚拟机执行 Java 方法（字节码）服务，
		每个方法在执行的时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，
		每个方法的调用直至执行完成对应于栈帧的入栈和出栈；
	
	3、本地方法栈： 
		为虚拟机使用的 Native 方法服务，也是线程私有；
	
	4、Java 堆： 
		在虚拟机启动时创建， 线程共享 ，
		唯一目的是存放对象实例，是垃圾收集器管理的主要区域——” GC 堆“，
		可以细分为新生代和老年代，
		新生代又可以细分为 Eden 空间、 From Survivor 空间和 To Survivor 空间；
		物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展；
	
	5、方法区： 
		线程共享 ，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
		被称为“永久代”，是因为 H otSpot 虚拟机的设计团队把 GC 分代收集扩展到方法区，
		即使用永久代来实现方法区，像 GC 管理 Java 堆一样管理方法区，从而省去专门为方法区编写内存管理代码，
		内存回收目标是针对常量池的回收和堆类型的卸载；
		
		方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。
		在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
	
	6、运行时常量池： 
		线程共享 ，是方法区的一部分， 
		C lass 文件中存放编译期生成的各种字面量和符号引用，类加载后进入方法区的运行时常量池中。
	
	
	
JVM 运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器

	虚拟机栈区 ：
		也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。

	堆区 ， JAVA 堆，也称 GC 堆，
		所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。

	方法区 ：
		所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
		这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。

	程序计数器 ：
		线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。

JVM 内存分区：
	1. 栈区：存放函数的参数、局部变量等
	2. 堆区：存放对象
	3. 全局区(静态区)：存放全局变量和静态变量
	4. 常量区：存放常量字符串
	5. 代码区：存放函数体的二进制代码
	
JVM 内存：
	一条进程的栈区、堆区、数据区和代码区在内存中的映射 
		1. 栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。 
		2. 堆区：用于存放动态分配的对象, 
			当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。
			动态分配得到的内存区域附带有分配信息, 所以可以 free 和 delete 它们。 
		3. 数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。
	
JVM 内存：
	1. 方法区（Method Area）：
		存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
	2. 堆（Heap）：
		存放对象实例，几乎所有对象实例都在这里分配内存；
	3. 虚拟机栈（VM Stack）：
		描述的是Java方法执行的内存模型；
		每个方法在执行的同时会创建一个Stack Frame（方法运行时的基础数据结构）
		用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
	4. 本地方法栈（Native Method Stack）：
		与虚拟机栈了类似，不过则为虚拟机使用的到的Native方法服务
		（有的虚拟机譬如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一）。
	5. 程序计数器（Program Counter Register）：
		可看作当前线程所执行的字节码的行号的标识器。



JVM 内存：
		
	栈：存放基本类型的数据和对象的引用；但对象本身不存放在栈中，而是存放在堆中；
	堆：存放用new产生的数据，和对象本身；
	静态域：存放在对象中用 static 定义的静态成员；
	常量池：存放常量；
	非RAM存储：硬盘等永久存储空间。
	
JVM 内存：
	用new创建的对象，在堆区；
	函数中的临时变量，在栈区；
	Java 中的字符串，在字符串常量区，常量池。
	
	
	
	
	
	
	
	
String：
	
	基于广泛使用的 Oracle HotSpot 虚拟机：
		首先，String str1 = “abc” 编译为字节码后，实际上相当于：String str1 = “abc”.intern()
		对于JDK 1.6，intern()方法是这样的：如果“abc”是首次遇到，则字符串“abc”本身会被复制到字符串常量池中，
		且以后如果再遇到“abc”，直接返回常量池的引用。
		注意，JDK 1.6的常量池存在于JVM的永久代中，而对于Hotspot虚拟机的实现，永久代事实上对应 Java 虚拟机规范中的方法区！
		对于JDK 1.7，intern()方法不会对字符串实例进行复制，而只是在字符串常量池中记录首次出现的实例引用。
		当然，最关键的是，JDK 1.7中的字符串常量池是在堆中的！
		具体请参考 “深入理解JAVA虚拟机”一书中 第 42页 和 第57页 的讨论


	Java 中String是 immutable 的，也就是不可变，一旦初始化，其引用指向的内容是不可变的。
		String str = “aa”；str=“bb”；第二句不是改变“aa”所存储地址的内容，而是另外开辟了一个空间用来存储“bb”；
		同时由str指向原来的“aa”，现在已经不可达，GC时会自动回收。
		因此String作为参数传进来时候，str= "test ok"; 实际给副本引用str指向了新分配的地址，该地址存储“test ok”。
		因此，原先的str仍然指向“good”。
	
	
	
	
	
	
	
	
值传递机制：
	1. 基本类型和基本类型变量被当作参数传递给方法时，是值传递。
		在方法实体中，无法给原变量重新赋值，也无法改变它的值。

	2. 对象和引用型变量被当作参数传递给方法时，是引用传递。
		在方法实体中，无法给原变量重新赋值，但是可以改变它所指向对象的属性。

Boolean 是引用类型，不是基本数据类型。
	Java 中的基本数据类型都对应一个引用类型，如 Float 是 float 的引用类型，Integer 是 int 的引用类型。
	
	
	
	
	
	
	
	
	
	
	
堆内存：
	Java 的堆内存分为两块：permantspace（持久带）和 heap space。
	持久代：
		主要用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的 Java 对象关系不大。
	heap space：
		分为年轻代和年老代：
		年轻代：Young GC ；
		年老代：Full GC 。
	在年轻代中经历了 N 次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。
	因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	年老代溢出原因有：
		循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存；
	持久代溢出原因：
		动态加载了大量 Java 类而导致溢出。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
类装载器：
	用来装载 .class 文件；
	类装载器类型：
		启动类装载器：是 JVM 实现的一部分，
		用户自定义类装载器：是 Java 程序的一部分，必须是 ClassLoader 类的子类。
		
类加载机制：
	
		静态代码块：用static申明，JVM加载类时执行，仅执行一次，且按声明顺序执行
		构造代码块：类中直接用{}定义，每一次创建对象时执行
		执行顺序优先级：静态块 > main() > 构造块 > 构造方法
	
	执行顺序：1.静态代码块；2.构造代码块；3.构造方法；
		1.静态代码块：
			是在类的加载过程的第三步初始化的时候进行的，主要目的是给类变量赋予初始值。
		2.构造代码块：
			是独立的，必须依附载体才能运行；
			Java 会把构造代码块放到每种构造方法的前面，用于实例化一些共有的实例变量，减少代码量。
		3.构造方法：
			用于实例化变量。
		注意：1 是类级别的，2 和 3 是实例级别的，自然1 要优先 2 和 3。
	
	
	在继承中代码的执行顺序：
		1. 父类静态对象，父类静态代码块；
		2. 子类静态对象，子类静态代码块；
		3. 父类非静态对象，父类非静态代码块；
		4. 父类构造函数；
		5. 子类非静态对象，子类非静态代码块；
		6. 子类构造函数。
		
		
	类加载的属性：
		1、虚拟机在首次加载 Java 类时，会对静态初始化代码块、静态成员变量、静态方法进行一次初始化。
			我们不要去纠结这里的顺序，一般来说我们只需要知道，静态方法一般在最后。
		2、只有在调用new方法时才会创建类的实例；
		3、类实例创建过程：
			按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；
			再执行本类继承的子类的初始化块，最后是子类的构造方法。
		4、类实例销毁时候，首先销毁子类部分，再销毁父类部分
	
	类的加载顺序。
		(1) 父类静态代码块；(包括静态初始化块，静态属性，但不包括静态方法)
		(2) 子类静态代码块；(包括静态初始化块，静态属性，但不包括静态方法)
		(3) 父类非静态代码块；(包括非静态初始化块，非静态属性)
		(4) 父类构造函数；
		(5) 子类非静态代码块；(包括非静态初始化块，非静态属性)
		(6) 子类构造函数。
		其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(在类加载到方法区的时候执行的)

		
		
	初始化过程： 
		1. 首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 
		2. 然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 
		3. 其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法；
		4. 最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法； 
	
	初始化过程：
		1. 初始化父类中的静态成员变量和静态代码块 ； 
		2. 初始化子类中的静态成员变量和静态代码块 ； 
		3. 初始化父类的普通成员变量和代码块，再执行父类的构造方法；
		4. 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 
		
		（1）初始化父类的普通成员变量和代码块；
		（2）再执行父类的构造方法；
		（3）初始化子类的普通成员变量和代码块；
		（4）再执行子类的构造方法。
		
		1. 父类静态代码块；（ Java 虚拟机加载类时，就会执行该块代码，故只执行一次）
		2. 子类静态代码块；（ Java 虚拟机加载类时，就会执行该块代码，故只执行一次）
		3. 父类属性对象初始化；
		4. 父类普通代码块；（每次new,每次执行）
		5. 父类构造函数；（每次new,每次执行）
		6. 子类属性对象初始化；
		7. 子类普通代码块；（每次new,每次执行）
		8. 子类构造函数；（每次new,每次执行）
		
		
		
	子类的构造方法总是先调用父类的构造方法，
		如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。
		而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。

		如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。
		如果超类没有不带参数的构造器，并且在子类的构造器中有没有显示地调用超类的其他构造器，则Java编译器将报告错误。
		使用super调用构造器的语句必须是子类构造器的第一条语句。
	
	当类加载时，static静态方法随着类加载而初始化，此时实例对象还未被创建，
	但是非静态成员变量需要等到实例对象创建才会被初始化，故无法被引用。
	
	
	构造方法不需要同步化，
		一个子类可以覆盖掉父类的同步方法，
		定义在接口中的方法默认是 public 的，
		容器保存的是对象的引用，
		构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步。
		如果父类中的某个方法使用了 synchronized 关键字，而子类中也覆盖了这个方法，
		默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。
		当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，
		但子类调用了父类中的同步方法，也就相当子类方法也同步了。

接口：
	接口里面的变量为常量，其实际是 public static final ；
	接口里面的方法为抽象方法，其实际是 public abstract 。
	
子类覆盖父类方法：
	子类覆盖父类方法的问题，也就是方法重写实现多态问题。
		Base b = new Sub();
		它为多态的一种表现形式，声明是 Base，实现是 Sub 类，
		理解为 b 编译时表现为 Base 类特性，运行时表现为 Sub 类特性。
		当子类覆盖了父类的方法后，意思是父类的方法已经被重写。
		题中父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的 baseName 为子类中的私有属性。

	
	
	
	
	

GC 
	
	G1 收集器，基于标记清理。
	
	CMS 收集器：整体上是基于标记整理 ，局部采用复制。
	
	Minor GC：
	Full GC：
	
	PS GC：
		
	复制算法和标记清理算法：最基本的 Java 回收算法
		
		复制算法：
			两个区域 A 和 B，初始对象在 A，继续存活的对象被转移到 B。此为新生代最常用的算法；
		标记清理算法：
			一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法；
		标记-整理算法：
			比标记清理算法多了碎片整理，整理出更大的内存放更大的对象
		
	新生代、年老代和持久代：
		
		新生代：初始对象，生命周期短的；
		年老代：长时间存在的对象；
		持久代：要用于存放静态类型数据。
	
		整个Java 的垃圾回收是新生代和年老代的协作，这种叫做分代回收。
			P.S：
				Serial New收集器是针对新生代的收集器，采用的是复制算法
				Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理
				Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法
				Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理
				Parallel Old（并行）收集器，针对老年代，标记整理
		
		1. 新生代：
			a. 所有对象创建在新生代的 Eden 区，
				当 Eden 区满后触发新生代的 Minor GC，
				将 Eden 区和非空闲 Survivor 区存活的对象复制到另外一个空闲的 Survivor 区中。
			b. 保证一个 Survivor 区是空的，
				新生代 Minor GC 是在两个 Survivor 区之间相互复制存活对象，直到 Survivor 区满为止。
		2. 老年代：
			当 Survivor 区也满了之后就通过 Minor GC 将对象复制到老年代。
			老年代也满了的话，就将触发 Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。
		3. 持久代：
			持久代如果满了，将触发Full GC。
		
	除直接调用 System.gc 外，触发 Full GC 执行的情况有如下四种：
		
		1. 老生代空间不足：		
			旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，
			当执行Full GC后空间仍然不足，则抛出如下错误：
				java.lang.OutOfMemoryError: Java heap space 
			为避免以上两种状况引起的FullGC，调优时应尽量做到：
				让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
		
		2. 持久代（Permanet Generation）空间满：
			PermanetGeneration 中存放的为一些 class 的信息等，
			当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，
			在没有配置成采用 CMS GC 的情况下会执行 Full GC。
			如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
				java.lang.OutOfMemoryError: PermGen space 
			为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
		
		3. CMS GC 时出现 promotion failed 和 concurrent mode failure：
			对于采用CMS进行旧生代GC的程序而言，
			尤其要注意GC日志中是否有 promotion failed 和 concurrent mode failure 两种状况，
			当这两种状况出现时可能会触发Full GC。
				promotionfailed 是在进行 Minor GC 时，
					survivor space 放不下、对象只能放入老生代，
					而此时老生代也放不下造成的；
				concurrent mode failure 是在执行 CMS GC 的过程中，
					同时有对象要放入旧生代，而此时旧生代空间不足造成的。
				应对措施为：增大 survivorspace、旧生代空间或调低触发并发GC的比率，
				但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。
				对于这种状况，可通过设置 -XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。
				
		4. 统计得到的 Minor GC 晋升到老生代的平均大小大于老生代的剩余空间：
			这是一个较为复杂的触发情况，
			Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断，
			如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。
				例如程序第一次触发 MinorGC 后，有 6MB 的对象晋升到旧生代，
				那么当下一次 Minor GC 发生时，首先检查旧生代的剩余空间是否大于 6MB，
				如果小于 6MB，则执行 Full GC。
			当新生代采用 PS GC 时，方式稍有不同，
				PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。
		
		
		
	Java 的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。
		所以 Java 的垃圾收集算法使用的是分代回收。
			一般 Java 的对象首先进入新生代的 Eden 区域，当进行 GC 的时候会回收新生代的区域；
			新生代一般采用复制收集算法，将活着的对象复制到 survivor 区域中。
		如果 survivor 区域装在不下，就查看老生代是否有足够的空间装下新生代中的对象，
		如果能装下就装下，否则老生代就执行 FULL GC 回收自己，
		如果老生代还是装不下，就会抛出 OUtOfMemory 的异常内存泄露问题，
			可能原因：访问资源文件，流不关闭，访问数据库等连接不关闭。
	
	System.gc()：
		其实这个 gc() 函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。
		但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策.	
		释放掉占据的内存空间是由gc完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，
		这取决于GC本身，无法由程序员通过代码控制。
	
	Java 把内存划分成两种：
		一种是栈内存，另一种是堆内存。
			栈内存中分配：在函数中定义的一些基本类型的变量和对象的引用变量；
				当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，
				当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
			数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用；
				但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。
			这也是 Java 比较占内存的原因。
	
	
	
	
	
	
	
	
	
	