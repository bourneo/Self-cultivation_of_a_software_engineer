
基本算法




	简单排序
		冒泡排序：
			从尾开始，相邻元素依次比较，小的移到前面，
			或者，
			从头开始，相邻元素依次比较，大的移在后面。
			时间复杂度：O（n^2）。
				// 数组的冒泡排序
				public void bubbleSort() {
					long tmp = 0;
					for (int i = 0; i < elements - 1; i++) {
						for (int j = elements - 1; j > i; j--) {
							if (arr[j - 1] > arr[j]) {
							tmp = arr[j];
							arr[j] = arr[j - 1];
							arr[j - 1] = tmp;
							}
						}
					}
				}
		选择排序：
			直接选择；
			在无序区选择最小的，依次添加到有序区；
			注意退出条件；
			减少了交换位置的次数。
			需要中间变量来暂存元素。
			时间复杂度：O（n^2）。
				// 数组的选择排序
				public void selectionSort() {
					int k = 0;
					long tmp = 0;
					for (int i = 0; i < elements - 1; i++) {
						k = i;
						for (int j = i; j < elements; j++) {
							if (arr[j] < arr[k]) {
								k = j;
							}
						}
						tmp = arr[i];
						arr[i] = arr[k];
						arr[k] = tmp;
					}
				}
		插入排序：		
			从索引为1一个位置开始，对比左侧的元素，
			小于左侧的元素则从目标数据开始位移，然后交换位置。
			需要中间变量来暂存元素。
			时间复杂度：O（n^2）。
				// 数组的插入排序
				public void insertSort() {
					long tmp = 0;
					for (int i = 1; i < elements; i++) {
						tmp = arr[i];
						int j = i;
						while (j > 0 && arr[j - 1] >= tmp){
							arr[j] = arr[j - 1];
							j--;
						}
						arr[j] = tmp;
					}
				}
			
	递归
		递归 recursion
			先依次传递，然后依次回归。
		斐波拉契数列
			x1=0，x2=1，xn=xn-1+xn-2；
		汉诺塔问题
			HanoiTower
			
	复杂排序
		希尔排序：
			以插入排序为基础
			通过设置间隔，减少位移的次数。
			保证在插入排序之前，右边不会有特别小的数据。
			最大间隔参考：h = 3h + 1；
				h 初始值为 1；h 取不大于数组长度的最大整数。
				如：1，4，13，40，121...
			逐步减少间隔：h = (h-1) / 3；
				public void shellSort() {
					int h = 1;
					while (h < elements / 3) {
						h = h * 3 + 1;
					}
					while (h > 0) {
						long tmp = 0;
						for (int i = h; i < elements; i++) {
							tmp = arr[i];
							int j = i;
							while (j > h - 1 && arr[j - h] >= tmp) {
								arr[j] = arr[j - h];
								j -= h;
							}
							arr[j] = tmp;
						}
						h = (h - 1) / 3;
					}
				}
				
		快速排序：
			将一个数组划分成两个子数组，
			通过递归调用自身来排序；
				需要设定关键字，比关键字小的放左边一组。
				可以设定最右端的数据为关键字。
			核心思想：
				二分法；递归。
			属性：
				左指针：leftPtr；
				右指针：rightPtr；
				左起点：left；
				右起点：right；
				关键字：point；
			// 划分数组
			public static int partition(long arr[], int left, int right, long point) {
				int leftPtr = left - 1;
				int rightPtr = right;
				while (true) {
				// 循环,将比关键字小的留在左端
				while (leftPtr < rightPtr && arr[++leftPtr] < point) ;
				// 循环，将比关键字大的留在右端
				while (rightPtr > leftPtr && arr[--rightPtr] > point) ;
				if (leftPtr >= rightPtr) {
					break;
				} else {
					long tmp = arr[leftPtr];
					arr[leftPtr] = arr[rightPtr];
					arr[rightPtr] = tmp;
				}
				}
				// 将关键字和当前 leftPtr 所指的这一个进行交换
				long tmp = arr[leftPtr];
				arr[leftPtr] = arr[right];
				arr[right] = tmp;
				return leftPtr;
			}
			public static void quickSort(long[] arr, int left, int right) {
				if (left - right  >= 0) {
				return;
				} else {
				// 设置关键字
				long point = arr[right];
				// 获得切入点，同时对数组进行划分
				int partition = partition(arr, left, right, point);
				// 对左边的子数组进行快速排序
				quickSort(arr, left, partition - 1);
				// 对右边的子数组进行快速排序
				quickSort(arr, partition + 1, right);
				}
			}
			
	树
		基本概念：
			有序数组增删数据慢；
			链表改查数据慢；
			属性：
				结点；根结点，父结点，子结点，叶子结点，
				路径：边；
				子树：每个结点都可以作为一个子树的根。
				深度：层；
				访问结点：
					在结点上进行了一些操作；
					不同于经过结点；
		二叉树：
			树的每个结点最多只有两个子结点的树。
			属性：
				结点：
					数据：data；一个结点可以存储多个数据。
					左子结点：leftChild；
					右子结点：rightChild；
				树：
					根结点：root；
					
		遍历二叉树：
			根据特定的顺序访问每一个结点；
			前序遍历：
				访问根结点；
				前序遍历左子树；
				前序遍历右子树。
			中序遍历：
				中序遍历左子树；
					画图：最左最小子树的左叶子结点开始。
				访问根结点；
				中序遍历右子树。
			后序遍历：
				后序遍历左子树；
				后序遍历右子树；
				访问根结点。
		前序，中序，后序可以理解为根的位置。
			都是先左子树再右子树，根节点的遍历顺序决定遍历的顺序。
		删除二叉树结点：
			首先找到要删除的结点；
				参考查找二叉树结点。
			如果要删除的结点是叶子结点；
				判断是否是左结点，然后把父结点引用设为空。
			如果要删除的结点只有左子树或者右子树；
				判断是否是左结点，
				然后把左子树或者右子树的根结点
				赋值给父结点。
			如果要删除的结点有左子树和右子树。
				把后序中继结点赋值给要删除的结点；
					如果右子树根结点没有左子树；
						右子树的根结点赋给父结点的右子结点。
					如果右子树根结点有左子树；
						循环遍历左子树的左子树。
				如果中继结点不是要删除结点的右子结点；
					记得把中继结点的右结点赋值给
						中继结点父结点的左子结点。
				把找到的中继结点赋值给父结点的子结点；
					需要盘算是父结点的左子还是右子。
				把要删除结点的子结点赋值给中继结点的子结点。
			
		红黑树：
			二叉树：
				插入随机数据有优势；
				但是插入有序的数据，会变得特别慢。
			平衡树：
				用二叉树插入随机的数据；
			非平衡树：
				用二叉树插入有序的数据。
			红黑规则：
				每个结点不是红色就是黑色；
				根总是黑色的；
				如果结点是红色的，那么子结点必须是黑色；
				根结点到叶子结点的每条路径，
					必须包含相同数目的黑色结点。
			纠正规则：
				改变结点的颜色；
				执行旋转操作。
			
	图
		基本概念：
			邻接
				如果两个顶点被同一条边连接，则这两个顶点邻接。
			路径
				从一个顶点到另一个顶点经过的边的序列。
			连通图
				至少有一条路径可以连接所有的顶点。
				反之就是非连通图。
			有向图
				边有方向图，有方向的边被称为弧。
			带权图
				边被赋予权值的图。
		图的属性：
			顶点
				顶点数组；
				顶点标识。
			邻接
				邻接表：数组链表；
				矩阵：n x n 矩阵表示是否邻接。
		图的搜索：
				从一个指定顶点可以到达哪些顶点。
			分类：
				深度优先搜索；
					DepthFirstSearch；DFS
				广度优先搜索。
					BreadthFirstSearch；BFS
			深度优先搜索规则：
				访问一个未访问过的邻接点，标记后放入栈中；
				如果找不到未访问过的邻接点，
					则从栈中弹出一个顶点；
				如果在找不到未访问过的顶点，栈中也没有顶点，
					则完成整个搜索。
			广度优先搜索规则：
				访问下一个未访问过的邻接点，
					标记并插入到队列中；
				如果如果找不到未访问过的邻接点，
					就从队列头取出一个顶点；
				如果在找不到未访问过的顶点，队列中也没有顶点，
					则完成整个搜索。
		图的最小生成树：
			最小生成树
				连接每个顶点最小的连线数；
				最小生成树边的数量总是比顶点数量少 1。
			深度优先；
			广度优先；
		
		
0      1      2     3   
34，32，09，78


