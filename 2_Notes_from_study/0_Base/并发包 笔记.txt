
JUC 并发包 笔记



	JUC (Java Util Concurrency)：Java 并发工具包；
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	Java JUC包的主体结构：
		Atomic : AtomicInteger
		Locks : Lock, Condition, ReadWriteLock
		Collections : Queue, ConcurrentMap
		Executer : Future, Callable, Executor
		Tools : CountDownLatch, CyclicBarrier, Semaphore		
		
		
		
		
		
	AQS (AbstractQueuedSynchronizer)：抽象队列同步；
		AQS 类是锁机制实现的核心所在；是独占锁(如：ReentrantLock)和共享锁(如：Semaphore)的公共父类。
		
		AQS 锁的分类：
			独占锁：锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。
				公平锁，是按照通过CLH等待线程按照先来先得的规则，公平的获取锁；
				而非公平锁，则当线程要获取锁时，它会无视CLH等待队列而直接获取锁。
				独占锁的典型实例子是ReentrantLock，此外，ReentrantReadWriteLock.WriteLock也是独占锁。
			共享锁：能被多个线程同时拥有，能被共享的锁。
				JUC包中的 ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch 和 Semaphore 都是共享锁。
		
		
		
	CLH 队列 (Craig, Landin, and Hagersten lock queue)：
		CLH 队列是A QS 中等待锁的线程队列。
		在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。
		在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。
		CLH 就是管理这些等待锁的线程的队列。
		CLH 是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，
		而是通过自旋锁和 CAS 保证节点插入和移除的原子性。
		
		
		
		
	CAS (Compare and Swap)：比较和交换函数；
		CAS 是原子操作函数；通过 CAS 操作的数据都是以原子方式进行的。
		比如：compareAndSetHead(), compareAndSetTail(), compareAndSetNext() 等函数。
		它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。
	
	
	
	
	
	
	
	
	volatile：
		volatile 实现了类似synchronized的语义，却又没有锁机制。
		它确保对 volatile 修饰的字段更新以可预见的方式告知其他的线程。
		
		Java 存储模型不会对volatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。
		volatile变量不会被缓存在寄存器中（只有拥有线程可见），每次总是从主存中读取volatile变量的结果。
			ps：volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性。
	
	Lock 锁：
		Synchronized 属于独占锁，高并发时性能不高，JDK5 以后开始用JNI实现更高效的锁操作。
	
	
	
		ReentrantLock 是一个可重入的互斥锁，又被称为“独占锁”。
	
		ReentrantLock分为“公平锁”和“非公平锁”：
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	