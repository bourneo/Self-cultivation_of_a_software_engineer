
JUC 并发包 笔记



	JUC (Java Util Concurrency)：Java 并发工具包；
		
		ConcurrentHashMap：
			引入了一个“分段锁”的概念，
				具体可以理解为把一个大的Map拆分成N个小的HashTable，
				根据key.hashCode()来决定把key放到哪个HashTable中。
			把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。
				默认是把 segments 初始化为长度为16的数组。
			操作相同的 segments 才会阻塞，操作不同的 segments 就不会阻塞；
				所以通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，
				但是效率提升N倍，默认提升16倍。
			
		synchronized 最主要有以下3种应用方式：
			修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
			修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
			修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	Java JUC 包的主体结构：
		Atomic : AtomicInteger
		Locks : Lock, Condition, ReadWriteLock
		Collections : Queue, ConcurrentMap
		Executer : Future, Callable, Executor
		Tools : CountDownLatch, CyclicBarrier, Semaphore		
		
		
		
		
		
	AQS (AbstractQueuedSynchronizer)：抽象队列同步；
		AQS 类是锁机制实现的核心所在；是独占锁 (如：ReentrantLock) 和共享锁 (如：Semaphore) 的公共父类。
		
		AQS 锁的分类：
			独占锁：锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。
				公平锁，是按照通过 CLH 等待线程按照先来先得的规则，公平的获取锁；
				而非公平锁，则当线程要获取锁时，它会无视 CLH 等待队列而直接获取锁。
				独占锁的典型实例子是 ReentrantLock，此外，ReentrantReadWriteLock.WriteLock 也是独占锁。
			共享锁：能被多个线程同时拥有，能被共享的锁。
				JUC 包中的 ReentrantReadWriteLock.ReadLock，CyclicBarrier，CountDownLatch 和 Semaphore 都是共享锁。
		
		
		
	CLH 队列 (Craig, Landin, and Hagersten lock queue)：
		CLH 队列是 A QS 中等待锁的线程队列。
		在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。
		在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。
		CLH 就是管理这些等待锁的线程的队列。
		CLH 是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，
		而是通过自旋锁和 CAS 保证节点插入和移除的原子性。
		
		
		
		
	CAS (Compare and Swap)：比较和交换函数；
		CAS 是原子操作函数；通过 CAS 操作的数据都是以原子方式进行的。
		比如：compareAndSetHead(), compareAndSetTail(), compareAndSetNext() 等函数。
		它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。
	
	
	
	
	
	
	
	
	volatile：
		volatile 实现了类似 synchronized 的语义，却又没有锁机制。
		它确保对 volatile 修饰的字段更新以可预见的方式告知其他的线程。
		
		Java 存储模型不会对 volatile 指令的操作进行重排序：这个保证对 volatile 变量的操作时按照指令的出现顺序执行的。
		volatile 变量不会被缓存在寄存器中 (只有拥有线程可见) ，每次总是从主存中读取 volatile 变量的结果。
			ps：volatile 并不能保证线程安全的，也就是说 volatile 字段的操作不是原子性的，volatile 变量只能保证可见性。
	
	Lock 锁：
		Synchronized 属于独占锁，高并发时性能不高，JDK5 以后开始用 JNI 实现更高效的锁操作。
		ReentrantLock 是一个可重入的互斥锁，又被称为“独占锁”。
		ReentrantLock 分为“公平锁”和“非公平锁”：
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	