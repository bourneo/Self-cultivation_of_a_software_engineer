
常用设计模式




设计模式简介
	模式：是某类问题的通用设计解决方案；
	目的：使软件在维护性、拓展性、变化性、复杂度成 O(N)。
	
常用设计模式
	策略
	
	观察者
	
	
	
	
	
	
	
	
		
结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。
	故可以分为 类结构模式 和 对象结构模式。

在 GoF 设计模式中，结构型模式有：
	1. 适配器模式 Adapter
	适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。

	2. 桥接模式 Bridge
	桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。

	3. 组合模式 Composite
	组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

	4. 装饰模式 Decorator
	装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。

	5. 外观模式 Facade
	外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
	外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。

	6. 享元模式 Flyweight
	享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。
	享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。

	7. 代理模式 Proxy
	为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。
	
	
	
	
	
	
常用设计模式

	策略模式
		策略模式：
			把行为封装成接口，形成行为族。
			行为接口对象放在父类，
				子类实现具体的行为对象。
			让行为方法的变化独立于使用者。
		案例：
			鸭子及其行为。
		继承的问题：
			对超类局部的改动，会影响其他部分；
			影响有溢出效应。
		使用原则：
			分离变化的部分，封装成接口。
		注意点：
			分析项目比赛变化的部分，不变化的部分。
			多用组合，少用继承；
				用行为类的组合，而不是行为的继承。
		
	观察者模式
		观察者模式
			是对象之间多对一依赖的一种设计方案；
			Subject：被依赖的对象；
			Obsever：依赖的对象；
			Subject 通知 Obsever 变化。
		案例：
			气象站的天气数据服务。
		好比订外卖
			Subject：外卖平台；
				可以登记注册或者移除通知。
			Obsever：用户；接受数据。
		松耦合
			模块交互但是不相互依赖。
		高内聚
			模块内部功能集中。
		
	装饰者模式
		装饰者模式
			动态的将新功能附加到对象上；
			在对象功能拓展放面，比继承更有弹性。
		案例：
			咖啡店的饮品和调料价格。
		结构
			Component；
			ConcreteComponent；
			ConcreteDecorator；
			Decorator。
		开放-关闭原则
			对添加新功能是开放的；
			对原有功能进行修改是关闭的。
		
	单例模式
		单例模式
			确保一个类最多只有一个实例；
			并提供一个全局访问点。
		实现方式
			私有构造器，保证外部类的 new 不奏效；
			然后在类里面 new 一个实例；
			然后静态 get 方法返回该实例，供全局调用。
		案例：
			巧克力工厂。
		单例类
			private static Single uniqueInstance=null;
			private Single(){};
			public static Single getInstance(){
				if(uniqueInstance==null){
					uniqueInstance=new Single();
				}
				return uniqueInstance;
			}
		经典单例模式
			需求：线程池、缓存、打印机；
			多个实例有可能造成冲突，结果不一致。
			可以使用静态变量、全局变量实现替代。
		经典单例模式的优化
			同步锁解决多线程问题
			使用 getInstance 频率少，性能要求低的情况。
			private static Single uniqueInstance = null;
			private Single(){};
			public static synchronized Single getInstance(){
				if(uniqueInstance == null){
					uniqueInstance=new Single();
				}
				return uniqueInstance;
			}
			急切创建线程
			不需要再进入同步锁；
			private static Single uniqueInstance = new Single;
			双重检查加锁
			同步锁只需要进入一次。
			private volatile static Single uniqueInstance = null;
			private Single(){};
			public static synchronized Single getInstance(){
				if(uniqueInstance == null){
				synchronized (Single.class){
					if(uniqueInstance == null){
						uniqueInstance=new Single();
					}
				}
				)
				return uniqueInstance;
			}

	工厂模式
		简单工厂模式
			把创建对象的代码抽离出来作为简单的工厂类。
			定义一个创建对象的类，用来封装实例化对象。
		工厂方法模式
			把创建对象的代码抽离出来，放到子类中。
			在抽象类中，定义一个创建对象的抽象方法，
			由子类决定要实例化的类。
			将对象的实例化推迟到子类。
		抽象工厂模式
			把创建对象的代码抽离出来，
			变成一个接口和一个实现类。
			定义一个工厂接口，
			用于创建相关的或者有依赖关系的对象族，
			无需明确指定具体的类。
			由实现工厂去指定具体的类。
		案例：
			披萨连锁店。
		依赖抽象原则：
			变量不要持有具体类的引用；
			不要让类继承自具体类，
			要继承自抽象类或接口；
			不要覆盖超类中已经实现的方法。
		
	命令模式
		命令模式
			将请求、命令、动作等，封装成对象；
			可以让项目使用该对象来参数化其他对象。
			使命令的请求者和执行者解耦。
		案例：
			遥控器控制家电。
		策略模式和命令模式
			策略模式：
				创建行为接口，实现类来实现具体行为；
			命令模式：
				将命令抽象成接口，
				将具体的命令抽象成实现接口的类。
				
	适配器模式
		对象适配器
			用户调用适配器转化出来的目标接口方法；
			适配器再调用被适配者的相关接口方法。
			把一种接口，转换成另一种接口；
			让原本接口不兼容的类可以兼容。
		类适配器
			通过多重继承目标接口和被适配者类来实现。
				继承目标接口达到适配的目的；
				继承被适配者类，
				达到通过调用被适配者类里的方法，
				来实现目标接口的功能。
		区别：
			使用不同的方法实现适配，
			对象适配器使用组合；
			类适配器使用继承。
		案例：
			用火鸡适配器扮演鸭子的功能。
			火鸡适配器实现了鸭子接口，所以类型是鸭子，
			但实现方法里面调用了火鸡的方法。
		枚举器和迭代器的适配
			用迭代器接口，
			创建枚举适配器，
			重载的是迭代器的方法，
			方法里面调用枚举器方法，
			来实现枚举器的功能。
		装饰者和适配器的差别
			装饰者模式中，
			被装饰者和装饰后的对象都属于同一个类族；
			添加了新的功能，但是没有进行接口转换。
			适配器模式中，
			实现的目标接口和被适配者，不是同一个接口。
			把被适配者接口，转换成了目标接口。
		
	外观模式
		外观模式
			提供一个统一的接口，
			来访问子系统中一群功能相关接口。
			中间加一层接口用来包装一些方法。
			定义一个高层接口，让子系统更容易使用。
		最少知识原则
			尽量减少对象之间的交互，只留几个密友。
		对象调用的范围
			该对象本身；
			作为参数传进来的对象；
			此方法创建和实例化的对象；
			对象的组件。
		案例：
			家庭影院的控制。
		
	模板模式
		模板模式
			抽象类封装一个算法步骤，
			允许子类为一个或者多个步骤方法提供实现；
			可以使子类在不改变算法结构的情况下，
			重新定义算法中的某些步骤。
		案例：
			泡茶和泡咖啡。
		好莱坞原则：
			别调用我们，我们会调用你。
		
	迭代器模式
		迭代器模式：
			提供一种方法顺序，
			访问一个聚合对象中的各个对象。
			遍历目标类创建内部迭代器类，
			实现迭代器接口；
			提供 get 方法，供外部调用。
			ArrayList 内置了迭代器。
		案例：
			蛋糕店和餐厅，统一管理菜单项目。
		单一责任原则：
			一个类应该只有一个引起变化的原因
		
	组合模式
		组合模式
			创建一个抽象组合类，
			组件都继承抽象类，
			
			将对象聚合成树形结构，
			来表现整体和部分的层次结构；
			让客户以一致的方式来处理个别对象/对象组合，
			忽略对象组合与个体对象之间的差别。
		案例：
			遍历蛋糕菜单、餐厅菜单、及其甜点子菜单。
		拓扑结构：
			树形结构。
			
	状态模式
		状态模式
			把状态抽象成一个接口，
			然后把各种状态抽象成实现接口的类。
			根据内部状态的变化，改变对象的行为，
			看起来好像修改了类。
		案例：
			糖果机，再来一颗活动。
		策略模式、状态模式、模板模式：
			策略模式：动作抽象成类族；
			状态模式：每一状态下的动作能完成；
			模板模式：每一动作都是流程的一部分。
		
	代理模式
		远程代理：
			远程对象的本地代表，
			通过它可以让远程对象当本地对象来调用。
			远程代理通过网络和真正的远程对象沟通信息。
		代理模式
			为对象提供一个替身，以控制对对象的访问；
			被对象的对象可以是远程对象，
				创建开销大的对象，
				或者需要安全控制的对象；
			代理模式由很多变体，
				都是为了控制与管理对象访问。
		案例：
			远程糖果机监控。
		代理模式分类
			虚拟代理
				为创建开销大的对象提供代理服务。
				真正的对象在创建前和创建中时，
					由虚拟代理来扮演替身。
				如：Android 的在线图片加载类。
			动态代理
				运行时动态的创建代理类的对象，
				并将方法调用转发到指定类。
				案例：约会服务系统。
			保护代理
				类似中介。
			几种变体
				防火墙代理；
				缓存代理；
				智能引用代理；
				同步代理；
				写入时复制代理。
		Java RMI：
			远程方法调用：
				计算机之间通过网络实现对象调用，
				的一种通讯机制。
			一台计算机上的对象，
				可以调用另外一台计算机上的对象，
				来获取远程数据。
			RPC：
				面向过程的开发，基于 TCP/IP。
				使调用远程更容易；
				面对复杂信息传讯，支持不太好。
			RMI：
				面向对象的开发。
			开发步骤：
				制作远程接口：接口文件；
				远程接口的实现：Service 文件；
				RMI 服务端注册，开启服务；
				RMI 代理端，通脱 RMI 查询到服务端，
				建立联系，通过接口调用远程方法。
		装饰者模式和代理模式
			装饰者装饰以后会增加新功能；
			代理模式是对目标对象访问的控制和管理；
			不增加功能，甚至会削减功能。
		
	复合模式
		复合模式
			模式常一起使用，组合在一个设计解决方案中；
			复合模式在一个解决方案中结合两个或多个模式，
			能解决一般性或一系列的问题。
			某些模式结合使用，并不就是复合模式。
		案例：
			复杂鸭子项目：
				多种鸭子，不同鸭子叫声、飞行、游泳方式不同--策略模式
				鹅，需要加入几只普通的鹅--适配器模式
				要统计鸭子叫声的次数--装饰者模式
				统一产生鸭子--工厂模式
				要管理一群鸭子--组合模式 (迭代器) 
				追踪某个鸭子的行为--观察者模式
		MVC 复合模式
			MVC： Model、 View 、 Controller。
			Model：是程序主体，代表了业务数据和业务逻辑；
			View ：是与用户交互的界面，显示数据、接收输入，但不参与实际业务逻辑；
			Controller：接收用户输入，并解析反馈给 Model。
		MVC 里的模式：
			Model 与 View 和 Controller 是观察者模式；
			View 以组合模式管理控件；
			View 与 Controller 是策略模式关系，Controller 提供策略。
		案例：
			Android App：
				生命周期--模板模式
				整体上是 MVC
				广播--观察者
				列表 View--模板
		
	桥接模式
		桥接模式
			将实现与抽象放在两个不同的类层次中，
			使两个层次可以独立改变。
		案例：
			万能遥控器。
		适用：
			系统有多维角度分类时，
			而每一种分类又有可能变化，
			考虑使用桥接模式。
			桥接的目的是分离抽象与实现，
			使抽象和实现可以独立变化。
		桥接模式与策略模式
			桥接的目的
				让底层实现和上层接口可以分别演化，
				从而提高移植性；
			策略的目的
				将复杂的算法封装起来，
				从而便于替换不同的算法。
			桥接模式是往往是为了利用已有的方法或类；
			策略模式是为了扩展和修改，并提供动态配置。
			桥接模式强调接口对象仅提供基本操作；
			策略模式强调接口对象提供的是一种算法。

	生成器模式
		生成器模式
			封装一个复杂对象构造过程，
			并允许按步骤构造。
		优点：
			将复杂对象的创建过程封装起来；
			允许对象通过几个步骤来创建，
				并且可以改变过程
				 (工厂模式只有一个步骤) ；
			只需指定具体生成器就能生成特定对象，
				隐藏类的内部结构；
			对象的实现可以被替换。
		案例：
			度假计划生成。
		演化形式
			省略抽象生成器类；
			省略指导者类。
		生成器模式和抽象工厂模式区别：
			生成器一般用来创建大的复杂的对象；
			生成器模式强调的是一步步创建对象，
				可以改变步骤来生成不同的对象；
			一般来说生成器模式中对象不直接返回。
		
	责任链模式
		责任链模式
			如果有多个对象都有机会处理请求，
			责任链可使请求的发送者和接收者解耦，
			请求沿着责任链传递，
			直到有一个对象处理了它为止。
		案例：
			购买请求决策项目。
		优点：
			 将请求的发送者和接收者解耦，
				使多个对象都有机会处理这个请求；
			 可以简化对象，因为它无须知道链的结构；
			 可以动态地增加或删减处理请求的链结构。
		缺点：
			 请求从链的开头进行遍历，对性能有一定的损耗
			 并不保证请求一定被处理。
		适用场合：
			有多个对象可以处理一个请求
			不明确接收者的情况
			有序、无序链，线型、树形、环形链
		责任链模式和状态模式：
			 责任链模式注重请求的传递
			 状态模式注重对象状态的转换
		
	蝇量模式
		蝇量模式 (享元模式) 
			通过共享的方式高效地支持大量细粒度的对象。
		案例：
			景观设计软件，新建百万棵树、百万棵草。
		优点：
			减少运行时的对象实例个数，
			节省创建开销和内存；
			将许多“虚拟”对象的状态集中管理。
		缺点：
			系统设计更加复杂；
			需要专门维护对象的外部状态。
		适用场合：
			需要大量细粒度对象；
			这些对象的外部状态不多；
			按照内部状态分成几个组，
			每一个组都仅用一个蝇量对象代替。
		
	解释器模式
		解释器模式
			定义一个语法, 定义一个解释器，
			该解释器处理该语法句子；
			将某些复杂问题，表达为某种语法规则，
			然后构建解释器来解释处理这类句子。
		案例：
			大数据统计项目。
		优点：
			容易修改，
			修改语法规则只要修改相应非终结符即可；
			扩展方便，
			扩展语法，只要增加非终结符类即可。
		缺点：
			对于复杂语法的表示会产生复杂的类层次结构，
			不便管理和维护；
			解释器采用递归方式，效率会受影响。
		注意事项：
			尽量不要在重要的模块中使用解释器模式；
			解释器模式在实际的系统开发中使用的非常少；
			可以考虑一下 Expression4J、MESP、Jep 等
			开源的解析工具包。
		适用场合：
			当你有一个简单语法，
			而且效率不是问题的时候；
			一些数据分析工具、报表设计工具、
			科学计算工具等。
		
		
	中介者模式
		中介者模式：
			用一个中介对象来封装一系列的对象交互。
			中介者使各对象不需要显式地相互引用，
			从而使其耦合松散，
			而且可以独立地改变它们之间的交互。
		案例：
			智慧家具项目。
		优点：
			通过将对象彼此解耦，可以增加对象的复用性；
			通过将控制逻辑集中，可以简化系统维护；
			可以让对象之间所传递的消息，
			变得简单而且大幅减少；
			提高系统的灵活性，使得系统易于扩展和维护。
		缺点：
			中介者承担了较多的责任，
			一旦中介者出现了问题，
			整个系统就会受到影响；
			如果设计不当，中介者对象本身变得过于复杂。
		适用场合：
			一组对象之间的通信方式比较复杂，
			导致相互依赖，结构混乱；
			一个对象引用很多其他对象，
			并直接与这些对象通信，导致难以复用该对象。
		中介者模式和外观模式
			中介者是内部之间通信，通过中介者简化；
			外观模式是子系统向外暴露方法或接口，
			简单包装简化操作。
		中介者模式和观察者模式
			中介者通信是定向的；
			观察者通信方式是广播。
		
	备忘录模式
		备忘录模式：
			在不破坏封装的前提下，
			存储关键对象的重要状态，
			从而可以在将来把对象还原到存储的那个状态。
		案例：
			游戏进度状态保存问题。
		优点：
			状态存储在外面，不和关键对象混在一起，
			这可以帮助维护内聚；
			提供了容易实现的恢复能力；
			保持了关键对象的数据封装。
		缺点：
			资源消耗上面备忘录对象会很昂贵；
			存储和恢复状态的过程比较耗时。
		适用场合：
			必须保存一个对象，
			在某一个时刻的 (整体或部分) 状态，
			在对象以外的地方, 以后需要时恢复到先前的状态时。

	原型模式
		原型模式：
			通过复制现有实例来创建新的实例，
			无须知道相应类的信息
		案例：
			邮件批量发送电子账单项目。
		优点：
			使用原型模式创建对象
			比直接 new 一个对象更有效；
			隐藏制造新实例的复杂性；
			重复地创建相似对象时可以考虑使用原型模式。
		缺点：
			每一个类必须配备一个克隆方法；
			深层复制比较复杂。
		适用场合：
			复制对象的结构与数据
			希望对目标对象的修改不影响既有的原型对象
			创建对象成本较大的情况下		
		注意事项：
			使用原型模式复制对象不会调用类的构造方法。
			所以，单例模式与原型模式是冲突的，
			在使用时要特别注意。
			Object 类的 clone 方法
			只会拷贝对象中的基本的数据类型，
			对于数组、容器对象、引用对象等都不会拷贝，
			也就是浅拷贝。
			 (浅拷贝：只拷贝地址，不拷贝内存中内容。) 
			如果要实现深拷贝，
			必须将原型模式中的数组、
			容器对象、引用对象等另行拷贝。

	访问者模式
		访问者模式：
			对于一组对象，在不改变数据结构的前提下，
			增加作用于这些结构元素新的功能。
			适用于数据结构相对稳定，
			它把数据结构和作用于其上的操作解耦，
			使得操作集合可以相对自由地演化。
		案例：
			雇员管理系统。
		优点：
			符合单一职责原则；
			扩展性良好；
			有益于系统的管理和维护。
		缺点：
			增加新的元素类变得很困难；
			破坏封装性。
		注意事项：
			系统有比较稳定的数据结构；
			与迭代器的关系。
		适用场合：
			如果一个系统有比较稳定的数据结构，
			又有经常变化的功能需求，
			那么访问者模式就是比较合适的。
		访问者模式和迭代器模式
			访问者强调访问对象之后进行处理；
			迭代器强调遍历对象。
			
	设计模式总结
		三个分类
			创建型模式：
				对象实例化的模式，
				创建型模式解耦了对象的实例化过程。
			结构型模式：
				把类或对象结合在一起形成更大的结构。
			行为型模式：
				类和对象如何交互，及划分责任和算法。
		创建型
			简单工厂：
				一个工厂类根据传入的参量决定创建出哪一种产品类的实例。
			工厂方法：
				定义一个创建对象的接口，让子类决定实例化哪一个类。
			抽象工厂：
				创建相关或依赖对象的家族，而无需明确指定具体类。
			单例模式：
				某个类只能有一个实例，提供一个全局访问点。
			生成器模式：
				封装一个复杂对象的构建过程，并可以按步骤构造。
			原型模式：
				通过复制现有的实例来创建新的实例。
		结构型
			适配器模式：
				将一个类的方法接口转换成客户希望的另外一个接口。
			组合模式：
				将对象组合成树形结构以表示“部分-整体”的层次结构。
			装饰模式：
				动态地给对象添加新的功能。
			代理模式：
				为其他对象提供一个代理以控制对这个对象的访问。
			蝇量模式：
				通过共享技术有效地支持大量细粒度的对象。
			外观模式：
				提供统一的方法来访问子系统的一群接口。
			桥接模式：
				将抽象部分与它的实现部分分离，使它们都可以独立地变化。
		行为型
			模板模式：
				定义一个算法结构，而将一些步骤延迟到子类中实现。
			解释器模式：
				给定一个语言，定义它的文法的一种表示，并定义一个解释器。
			策略模式：
				定义一系列的算法，把它们封装起来，并且使它们可相互替换。
			状态模式：
				允许一个对象在其内部状态改变时改变它的行为。
			观察者模式：
				对象间的一对多的依赖关系。
			备忘录模式：
				在不破坏封装性的前提下，保存对象的内部状态。
			中介者模式：
				用一个中介对象来封装一系列的对象交互。
			命令模式：
				将命令请求封装为一个对象，使得可用不同的请求来进行参数化。
			访问者模式：
				在不改变数据结构的前提下，增加作用于一组对象元素新的功能。
			责任链：
				请求发送者和接收者之间解耦，使的多个对象都有机会处理这个请求。
			迭代器：
				一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
		对象设计六大原则
			组合复用原则
				多用组合，少用继承；
				找到变化部分，抽象，封装变化；
				区分“Has-A”与“Is-A”。
			依赖倒置原则
				依赖：成员变量、方法参数、返回值
				要依赖于抽象，不要依赖于具体
				高层模块不应该依赖低层模块，二者都应该依赖其抽象
				抽象不应该依赖具体，具体应该依赖抽象
				针对接口编程，不要针对实现编程
				以抽象为基础搭建的结构比具体类搭建的结构要稳定的多
				在 java 中，抽象指的是接口或者抽象类，具体就是具体的实现类
			开闭原则
				对扩展开放，对修改关闭
				通过扩展已有软件系统，可以提供新的功能
				修改的关闭，保证稳定性和延续性
			迪米特法则
				一个对象应该与其他对象保持最少的了解。只与直接朋友交谈。
				成员变量、方法参数、方法返回值中需要的类为直接朋友
				类与类之间的关系越密切了解越多，耦合度越大
				尽量降低类与类之间的耦合
				外观模式、中介者模式
				接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上
			里氏替换原则
				所有引用基类的地方必须能透明地使用其子类对象
				子类在扩展父类功能时不能破坏父类原有的功能
				使用继承时，遵循里氏替换原则：
				子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
				当子类重载父类方法时，方法的形参要比父类方法的参数更宽松
				当子类实现父类的抽象方法时，方法的返回值要比父类更严格
				里氏替换原则是设计整个继承体系的原则
			单一职责原则
				类应该只有一个导致类变更的理由
				即一个类只负责一项职责
				降低类的复杂度
				提高系统的可维护性
				修改时降低风险溢出
		
		
	