

关键字简析


缩写名词：

	Javac (JavaCompilation)：Java 编译器；
		Java 编译程序读取 Java 源代码，并将其编译成字节代码。
		javac 可以隐式编译一些没有在命令行中提及的源文件。
		
	JVM (JavaVirtualMachine)：Java 虚拟机；
		JVM 是可运行 Java 代码的假想计算机，
		只要根据 JVM 规格描述将解释器移植到特定的计算机上，就能保证经过编译的任何 Java 代码能够在该系统上运行。
		Java 虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。
	
	JRE (Java Runtime Environment)：Java 运行环境；
		运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。
		
	JDK (Java Development Kit)：Java 软件开发的工具包；
		JDK 是整个 Java 的核心，包括了 Java 运行环境、Java 工具和 Java 基础类库。
		
	SDK (Software Development Kit)：软件开发工具包。
		
	HotSpot：HotSpot 虚拟机；
		2006 年底开源，主要使用 C++ 实现，JNI 接口部分用 C 实现。
			HotSpot 是较新的 Java 虚拟机，用来代替 JIT (Just in Time)，可以大大提高 Java 运行的性能。
		Java 原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。
		HotSpot 将常用的部分代码编译为本地 (原生，native) 代码，这样显着提高了性能。
	
	JIT (just in time)：即时编译技术；
		使用该技术，能够加速 java 程序的执行速度。
		当 JIT 编译启用时 (默认是启用的)，JVM 读入.class 文件解释后，将其发给 JIT 编译器。
		JIT 编译器将字节码编译成本机机器代码。
		JIT 对每条字节码都进行编译，会造成编译过程负担过重。
		为了避免这种情况，JIT 只对经常执行的字节码进行编译，如循环等。
	
	JNI (Java Native Interface)：Java 本地接口；
		JNI 是 JAVA 平台的一部分，允许 Java 代码和其他语言写的代码进行交互。
		JNI 一开始是为本地已编译语言，尤其是 C 和 C++ 而设计的，但并不妨碍使用其他语言，只要调用约定受支持。
	
	JUC (Java Util Concurrency)：Java 并发工具包；
		
		
	CAS (Compare and Swap)：比较和转换操作；
		
		
	AQS (AbstractQueuedSynchronizer)：抽象队列同步；
		锁机制实现的核心所在。
		
		
		
		
	IO ：I/O；输入 / 输出；
		指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口，
			是主存和外部设备 (硬盘、终端和网络等) 拷贝数据的过程。
		IO 是操作系统的底层功能实现，底层通过 I/O 指令进行完成。
			它对于任何计算机系统都非常关键，因而 I/O 的主体实际上是内置在操作系统中的。
		在 Java 编程中，直到最近一直使用流的方式完成 I/O。
			所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。
			流 I/O 用于与外部世界接触，它也在内部使用，用于将对象转换为字节，然后再转换回对象。
	NIO：NIO 库；
		在标准 Java 代码中提供高速的、面向块的 I/O，弥补原来 I/O 的不足，块 I/O 的效率可以比流 I/O 高许多。
		NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。
		NIO 将最耗时的 I/O 操作 (即填充和提取缓冲区) 转移回操作系统，因而可以极大地提高速度。
		通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。
	
	SQL (Structured Query Language)：结构化查询语言；
		是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；
		也是数据库脚本文件的扩展名。
	
	RPC ((Remote Procedure Call)：远程过程调用；
		通过作用在共享数据缓存器上的过程 (或任务) 实现程序间的通信。

	POJO：Plain Old Java Object。
		指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的 java 对象。


	Iaas (Infrastructure as a Servic)：基础设施即服务；
		给你虚拟机。
		
	Paas (Platform-as-a-Service)：平台即服务；
		给你 api，比如 amazon 的对象存储 api。
		
	Saas (Software-as-a-Service)：软件即服务；
		给你一套软件，比如销售管理系统，但是运行在卖方的云上，而不是你公司内网的服务器上，比如 salesforce。

	catalina：Tomcat 服务器使用的 Apache 实现的 servlet 容器的名字。
		Tomcat 的核心分为 3 个部分：
			Web 容器：处理静态页面；
			catalina：一个 servlet 容器，处理 servlet;
			JSP 容器：把 jsp 页面翻译成一般的 servlet。
	
	
		
	
	
	
	
	
	
	
	
	
	
	
Java 关键字：
static：
static 表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态 static 代码块；
但是 Java 语言中没有全局变量的概念。
被 static 修饰的成员变量和成员方法独立于该类的任何对象。它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java 虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static 对象可以在它的任何对象创建之前访问，无需引用任何对象。
用 public 修饰的 static 成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成 static 变量的副本，而是类的所有实例共享同一个 static 变量。
static 变量前可以有 private 修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用 (当然也可以在非静态成员方法中使用)，但是不能在其他类中通过类名来直接引用。private 是访问权限限定，static 表示不要实例化就可以使用。static 前面加上其它访问权限关键字的效果也以此类推。
static 修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：
类名. 静态方法名 (参数列表...)
类名. 静态变量名
用 static 修饰的代码块表示静态代码块，当 Java 虚拟机 (JVM) 加载类时，就会执行该代码块。
static 的作用：
static 方法就是没有 this 的方法。
static 方法内部不能调用非静态方法，反过来也成立。static 不允许用来修饰局部变量。
static 方法的主要用途：可以在没有创建任何对象的前提下，仅仅通过类本身来调用 static 方法。方便在没有创建对象的情况下来进行调用 (方法/变量)。
即使没有显示地声明为 static，类的构造器实际上也是静态方法。

this 的用法：
1)	表示对当前对象的引用；
2)	表示类的成员变量，而非函数参数，注意在函数参数和成员变量同名时进行区分。这是第一种用法的特例，比较常用，所以那出来强调一下。
3)	用于在构造方法中引用满足指定参数类型的构造器。注意：只能引用一个构造方法且必须位于开始！
需要用的情况 this：
1)	通过 this 调用另一个构造方法，用发是 this (参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。
2)	函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this. 成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字，而不用 this，用了也不为错，呵呵。
3)	在函数中，需要引用该函所属类的当前对象时候，直接用 this。
 这些用法总结都是从对“this 是指向对象本身的一个指针”这句话理解而来的。
注意：this 不能用在 static 方法中使用。

super 的作用
1. 子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以通过 super 关键字指定访问父类的成员。super.name； super.print ()；
2. 创建子类对象时，默认会先调用父类无参的构造方法，可以通过 super 关键字指定调用父类的构造方法 (带参、无参)。super ()；super (name)；

super 调用父类构造方法的注意事项
 (在子类构造方法中调用通过 super 调用父类构造方法)
1. 如果在子类的构造方法上没有指定调用父类的构造方法，那么 java 编译器会在子类的构造方法上面加上 super () 语句。
2. super 关键字调用父类的构造函数时，该语句必须要是子类构造函数中的第一个语句。super ()；super (name)；
3. super 与 this 关键字不能同时出现在同一个构造函数中调用其他的构造函数。因为两个语句都需要第一个语句。

super 与 this 的区别
1. 代表的事物不一致：
super 代表的是父类空间的引用；
this 代表的是所属函数的调用者对象。
2. 使用前提不一致：
super 必须要有继承关系才能使用；
this 不需要存在继承关系也可使用。
3. 调用构造函数的区别：
super 是调用父类的构造函数；
this 是调用本类的构造函数。

return 的作用：
return 从当前的方法中退出, 返回到该调用的方法的语句处, 继续执行。
return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。
return 后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。

final
根据程序上下文环境，Java 关键字 final 有“这是无法改变的”或者“终态的”含义；
可以修饰非抽象类、非抽象类成员方法和变量。
可能出于两种理解而需要阻止改变：设计或效率。
final 类不能被继承，没有子类，final 类中的方法默认是 final 的。
final 方法不能被子类的方法覆盖，但可以被继承。
final 成员变量表示常量，只能被赋值一次，赋值后值不再改变。
final 不能用于修饰构造方法。
注意：父类的 private 成员方法是不能被子类方法覆盖的，因此 private 类型的方法默认是 final 类型的。

switch… case 语句：
switch 的用法是判断 case 后面的表达式和 switch 后面的表达式是否相匹配。
一旦 case 匹配就会顺序执行后面的程序代码，而不管后面的 case 是否匹配，直到遇见 break。利用这一特性可以让好几个 case 执行统一语句.
switch (表达式){ 
case 常量表达式 1:语句 1；
....
default:语句； 
}
default：如果没有符合的 case 就执行它，default 并不是必须的.
case 后的语句可以不用大括号.。case 后面必须是常量表达式 constant expressions, 错误表示如: case x .
switch 语句的判断条件可以接受 int,byte,char,short, enum，不能接受其他类型.

泛型：
泛型的声明，必须在方法的修饰符 (public,static,final,abstract 等) 之后，返回值声明之前。
和泛型类一样，可以声明多个泛型，用逗号隔开。
public static <T>list<T> aslist (T...a)
第一个<T>表示是泛型方法；
这个<T>是个修饰符的功能，表示是个泛型方法，就像有 static 修饰的方法是个静态方法一样。
<T> 不是返回值，表示传入参数有泛型。
第二个表示返回值是 list 类型，而这个 list 有泛型，只能存 t 类型的数据。

反射：
可以理解为在运行时期获取对象类型信息的操作。
传统的编程方法要求程序员在编译阶段决定使用的类型，但是在反射的帮助下，编程人员可以动态获取这些信息，从而编写更加具有可移植性的代码。


ReentrantLock 重入锁：



类型类：
我们一般所使用的对象都直接或间接继承自 Object 类。
Object 类中包含一个方法名叫 getClass ()，利用这个方法就可以获得一个实例的类型类。
类型类指的是代表一个类型的类，在 Java 使用类型类来表示一个类型。
所有的类型类都是 Class 类的实例。

getclass () 和 class 方法：
一般情况下，getclass () 方法和 class 方法是等价的，都可以获得一个类型名。
两者区别：
getClass () 是一个类的实例所具备的方法，而 class 方法是一个类的方法。
getClass () 是在运行时才确定的，而 class 方法是在编译时就确定了。

getter 和 setter 方法：
提供了一些属性读取的封装，可以让代码更便捷，例如存储 FirstName 和 LastName 字段，但是提供 FullName 属性的 getter。
setter 对于程序的健壮性非常有帮助，在 setter 里可以直接判断输入值是否合法，如果直接暴露字段就危险。
setter 中可以打断点、打日志，方便开发调试和追踪程序状态，还能触发事件，实现类似 onNameChanged 这样的事件。
JAVA 没有提供语言特性和 meta data 级别的 getter/setter，getXXX 和 setXXX 是一种约定，当然因为这个约定接受度非常广泛，现在很多 IDE 也完全能把它当做 Property 来看。JAVA 中需要反射 Method，然后用命名规则去匹配。

foreach 和 iterator 的区别：
foreach 的形式是：for (int　i：arr){...}；
iterator 的形式是：Iterator it = arr.iterator ()； while (it.hasNext ()){ object o =it.next ()； ...}
foreach 需要先知道集合的类型，甚至是集合内元素的类型，需要访问内部的成员，不能实现态；
iterator 是一个接口类型，不关心集合或者数组的类型，而且还能随时修改和删除集合的元素。
foreach 比 Iterator 迭代器简单方便，但是 foreach 在迭代时很难进行对容器的操作，所以一般用于打印 (显示)，而 Iterator 迭代器可以方便的操作容器内的元素。

方法覆盖 (Overiding) 和 方法重载 (Overloading)：
相同点：
都要求方法同名。
都可以用于抽象方法和非抽象方法之间。
不同点：
方法覆盖要求参数签名必须一致，而方法重载要求参数签名必须不一致。
方法覆盖要求返回类型必须一致，而方法重载对此不做限制。
方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类的所有方法 (包括从父类中继承而来的方法)。
方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有限制。
父类的一个方法只能被子类覆盖一次，而一个方法在所在的类中可以被重载多次。

compareTo 和 compare 方法比较
这两个方法经常搞混淆，现对其进行总结以加深记忆。
compareTo (Object o) 方法：
是 java.lang.Comparable<T>接口中的方法，当需要对某个类的对象进行排序时，该类需要实现 Comparable<T>接口的，必须重写 public int compareTo (T o) 方法。比如：
MapReduce 中 Map 函数和 Reduce 函数处理的 <key,value>，其中需要根据 key 对键值对进行排序，所以，key 实现了 WritableComparable<T>接口，实现这个接口可同时用于序列化和反序列化。WritableComparable<T>接口 (用于序列化和反序列化) 是 Writable 接口和 Comparable<T>接口的组合；
compare (Object o1,Object o2) 方法：
是 java.util.Comparator<T>接口的方法，它实际上用的是待比较对象的 compareTo (Object o) 方法。
参数：o1 - 要比较的第一个对象；o2 - 要比较的第二个对象。
返回：根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。

URI,，URL，URN
URI：uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
URL：uniform resource locator，统一资源定位器，它是一种具体的 URI；
URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。
URN：uniform resource name，统一资源命名，是通过名字来标识资源，比如 mailto:java-net@java.sun.com。
在 Java 中，一个 URI 实例可以代表绝对的，也可以是相对的，只要它符合 URI 的语法规则。
URL 类不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema 必须被指定。
总之，URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式。
URL 和 URN 都是一种 URI。
URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。
URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的。
而 URL 则必须提供足够的信息来定位，所以是绝对的。
而通常说的 relative URL，则是针对另一个 absolute URL，本质上还是绝对的。

堆 (heap) 和 栈 (stack) 的区别：
栈 (stack) 与堆 (heap) 都是 Java 用来在 Ram 中存放数据的地方。与 C++ 不同，Java 自动管理栈和堆，程序员不能直接地设置栈或堆。
栈的优势是存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。
缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
另外，栈数据可以共享。
堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java 的垃圾收集器会自动收走这些不再使用的数据。
缺点是由于要在运行时动态分配内存，存取速度较慢。
Java 中的数据类型有两种。
一种是基本类型 (primitive types), 共有 8 种，即 int, short, long, byte, float, double, boolean, char (注意，并没有 string 的基本类型)。这种类型的定义是通过诸如 int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如 int a = 3; 这里的 a 是一个指向 int 类型的引用，指向 3 这个字面值。这些字面值的数据，由于大小可知，生存期可知 (这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。
另一种是包装类数据，如 Integer, String, Double 等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java 用 new () 语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。
栈有一个很重要的特殊性，就是存在栈中的数据可以共享。
每个 JVM 的线程都有自己的私有的栈空间，随线程创建而创建，java 的 stack 存放的是 frames，java 的 stack 和 c 的不同，只是存放本地变量，返回值和调用方法，不允许直接 push 和 pop frames，因为 frames 可能是有 heap 分配的，所以 java 的 stack 分配的内存不需要是连续的。java 的 heap 是所有线程共享的，堆存放所有 runtime data，里面是所有的对象实例和数组，heap 是 JVM 启动时创建。

内连接和外连接：
内指的是内涵，外指的是外延。
自连接：self join
发生在一张基表内，连接的是同一个表，可以由内连接，外连接各种组合方式，按实际应用去组合。
内连接：inner join
返回查询结果集合中的仅是符合查询条件 ( where 搜索条件或 having 条件) 和连接条件的行；
只有两个表相匹配的行才能在结果集中出现。
外连接：outer join
包括：left join / left outer join，right join / right outer join，full join / full outer join。
返回查询结果集合中，不仅包含符合连接条件的行，
而且还包括左表 (左外连接时)、右表 (右外连接时) 或两个边接表 (全外连接) 中的所有数据行。
在写连接查询的时候，on 后面只跟连接条件，对中间表限制的条件都写到 where 子句中，用 and 连接。
全外连接 (全连接)：full join / full outer join
mysql 是不支持全外的连接的，这里给出的写法适合 Oracle 和 DB2；
但是可以通过左外和右外求合集来获取全外连接的查询结果。
交叉联接：cross join
返回左表中的所有行，左表中的每一行与右表中的所有行组合；交叉联接也称作笛卡尔积。
from 子句中的表或视图可通过内联接或完整外部联接按任意顺序指定；
但是，用左或右向外联接指定表或视图时，表或视图的顺序很重要。

Adivisor 和 Aspect：
Adivisor 是一种特殊的 Aspect，Advisor 代表 spring 中的 Aspect。
区别：advisor 只持有一个 Pointcut 和一个 advice，而 aspect 可以多个 pointcut 和多个 advice。

装箱和拆箱：
自动装箱：把基本类型用它们对应的引用类型包装起来，使它们具有对象的特质，
可以调用 toString ()、hashCode ()、getClass ()、equals () 等方法。
如下：Integer a=3； //这是自动装箱
编译器调用的是 static Integer valueOf (int i) 方法,valueOf (int i) 返回一个表示指定 int 值的 Integer 对象: 
Integer a=3； => Integer a=Integer.valueOf (3)；
拆箱：跟自动装箱的方向相反，将 Integer 及 Double 这样的引用类型的对象重新简化为基本类型的数据。
如下：int i = new Integer (2)； //这是拆箱
编译器内部会调用 int intValue () 返回该 Integer 对象的 int 值

局部变量和成员变量：
在 Hero 里面、方法 run 外面的是成员变量；
在 Hero 里面、方法 run 外面的、static 开头的是类变量 (静态变量)；
在方法 run 里面的是局部变量。
public class Hero {
	int age；//成员变量
	String name；//成员变量
	static int age1；//类变量 (静态变量)
	static String name2；//类变量 (静态变量)
	public void run (){
		String name3；//局部变量
		int age3；//局部变量
	}
}


参数和变量：
参数：
设置或者赋值不同的数值来实现一个目标结果，这些数值就是参数。
函数声明中需要传递的数据类型变量一般称为参数，或形参。
调用函数时传人的变量，在叙述调用过程时称之为实参。
一般可以看做是函数输入数据的载体。
被调函数的形参作为被调函数的局部变量处理，相当于被调函数的局部变量 (还能接受来自主调函数的实参的值)，即在堆栈中开辟了存储空间用来存放主调函数传入的实参的值。
变量：
意指一个存储空间，系统从内存中划出一块空间，可以对其有访问权限，可以命名、修改与调用 (读写)。
变量不一定要赋值 (不赋值就是 0 或是默认值)。
一个参数可以赋值给一个变量，即一个变量是一个参数的载体，即存储单元。



抽象类和抽象方法：
抽象方法：在类中只有方法声明 (只有方法名，参数表，和返回值)，没有方法体的方法。
或者在方法声明前使用 abstract 修饰。抽象方法一般存在于抽象类或接口中。
静态方法，私有方法和 fianl 修饰的方法不能被覆写的，因此这三类方法不能定义为抽象方法。
抽象方法只需声明，而不需实现某些功能。
抽象类：含有抽象方法的类就叫抽象类。抽象类不能被实例化。
抽象类中的抽象方法必须被实现。抽象类中的普通方法，可以不必实现。
如果一个子类没有实现父类中的抽象方法，则子类也成为了一个抽象类。
用 abstract 来修饰一个类时，这个类叫抽象类；用 abstract 来修饰一个方法时，该方法叫抽象方法。
含有抽象方法的类必须被声明为抽象类，抽象类必须被继承，抽象方法必须被覆写。

TCP 与 UDP 区别：
1)	TCP 面向连接 (如打电话要先拨号建立连接)；UDP 是无连接的，即发送数据之前不需要建立连接。
2)	TCP 提供可靠的服务；也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；
UDP 尽最大努力交付，即不保证可靠交付。
3)	TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的。
4)	UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低 (对实时应用很有用，如 IP 电话，实时视频会议等)
5)	每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信。
6)	TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。
7)	TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。

拦截器与过滤器：
1)	拦截器是基于 java 反射机制的；					过滤器是基于函数回调的；
2)	拦截器不依赖于 servlet 容器；						过滤器依赖于 servlet 容器；
3)	拦截器只对 action 起作用；						过滤器几乎可以对所有请求起作用；
4)	拦截器可以访问 action 上下文、值栈里的对象；		过滤器不能；
5)	在 action 的生命周期里，拦截器可以多起调用；		过滤器只能在容器初始化时调用一次。

静态变量与非静态变量的区别： 
1)	内存分配 
静态变量在应用程序初始化时，就存在于内存当中, 直到它所在的类的程序运行结束时才消亡； 
非静态变量需要被实例化后才会分配内存。
2)	生存周期 
静态变量生存周期为应用程序的存在周期； 非静态变量的存在周期取决于实例化的类的存在周期。
3)	调用方式 
静态变量只能通过“类. 静态变量名”调用，类的实例不能调用； 
非静态变量当该变量所在的类被实例化后，可通过实例化的类名直接访问。
4)	共享方式 
静态变量是全局变量，被所有类的实例对象共享，即一个实例的改变了静态变量的值，其他同类的实例读到的就是变化后的值； 非静态变量是局部变量，不共享的。
5)	访问方式 
静态成员不能访问非静态成员； 非静态成员可以访问静态成员。
6)	静态变量在类装载的时候分配内存，以后创建的对象都使用该内存，相应的操作也就是对这块内存进行操作；也可以看作是另类的全局变量。

静态构造函数：
1)	用于对静态字段、只读字段等的初始化。
2)	添加 static 关键字，不能添加访问修饰符，因为静态构造函数都是私有的。
3)	类的静态构造函数在给定应用程序域中至多执行一次：只有创建类的实例或者引用类的任何静态成员才激发静态构造函数
4)	静态构造函数是不可继承的，而且不能被直接调用。
5)	如果类中包含用来开始执行的 Main 方法，则该类的静态构造函数将在调用 Main 方法之前执行。
6)	任何带有初始值设定项的静态字段，则在执行该类的静态构造函数时，先要按照文本顺序执行那些初始值设定项。　
7)	如果没有编写静态构造函数，而这时类中包含带有初始值设定的静态字段，那么编译器会自动生成默认的静态构造函数。


懒加载：
Web 应用程序做的最多就是和后台数据库交互，而查询数据库是种非常耗时的过程。当数据库里记录过多时，查询优化更显得尤为重要。为了解决这种问题，有人提出了缓存的概念。
缓存就是将用户频繁使用的数据放在内存中以便快速访问。
在用户执行一次查询操作后，查询的记录会放在缓存中。当用户再次查询时，系统会首先从缓存中读取，如果缓存中没有，再查询数据库。
缓存技术在一定程度上提升了系统性能，但是当数据量过大时，缓存就不太合适了。因为内存容量有限，把过多的数据放在内存中，会影响电脑性能。


Arrays.sort () 方法：
	该排序算法是一个经过调优的快速排序法，快速排序 (Quicksort) 是对冒泡排序的一种改进。
快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。
整个排序过程可以递归进行，以此达到整个数据变成有序序列。



Array 类：
java.lang.Object 继承者 java.lang.reflect.Array
public final class Arrayextends ObjectArray 类提供了动态创建和访问 Java 数组的方法。
Array 允许在执行 get 或 set 操作期间进行扩展转换，


BigDecimal：
用来对超过 16 位有效位的数进行精确的运算。
双精度浮点型变量 double 可以处理 16 位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float 和 double 只能用来做科学计算或者是工程计算，在商业计算中要用 java.math.BigDecimal。
BigDecimal 所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。
方法中的参数也必须是 BigDecimal 的对象。
构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。



















