
基础小结


	进制
		进制：人为规定的进位方法。
		位：每个二进制数字 0 或 1 就表示一个位 (bit)，简记为 b(比特)。
		字节：一个字节 (Byte) 表示 8 bit。
			字节与位：1 B = 8 bit；
		以 B 为基础的存储单位：
			B(Byte、字节)；
			KB(Kibibyte、千字节)；
			MB(Mebibyte、兆字节)；
			GB(Gigabyte、吉字节)；
			TB(Terabyte、万亿字节)；
			PB(Petabyte、千万亿字节)。
			带宽是以位来计算的，下载速度是以字节计算。
		二进制和十进制之间的转化：
			二进制转十进制：位值乘以二的位数减一次方之和；
			十进制转二进制：辗转除以二的余数依次逆序。
			表示形式：
				二进制：要求以 0b 开头 补成八位，如 int a = 0b110
				八进制：要求以 0 开头，如 int a = 012
				十进制：直接写。如 int a = 17
				十六进制：要求以 0x 开头，如 int a = 0x6E

	运算
		原码、反码和补码操作
			所有数据的运算都是采用补码进行的。	
			正数的原码、反码、补码都相同。
			原码：二进制定点表示法；最高位为符号位，0 表示正，1 表示负。
			正数的二进制数值就是该数的原码；
			反码：负数的反码是对其逐位取反，符号位不变。
			补码：负数的补码就是在反码的末尾加 1。
			求反码的时候，最高位是符号位，不能改变。
		位运算 (可以理解成 01 运算)：
			& 按位与 ：参与运算的两个数，值都为 1，则结果值为 1，否则是 0；
			| 按位或 ：参与运算的两个数，只要有一个 1，结果就为 1；
			^ 异或 ：参与运算的两个数，相同则结果为 0，否则为 1；
			~ 取反 ：表示把每个二进制的“1”换成“0”，把“0”换成“1”。
		移位操作：
			<<：左移位。
				将操作的二进制码整体左移指定位数，左移之后的空使用“0”来补充。
			>>：右移位。
				将操作的二进制码整体左移指定位数，右移之后的空使用“符号位”来补充。
				若是正数，使用“0”补充；
				若是负数，使用“1”补充 (操作负数：取反，求补码，右移位操作，取反，求补码)。
			>>>：无符号右移位。
				将操作数的二进制码整体右移指定位数，右移之后的空位使用“0”来补充；
				操作之后肯定为一个正数。
		参数的值传递机制：
			基本数据类型的值传递，传递的是值的副本。
			引用数据类型的值传递，传递的是引用的地址值的副本。
		比较对象
			==：
			对于基本数据类型来说，比较的是值；
			对于引用数据类型来说，比较的是在内存中的地址值。
			equals：
			在 Object 类中和”==”相同，建议用子类覆盖 equals 方法，去比较自己的内容。
			在 String 类，覆盖了 equals 方法，比较的是字符内容。

	符号
		注释
			单行注释：// ：CTRL + /
			多行注释：/* */ ：CTRL + SHIFT + /
			文档注释：/** */ ：ALT + SHIFT + J 
			文档注释可以专门生成文档信息 API。
			多行和文档注释不能相互或自我嵌套。
		分隔符
			花括号 { } ：表示一个代码块，是一个整体，要成对使用。
			方括号 [ ] ：定义数组，访问数组元素时使用。
		路径分隔符，属性分隔符：
			 / ：正斜线；
			 \ ：反斜线。
			Unix：使用“/”来分割目标路径；使用“：”来分割属性。
			Windows：
				使用“\”来分割目标路径；
				 (在 Java 中，一个“\”表示转义，在 Windows 中 Java 代码中，表示一个路径要使用“\\”，但是 Windows 支持“/”) ；
				使用“；”来分割属性。


	数据类型

		基本数据类型：
			1) 数值型：
			a) 整数类型：byte，short，int，long；
			b) 小数类型：float，double。
			2) 字符型：char。字符：字母和符号
			3) 布尔型：boolean。表示对与错：true，false
		大小：
			byte：		1；8 位；[-128, 127]
			short：		2；16 位；
			int：		4；32 位；
			long：		8；64 位；
			float：		4；32 位；
			double：	8；64 位；
			char：		2；16 位；
			boolean：	1 位；
		初始值：
			long 型：0 L；
			float 型：0.0 F；
			double 型：0.0 D；
			boolean 型：false；
			char 型：'\u0000'；
			引用型：null。
		引用数据类型 (对象数据类型)：
			字符串、数组、类、接口。

		String
			String 类，表示字符串。
				字符串必须要使用双引号标出，连接字符串使用“+”符号；
				引用数据类型的默认初始值都是 null。
			String 分类：
				1) 不可变的字符串：String。创建完之后，对象不可改变；
				2) 可变的字符串：StringBuilder / StringBuffer。
					创建完之后，对象的内容可以发生改变；内容发生改变的时候，对象保持不变。
				3) CharSequence：接口。String / StringBuilder / StringBuffer 都是 CharSequence 的实现类。
			String 和 StringBuilder 以及 StringBuffer 的区别：
				String 在做字符串拼接的时候，性能极低；
				StringBuilder 字符串拼接运行效率最高，不执行同步，单线程，数度更快；
				StringBuffer 字符串拼接运行效率很高，使用了 synchronized 修饰符，表示同步的，在多线程并发的时候，可以保证线程安全，所以性能略低。

			String 对象的创建：
				直接赋一个字面量：String str1 =“ABC”。
					编译期就存储到常量池中。
				通过构造器来创建：String str2 = new String(“ABC”)。
					如果常量池中已经存在，那么直接引用，不用创建 String 对象。
					否则，现在常量池中创建内存空间，再引用。
					对象会存储到堆内存中，运行期才创建。
			String 的比较操作：
				使用”==”：只能比较引用的内存地址是否相同。
				使用”equals”方法：在 Object 类中和”==”相同，建议用子类覆盖 equals 方法，去比较自己的内容。
				String 类覆盖 equals 方法，比较的是字符内容。
			
		数组
			定义
			静态初始化
			动态初始化

	包装类
		包装类缓存的范围：
			Byte，Short，Integer，Long：缓存 [ -128，127 ] 区间的数据；
			Character：缓存 [ 0，127 ] 区间的数据。

		Integer 和 int 的区别
			Integer 既可以表示 null，又可以表示 0。
			集合框架中能存储对象类型 Integer，不能存储基本数据类型 int；
			包装类型 Integer 存放于堆中，基本数据类型 int 变量存储在栈中。
			建议使用包装类型。


	关键字

		for 循环
			for 循环：for(初始化语句；判断表达式； 循环后操作语句){ 循环体语句 } ；
			foreach：for(元素类型 变量 ：数组名) { 循环体语句 }
				嵌套循环性能优化
					int i，j，k；
						for (k = 1； k <= 10； k ++)
							for (j = 1； j <= 100； j ++)
							for (i= 1； i <= 1000； i ++)
								testFuction (k，j，i )；

		break 关键字：表示终止当前的所在的循环，跳出循环。
		continue 语句：表示跳过当前循环、继续；相当于 skip；表示跳过当前的循环，进入下一次循环。

		this：
			表示当前对象；主要存在于两个位置；
			构造器：表示当前创建的对象；
			方法中：哪一个对象调用 this 所在的方法，那么 this 就表示哪一个对象。

		super 使用场景：
			可以使用 super 解决子类隐藏父类的字段的情况；因为破坏封装不讨论；
			在子类方法中调用父类被覆盖的方法，引出 super 的例子，此时必须使用 super；
			子类构造器中，调用父类构造器，必须使用 super 语句：super([ 实参 ])。

		final：
		final 修饰的类：最终类，该类不能被继承，所以没有子类；
		final 方法：最终方法，该方法不能被子类所覆盖。
		final 修饰的变量：最终变量 (常量)，该变量只能赋值一次，不能再赋值。

		transient：
			被修饰的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
			Java中，对象的序列化可以通过实现两种接口来实现，
				若实现的是Serializable接口，则所有的序列化将会自动进行，
				若实现的是Externalizable接口，则没有任何东西可以自动序列化，
				需要在writeExternal方法中进行手工指定所要序列化的变量，
				这与是否被transient修饰无关。
		strictfp：
			strict float point：精确浮点。
			一旦使用了关键字strictfp来声明某个类、接口或者方法时，
			那么在这个关键字所声明的范围内所有浮点运算都是精确的，符合IEEE-754规范的。
		

	JVM 内存模型

		JVM 的内存划分：人为的根据不同的内存空间的存储特点以及存储的数据。
		程序计数器：当前线程所执行的字节码的行号指示器。
		本地方法栈：为虚拟机使用的 native 方法服务。
		Java 虚拟机栈：
			描述 java 方法执行的内存模型，每个方法被执行的时候，都会同时创建一个栈帧，
			用于存储局部变量表，操作线，动态连接，方法出口等信息。
			每个方法会创建一个栈帧，栈帧存放了当前方法的数据信息 (局部变量)，当方法调用完毕，该方法的栈帧就被销毁了。
		Java 堆：
			被所有线程共享的一块内存区域，在虚拟机启动时创建。
			所有对象实例以及数组都要在堆上分配。使用 new 关键字就表示在堆中开辟了一块新的存储空间。
		方法区：
			线程共享的内存区域，存储已被虚拟机加载的类信息，常量，静态变量即时编译器编译后的代码数据等，
			这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
		GC(garbage collection)：垃圾回收器。
		回收机制：
			程序员不需要手动去控制内存的释放。
			当 JVM 内存资源紧张的时候，就会自动的去清理无用对象 (没有被引用到的对象) 所占用的内存空间.


	基本算法

		排序：
			1) 交换排序 (冒泡排序，快速排序)
			2) 选择排序 (直接选择排序，堆排序)
			3) 插入排序 (直接插入排序，二分法排序，希尔排序)
			4) 归并排序。

		查找
			二分法查找

	面向对象

		三大特征：
			封装 (Encapsulation)：将对象的实现细节隐藏起来，通过公共方法来向外暴露该对象的功能。
			继承 (Inheritance)：是面向对象实现软件复用的重要手段；
				子类继承父类后，子类就是一种特殊的父类，能直接或间接获取父类里的成员。
			多态 (polymorphidm)：可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，
				这意味着，同一类型的对象在运行时可能表现出不同的行为特征。
				可以把不同的子类对象都当作父类类型来看待。

		构造器：
			1) 构造器的名称和当前所在类的名称相同；
			2) 禁止定义返回类型，千万不要使用 void 作为返回类型；
			3) 在构造器中，不需要使用 return 语句。

		类成员和实例成员
			类成员：直接属于类，可以通过类来访问 static 字段和 static 方法。
			实例成员：只属于对象，通过对象来访问非 static 字段和非 static 方法。
			在 static 方法中，只能调用 static 成员。(无法从静态上下文中引用非静态变量。)
			非 static 方法，可以访问静态成员，也可以访问实例成员。

		访问权限
			private：私有的，表示类访问权限；只能在类中访问，离开本类之后就不能直接访问；
			不写 (缺省)：包私有，表示包访问权限；必和当前定义类同包才能访问；
			protected：子类访问权限，表示同包可以访问，即使不同包，有继承关系也可以访问；
			public：全局的，表示公共访问权限；使用 public 修饰的字段方法，可以在项目的任何地方访问。


		JavaBean
			1) 类必须使用 public 修饰；
			2) 必须保证有公共无参数构造器，即使手动提供了带参数构造器，还得提供无参数构造器；
			3) 包含属性的操作手段 (给属性赋值，获取属性值)。


		方法覆盖：Override
			原则：一同两小一大；
				一同：实例方法签名必须相同 (方法签名 = 方法名 + 方法的参数列表)；
				两小：
					子类方法的返回值类型是父类方法返回值类型相同，或是其子类；子类可以返回一个更加具体的类；
					子类方法声明抛出的异常类型和父类方法声明抛出的异常类型相同，或是其子类；
						子类方法声明抛出的异常类型小于或等于父类方法声明抛出的异常类型；
						子类方法可以同时声明抛出多个属于父类方法声明抛出的异常类的子类 (RuntimeException 类型除外)。
				一大：子类方法的访问权限比父类方法的访问权限更大，或者相等。
					private 修饰的方法不能被子类所继承，所以不存在覆盖的概念。
			方法覆盖的作用：
				解决子类继承父类之后，父类的某一个方法可能不满足子类的具体特征，需要重新在子类中定义该方法，并重写方法体。


		方法重载：OverLoad
			原则：两同一不同；
				同类中，方法名相同，方法参数列表不同 (参数类型，参数个数，参数顺序)。
				只要参数类型，参数个数，参数顺序有一个不同，参数列表就不同。
			方法重载的作用：
				解决同一个类中，相同功能的方法名不同的问题；
				相同的功能，方法名也就相同。



		类加载机制：
			系统通过加载、连接、初始化三个步骤对类进行初始化；
				类的加载；
				类的连接；
				类的初始化：
					JVM 负责对类进行初始化，主要是对 static 静态变量初始化。
					初始化的三个步骤：
						a) 如果还没被加载和连接，则先加载并连接该类；
						b) 如果直接父类还没被初始化，则先初始化其父类；
						c) 如果类中有初始化语句 (静态代码块) ，则系统依次执行这些初始化语句。

			子类初始化过程
				子类初始化过程：创建子类对象的过程；
					创建子类对象之前，先创建父类对象；
					调用子类构造器之前，在子类构造器中会先调用父类的构造器，默认调用父类无参数构造器；
						如果父类不存在可以被访问的构造器，则不能存在于子类；
						如果父类没有提供无参数构造器，子类必须显示通过 super 语句去调用父类带参数的构造器。
				注意：
					必须先有父类对象，而后有子类对象；
					必须先调用父类构造器，而后再调用子类构造器。
					调用父类构造器的语句，必须作为子类构造器的第一句话。

		反射机制：
			Class 类
				获取类字节码对象的方式：
					//方式一：使用 class 属性；
					Class<java.util.Date> clz1 = java.util.Date.Class；
					//方式二：通过对象的 getClass () 方法来获取，getClass 是 Object 类中的方法；
					java.util.Date date = new java.util.Date () ；
					Class<?> clz2 = date.getClass () ；
					//方式三：通过 Class 类中的静态方法 forName (String className) 。
					Class<?> clz3 = Class.forName (”java.util.Date”) 。
			九大内置 Class 实例：
				JVM 中预先提供的 Class 实例：byte，short，int，long，float，double，boolean，char，void。
			获取类中的构造器：getConstructor () ；
			调用构造器：newInstance () ；
			获取类中的方法：getMethods () ；
			调用方法：invoke (clz.newInstance () ) ；
			调用静态方法：invoke(null,“正”)；
			调用数组参数 (可变参数) ：invoke (方法底层所属对象，new Object[ ]{ 所有实参 }) 

		设计模式：

			单例模式 (singleton)
				饿汉式：
					1) 必须在该类中，自己先创建出一个对象；
					2) 私有化自身的构造器，防止外界通过构造器创建新的对象；
					3) 向外暴露一个公共的静态方法，用于获取自身的对象。
				懒汉式：
					1) 必须在该类中，自己先声明出一个对象为 null；
					2) 私有化自身的构造器，防止外界通过构造器创建新的对象；
					3) 向外暴露一个公共的静态方法，用于获取自身的对象；
						在公共的静态方法中，判断对象是否为空，为空则创建对象；
						不为空则直接返回实例。
					//单例模式，饿汉式
					public class ArrayUtil_1 {
						private static ArrayUtil_1 instance = new ArrayUtil_1()；
						private ArrayUtil_1(){
						}
						public static ArrayUtil_1 getInstance(){
						return instance；
						}
					}
					//单例模式，懒汉式
					public class ArrayUtil_2 {
						private static ArrayUtil_2 instance = null；
						private ArrayUtil_2() {
						}
						public static ArrayUtil_2 getInstance(){
						if(instance == null){
							instance = new ArrayUtil_2()；
						}
						return instance；
						}
					}
					//单例模式，懒汉式的线程不安全；改进：双重检查锁机制
					public class ArrayUtil_4 {
						private static ArrayUtil_4 instance = null；
						private ArrayUtil_4() {
						}
						//同步方法，此时同步对象是 (ArrayUtil_4.class)
						public static ArrayUtil_4 getInstance(){
						if(instance == null){
							synchronized(ArrayUtil_4.class){
							if(instance == null){
								instance = new ArrayUtil_4()；
							}
							}
						}
						return instance；
						}
					}

			模板方法设计模式 (TemplateMethod)：
				在父类的一个方法中定义一个总体算法的骨架 (模板方法)，而将某一些步骤延迟到子类中，因为不同的子类实现细节不同。
				模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
				抽象类：不能创建对象，可以包含抽象方法。

		接口
			1) 接口里没有构造方法，也不能显示定义构造器，接口不能实例化 (不能 new)。
			2) 接口只能继承接口，不能继承类，且接口支持多继承 (类是单继承关系)。
				一个接口允许有多个父接口：interface 接口名 extends 接口 1，接口 2{}
			3) 接口里的方法全是公共的抽象的，默认修饰符是 public abstract。
			4) 接口里的字段 (成员变量) 是全局静态的常量，默认修饰符是 public static final。
			5) 接口里的内部类全是公共的静态的，默认修饰符是 public static。
			接口和和接口之间只能是继承关系：使用 extends 表示；

		内部类：
			1) 实例内部类：内部类没有使用 static 修饰；
			2) 静态内部类：内部类使用 static 修饰；
			3) 局部内部类：在方法中定义的内部类 (破坏封装)；
			4) 匿名内部类：适合于仅使用一次使用的类，属于局部内部类的特殊情况。


		枚举：
			[修饰符] enum 枚举类名 { 常量 A，常量 B，常量 C；s }
			使用枚举类做单例模式，很安全；即使使用反射也不能创建对象。


		命名的规范
			起名：全部使用驼峰表示法；使用英文单词或者组合单词。
			1) 包名：全部使用小写字母。域名倒写. 模块名. 组件：package com.m520it.pss.util
			2) 类名：用名词，首字母大写；不要使用内置类名。
			3) 接口名：用形容词、副词、名词，首字母大写。有的企业习惯以 i 作为接口前缀名。
			4) 方法名：用动词，首字母小写。
			5) 变量：用名词，首字母小写。
			6) 常量：全部使用大写字母，多个单词组合使用下划线分割。方法中定义的 final 变量不使用大写。

			
	异常

		常见异常
			NullPointerException：空指针异常，一般指对象为 null 的时候，调用了该对象的方法或字段；
			ArrayIndexOutOfBoundsException：数组的索引越界。小于零或大于数组长度；
			NumberFormatException：数字格式化异常，一般指把非零到九的字符串转换成整数。
			ClassCastException：类型强制转换异常；
			ArithmeticException：算术异常；

		finally ：修饰的语句块最终都会执行，无论有没有异常；使用 finally 可以保证代码块最终会执行。
		RuntimeException 类及其子类：称之为 runtime 异常。
		
		throw ：
			用于方法内部，抛出一个具体的异常对象。
			用于给调用者返回一个异常对象，和 return 一样会结束当前方法。
		throws：
			运用于方法声明之上，表示当前方法不处理异常，而是提醒调用者需要来处理该异常。
			如果每一个方法都放弃处理异常，都直接通过 throws 声明抛出，最后异常会抛 main 方法，
			通过此时 main 方法不处理，继续抛出给 JVM，底层的处理机制就是打印异常的跟踪栈信息。
		Throwable：Error 类和 Exception 类有共同的父类。



