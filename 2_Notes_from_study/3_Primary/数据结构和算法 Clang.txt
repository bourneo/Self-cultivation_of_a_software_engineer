
数据结构和算法

导论
	数据结构
		数据结构：
			非数值操作对象以及操作对象之间关系的集合。
			包括：逻辑结构和物理结构。
		逻辑结构：
			集合结构：元素同属于一个无序集合；
			线性结构：有序集合中元素之间一对一；
			树形结构：元素之间一对多；
			图形结构：元素之间多对多。
		物理结构：
			顺序存储结构；如数组。
			链式存储结构；存储灵活，通过指针进行访问。
	算法
		算法：特定简单指令的集合。
			特征：输入、输出、有穷、确定、可行性。
			设计要求：正确、可读、健壮、时间效率高。存储量低。
			效率度量：
				事后统计；事前分析统计；
				忽略常数和次要项，要关注主项的阶数。
			时间复杂度：
				大 O 记法；
				大 O 阶；
					O (1) ，常数阶；
					O (log n) ，对数阶；
					O (n) ，线性阶
					O (n log n) ，
					O (n^2) ：平方阶；
					
					O (n^3) ：立方阶；
					O (2^n) ：指数阶
					O (n！) ：阶乘阶；
					O (n^n) ：完全指数。
				平均情况的时间复杂度：
				最坏情况的时间复杂度：
			空间复杂度：
				空间开销换时间开销；
				计算算法所需的存储空间。
	 
线性表
	线性表 (顺序表、链表) 
		List：零个或者多个数据元素组成的有限序列；
			分为直接前驱元素和直接后继元素。
		抽象数据类型 (ADT) ：
			数据类型：性质相同的值的集合，和在此集合上的操作。
				如：基本类型、结构类型；
			抽象：忽略细节，抽取关键的特征。
		线性表顺序存储结构的优缺点：
			可以快速的存取表比赛任意位置的元素；
			插入和删除需要移动大量的元素；
			容易造成存储空间的碎片。
	线性表链式存储结构：
		单向链表：
			单链表：
				头指针；
				头节点；
				节点：由数据域和指针域组成。
				单链表没有表长，
					不能使用 for 循环控制。
				头插法；
				尾插法：
			单链表结构优缺点：
				采用链式存储结构；
				查找性能不高：O (n) ；
				插入和删除性能良好：O (1) ；
				不需要预分配存储空间；
				所以增删操作可以采用单链表。
			静态链表：
				使用数组实现的链表，
				包括下标，游标，数据。
			动态链表优缺点：
				插入删除只需要修改游标；
				不需要移动大量元素；
				长度难以确定；
				失去随机存取的特性。
			循环链表：
				约瑟夫问题：
			循环链表特点：
			判断单链表中是否有环：
				魔术师发牌问题：
				拉丁方阵问题：
		双向链表：
			时间效率比单向链表更加高效。
				head 头节点；
				rear 尾节点；
				next prior 上一个、下一个节点的地址 ；
				data 数据；
			双向循环链表：
				维吉尼亚密码；
		栈：
				先进后出；
				栈顶 (top) ，栈底 (bottom) ；
				入栈 (push) ，出栈 (pop) ；
			栈的顺序存储结构：
				base，top，stackSize；
			栈的链式存储结构：
				中缀表达式；
				逆波兰表达式 (后缀表达式) ；
				逆波兰计算器。
		队列：
				先进先出；
				队尾入，队头出；
				队列链式存储结构；
				front 头节点；
				rear 尾节点；
				next 下一个节点；
				入队列、出队列；
			循环队列：
				取模运算；
		递归：
				代码简洁，适合未知嵌套层次；
				会新建大量副本，废资源。
			斐波那契数列；
				f (n) =f (n-1) +f (n-2) 
			阶乘：
				n! = n (n-1) ... *1
			结束条件：用 # 表示。
			二分查找算法：
				是否包含某个元素；
			汉诺塔问题：
				调用自己是完全执行自己，
				直到结束条件。
		分治思想：
			递归：
				汉诺塔问题。
		穷举算法：
			
		贪心算法：
			
		回溯思想：
			八皇后问题：
		字符串：
			String：
				零个或多个字符组成的有限序列；
				子串和主串；
			BF 算法：
				brute force 算法；
				朴素模式匹配算法：
			KMP 算法：
				避免重复遍历；
				回溯算法； 
				
树	
	树：Tree；
		若干节点的有限集；
		分为有序树、无序树；
		根：root；唯一的；
		子树：subtree；互不相交；
		度：degree；节点拥有的子树数；
		叶节点：leaf；度为零的节点；
		节点：node；
			可以分为 child，parent，sibling；
		层次：level；
		深度：depth；数的高度；
		森林：forest；树的集合；
	树的存储结构：
		双亲表示法；
			
		孩子表示法；
			
		双亲孩子表示法；
		
		孩子兄弟表示法；
	二叉树：
		binary tree：二叉树；
			左子树，右子树；
		基本形态：
			空树
			根节点
			左子树
			右子树
			左右子树
		特殊二叉树：
			斜树 (左斜树，右斜树；
			满二叉树 (完美二叉树) ；
			完全二叉树；
				最下两层可以有叶节点；
				度为一的节点只有左子树。
		二叉树性质：
			i 层至多有 2^ (i-1) 个节点；
			深度 k 至多有 2^k -1 个节点；
			连接数 = 总结点数 n - 1
			连接数 = n1 + 2*n2
				n0 = n2 + 1
			具有 n 个节点的完全二叉树，
				深度为 [log2n] + 1
		二叉树的顺序存储结构：
			数组实现，虚节点用-1 代替。
			实用性不强，
		二叉链表：
			节点：node;
			数据：data；
			左子：lchild；
			右子：rchild；
		二叉树的遍历：traversing
			分类依据：访问根节点的顺序位置。
			前序遍历：
				从根节点开始，
				先访问父节点，
				然后访问左子树，
				再访问左子树，
				无左子树则直接访问右子树。
			中序遍历：
				从最底层左子树开始，
				先访问左子树，
				再访问父节点和右子树，
				无左子树则访问父节点。
			后序遍历：
				从最底层左边叶子节点开始，
				先访问左子树，
				再访问右子树，
				然后访问父节点，
				无左子树则访问右子树，
				无右子树则访问父节点，
				最后访问根节点。
			层序遍历：
				先访问根节点，
				再依次访问第二层的所有节点，
				依次类推。
		二叉树的建立：
			基础：前序二叉树；
			元素：根节点、左右子节点；利用递归。
		线索二叉树：
			基础：中序二叉树；
			在存有空指针的叶子节点中，
			存放前一个和后一个的指针。
		树、森林、二叉树：
			树到二叉树；
				连接所有兄弟节点；
				只保留父节点和左子树的连线。
				得到的树只有左子树。
			森林到二叉树；
				将森林中的树转成二叉树；
				将根节点视为兄弟节点连起来。
				得到的树有左子树和右子树。
			二叉树到树或者森林：
				如果子节点是父节点的左子树，
				则把子节点的右子树，
				右子树的右子树...
				与父节点连起来，
				去除右子树与其父节点间的连线。
			二叉树转换成树还是森林，			处决于二叉树的根节点有没有右子树。
		树和森林的遍历：
			树的遍历：
				先根遍历；
					从根部开始，
					先访问父节点，
					再访问左右子树。
				后根遍历；
					先访问左右子树，
					再访问父节点。
			森林的遍历：
				前序遍历；
				后序遍历。
			树和森林的前序遍历：
				和二叉树的前序遍历结果相同；
			树和森林的后根遍历：
				和二叉树的中序遍历结果相同。
	哈夫曼树：
		哈夫曼树：
			权重：weight；
			节点路径长度：根节点到节点；
			树的路径长度：叶子节点路径长度之和。
			节点带权路径长度：
			树的带权路径长度：
			WPL：
				所有叶子节点的带权路径长度之和。
				WPL 最小：最优哈夫曼树。
		哈夫曼编码：
			无损压缩编码方案，贪心算法。
			定长编码：如 ASCII 码；
			变长编码：长度根据出现频率来调节；
			前缀码：没有码字是其他码字的前缀。
		
图
	图：Graph；
		顶点：Vertex；有穷非空集合；
		边：Edge；
			无向边；
			有向边：叫弧 Arc ：弧头，弧尾；
		权重：weight；
	图的分类：
		简单图：
			没有定点到自身边，
			同一条边不重复出现。
		无向完全图：
			任意两个定点之间都存在边；
			边数：v * (v-1) / 2。
		有向完全图：
			任意两个顶点间存在方向相反的两条弧。
			边数：v * (v-1)。
		疏密图：
			边数或弧数小于 v * log v。
		稠密图：
			边数或弧数大于 v * log v。
		网：Network；
			带权的图；
		子图：Subgraph；
			g2 是 g1 的子图：
			v2 包含于 v1，且 e2 包含于 e1。
	顶点和边之间的关系：
		无向图：
			邻接点：Adjacent；顶点和顶点；
			依附于：incident；边和顶点；
			度：Degree；顶点相关的边数；
			路径：Path。
		有向图：
			邻接自；
			入度：InDegree；以顶点为头的弧数；
			出度：OutDgree；以顶点为尾的弧数。
			TD = ID + OD。
		环：回路；Cycle；
			简单环：
				第一个和最后一个顶点除外，
				其余顶点不重复出现的贿赂。
			简单路径：
				序列中顶点不重复出现的路径。
		连通图：
			任意两个顶点之间有路径。
			连通分量：
				无向图中的极大连通子图。
			连通子图：
				被包含的连通图。
		强连通图：
			强连通分量：
				有向图中极大强连通子图。
			强连通子图：
				路径有方向的连通子图。
		连通图生成树：
			极小连通子图；
			含有 n 个顶点，只有 n - 1 条边。
		有向树：
			有向图的一个顶点入度为 0，
			其他顶点入度均为 1。
	图的存储结构：	
		邻接矩阵：Adjacency Matrix ；
			无向图；
			对称矩阵；
			元：矩阵中的元素；
			顶点数组，
			边数数组，
		邻接矩阵 (网) ：
			有向的邻接矩阵；
			非对称矩阵；
			列是弧头，行是弧尾；
		邻接表：AdjacencyList；
			顶点用一维数组存储，
			所有邻接点构成一个单链表；
		邻接表： (有向图) ；
			单链表存储每个顶点的出度；
		邻接表： (网) ；
			再链表中增加一个数据域存储权值；
		十字链表： (Orhogonal List) 
			把邻接表和逆邻接表整合在一起；
			在有向图应用中是优秀的数据结构模型；
		邻接多重表：
			无向图应用中，
			如果关注点是顶点，邻接表是不错的；
			如果关注点是边，邻接表不方便。
			边表里存放的是一条边，不是顶点。
		边集数组：
			两个一维数组；
			一个存储顶点信息；
			另一个存储边的信息；
			边数数组包括：
				起点下标：begin；
				终点下标：end；
				权：weight。
	图的遍历：
		深度优先遍历：DepthFirstSearch；DFS；
			深度优先搜索；
			右手原则；
			没有新元的情况下回到上一个元。
		马踏棋盘算法：
			骑士漫游问题：
			回溯法；
				和递归一起使用。
			哈密尔顿路径；
				遍历并且不重复的路径。
		 广度优先遍历：BreadthFirstSearch；BFS；
				逐步扩大查找范围的方式；
			最小生成树：
				普里姆算法；
					带权邻接矩阵；
					以某个顶点为起点，
					逐步找到各个顶点上
					最小权值的边
					来构建最小生成树。
				克鲁斯卡尔算法：
					从边出发，
					直接去找最小权值的边，
					适用于稀疏图。
			最短路径：
				迪杰斯特拉算法：
					求的是一个顶点到所有顶点的
					最短路径。
				弗洛伊德算法：
					求的是所有顶点到所有顶点的
					最短路径。
					非常简洁优雅。
			拓扑排序：
					对有向图构造拓扑序列的过程
				无环图：DirectedAcyclic Graph
					无环的有向图
				AOV 网：
					Active On Vertex Network
					用顶点表示活动的有向图。
					不能存在回路。
				拓扑序列：
					若 Vi 到 Vj 有一条路径，
					则顶点 Vi 必在 Vj 之前。
			关键路径：
					先拓扑序列；
					再拓扑排序；
					
				AOE 网：
					Active On Eage Network
					用顶点表示事件，
					用有向边表示活动，
					用边的权值表示活动持续时间
					始点：
						没有入边的顶点；
					终点：
						没有出边的顶点。
					事件最早发生时间
						etv
					事件最晚发生时间
						ltv
					活动最早发生时间
						ete
					活动最晚发生时间
						lte	
					
	基本课程：
		数据结构；
		算法分析；
		汇编语言；
		计算机原理；
		图形学；
		编译系统；
		操作系统；
		
		