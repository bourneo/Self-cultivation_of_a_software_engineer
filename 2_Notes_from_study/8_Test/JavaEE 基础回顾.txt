
JavaEE 笔记 基础回顾

集合、泛型、IO 流、线程、Junit、断言、内省、路径


01_集合
集合：
存储对象数据的集合容器。
集合的类型与特性：
Collection：单列集合的根接口；
List：有存储顺序，可重复；
ArrayList：
底层使用了 Object 数组来实现；查找速度快，增删慢。
由于是数组实现，在增和删的时候会牵扯到数组增容，以及拷贝元素，所以增删慢。
数组是可以直接按索引查找，所以查找时较快。
LinkedList：
底层使用了链表数据结构实现；查找速度慢，增删快。
由于链表实现，增加时只要让前一个元素记住自己就可以，删除时让前一个元素记住后一个元素，后一个元素记住前一个元素，这样的增删效率较高；
但查询时需要一个一个的遍历，所以效率较低
Vector：	底层使用了 Object 数组来实现；和 ArrayList 原理相同，但线程安全，效率略低
和 ArrayList 实现方式相同，但考虑了线程安全问题，所以效率略低
Set：无存储顺序，不可重复
HashSet：
线程不安全，存取速度快。底层是以哈希表实现的。
往 hashSet 添加元素的时候，首先会调用元素的 hashCode 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素在哈希表中的位置。
情况一：
如果算出的位置目前还没有存在任何元素，那么该元素直接添加到哈希码中；
情况二：
如果算出的位置目前已经存在其他的元素，那么还会调用元素的 equals 方法，再与这个位置上的元素比较一次。
如果 equals 方法返回的是 true，那么该元素被视为重复元素，不允许添加；
如果 equals 方法返回的是 false，那么该元素也可以被添加。
	@Override
	public int hashCode() {
		return this.id;
	}
	@Override
	public boolean equals(Object obj) {
		Person pe = (Person)obj;
		return this.id == pe.id;
	}
TreeSet：
底层使用了红黑树 二叉树) 的数据结构来实现；默认对元素进行自然排序 String) 。
如果在比较的时候两个对象返回值为 0，那么元素重复。
如果元素具备自然顺序的特点，那么 TreeSet 会根据元素的自然排序特性进行排序存储；
如果元素不具备自然顺序的特点，那么元素所属的类就必须实现 Comparable 接口，把规则定义在 CompareTo 方法上；
如果元素不具备自然顺序的特点，元素所属的类就必须实现 Comparable 接口，那么创建 TreeSet 对象的时候必须要传入比较器对象。
比较器的定义格式：class 类名 implements Comparator { }。

Map：双列集合的根接口；存储的数据以键值对形式存在；键不可重复，键可以重复；
HashMap：
线程不安全，存取速度快；底层是以哈希表实现的.。
TreeMap：
红-黑树的数据结构，默认对元素进行自然排序 String) 。
如果在比较的时候两个对象返回值为 0，那么元素重复。
HashTable：
底层也是使用了哈希表维护的，存取的读取快，存储元素没有顺序。
集合练习：
遍历集合的几种方式：
使用迭代器 Iterator 的方式；
使用增强 for 循环的方式； 底层是用迭代器完成的) 
如果有下标，则可以使用下标的方式。
entrySet) ：key ---- value。键值组合) 
遍历数组：
public static void main(String[] args) {
	// 遍历数组：
	String[] arr = new String[] { "xx"，"yy"，"zz" };
	// 1，增强的 for 循环
	for (String elt ：arr) {
		System.out.println(elt);
	}
	// 2，下标的方式
	for (int i = 0; i < arr.length; i++) {
		System.out.println(arr[i]);
	}
}
遍历 List：
public static void main(String[] args) {
	// 遍历 List：
	List<String> list = new ArrayList<String>();
	list.add("aa");
	list.add("bb");
	list.add("cc");
	// 1，增强的 for 循环
	for (String elt ：list) {
		System.out.println(elt);
	}
	// 2，下标
	for (int i = 0; i < list.size(); i++) {
		System.out.println(list.get(i));
	}
	// 3，迭代器
	for (Iterator<String> iter = list.iterator(); iter.hasNext();) {
		String elt = iter.next();
		System.out.println(elt);
	}
}
遍历 Set：
public static void main(String[] args) {
	// 遍历 Set：
	Set<String> set = new HashSet<String>();
	set.add("dd");
	set.add("ee");
	set.add("ff");
	// 1，增强的 for 循环
	for (String elt ：set) {
		System.out.println(elt);
	}
		// 2，迭代器
	for(Iterator<String> iter = set.iterator(); iter.hasNext() ; ){
		String elt = iter.next();
		System.out.println(elt);
	}
}
遍历 Map：
public static void main(String[] args) {
	// 遍历 Map：
	Map<String，String> map = new HashMap<String，String>();
	map.put("aa"，"xx");
	map.put("bb"，"yy");
	map.put("cc"，"zz");
	// 1，增强的 for 循环 Entry 集合) 
	for (Entry<String，String> entry ：map.entrySet()) {
		System.out.println(entry);
	}
	// 2，增强的 for 循环 Key 集合) 
	for(String key ：map.keySet()){
		System.out.println(key + " = " + map.get(key));
	}
	// 3，遍历值的集合
	for(String value ：map.values()){
		System.out.println(value);
	}
}
引入泛型：
当集合中存储的对象类型不同时，那么会导致程序在运行的时候的转型异常。
public class Demo5 {
	public static void main(String[] args) {
		ArrayList arr = new ArrayList();
		arr.add(new Tiger("华南虎"));
		arr.add(new Tiger("东北虎"));
		arr.add(new Sheep("喜羊羊"));
		System.out.println(arr);
		Iterator it = arr.iterator();
		while (it.hasNext()) {
			Object next = it.next();
			Tiger t = (Tiger) next;
			t.eat();
		}
	}
}
class Tiger {
	String name;

	public Tiger() {

	}
	public Tiger(String name) {
		this.name = name;
	}
	public String toString() {
		return "Tiger@name：" + this.name;
	}
	public void eat() {
		System.out.println(this.name + "吃羊");
	}
}
class Sheep {
	String name;
	public Sheep() {
	}
	public Sheep(String name) {
		this.name = name;
	}
	public String toString() {
		return "Sheep@name：" + this.name;
	}
	public void eat() {
		System.out.println(this.name + "吃青草");
	}
}
异常原因 ：
虽然集合可以存储任意对象，但是如果需要使用对象的特有方法，那么就需要类型转换；
如果集合中存入的对象不同，可能引发类型转换异常。
[Tiger@name：华南虎，Tiger@name：东北虎，Sheep@name：喜羊羊]
华南虎吃羊
东北虎吃羊
Exception in thread "main" java.lang.ClassCastException：cn.itcast.gz.map.Sheep cannot be cast to cn.itcast.gz.map.Tiger
	at cn.itcast.gz.map.Demo5.main(Demo5.java：17)
问题：
存入的是特定的对象，取出的时候是 Object 对象，需要强制类型转换，可能诱发类型转换异常。
无法控制存入的是什么类型的对象，取出对象的时候进行强转时可能诱发异常. 而且在编译时期无法发现问题。
虽然可以再类型转换的时候通过 if 语句进行类型检查 (instanceof)，但是效率较低.(例如吃饭的时候，还需要判断米饭里有没有沙子，吃饭效率低). 可以通过给容器加限定的形式规定容器只能存储一种类型的对象。
就像给容器贴标签说明该容器中只能存储什么样类型的对象。
所以在 jdk5.0 后出现了泛型。
需求：
定义一个函数可以接收任意类型的参数，要求函数的返回值类型和实参的数据类型一致。
实现一：
由于无法确定具体传递什么类型的数据. 那么方法的形参就定义为 Object 类型. 返回值也就是 Object 类型. 但是使用该函数时需要强制类型转换。
private Object getDate(Object obj) {
		return obj;
}
当不进行强制类型转换能否写出该功能：
目前所学的知识无法解决该问题；就需要使用泛型类解决，使用的泛型的自定义来解决以上问题。

02_泛型
泛型：
就是将类型当作变量处理；规范泛型的定义一般是一个大写的任意字母。
泛型格式：
集合类 < 类的类型 > 变量名 = new 集合类 < 类的类型 >) ；
通过< >来指定容器中元素的类型。
public class Demo5 {
	public static void main(String[] args) {
		// 使用泛型后，规定该集合只能放羊，老虎就进不来了。
		ArrayList<Sheep> arr = new ArrayList<Sheep>();
		arr.add(new Sheep("美羊羊"));
		arr.add(new Sheep("懒洋洋"));
		arr.add(new Sheep("喜羊羊"));
		// 编译失败
		// arr.add(new Tiger("东北虎"));
		System.out.println(arr);
		Iterator<Sheep> it = arr.iterator();
		while (it.hasNext()) {
			// 使用泛型后，不需要强制类型转换了
			Sheep next = it.next();
			next.eat();
		}
	}
}
泛型的好处：
1) 将运行时的异常提前至编译时发生；
2) 获取元素的时候无需强转类型，就避免了类型转换的异常问题。
泛型没有多态的概念：
泛型的两边数据必须要一致，泛型类型也可以只写一边 考虑新老兼容性) ；推荐两边的数据类型都写上。
什么时候使用泛型：
当类中操作的引用数据类型不确定的时候，就可以使用泛型类。
JDK5.0 之前的 Comparable：
package java.lang;
public interface Comparable {
 public int compareTo(Object o);
}
JDK5.0 之后的 Comparable：
package java.lang;
public interface Comparable<T> {
 public int compareTo(T o);
}
细节一：明好泛型类型之后，集合中只能存放特定类型元素
public class Demo6 {
	public static void main(String[] args) {
		//创建一个存储字符串的 list
		ArrayList<String> arr=new ArrayList<String>();
		arr.add("gz");
		arr.add("itcast");
		//存储非字符串编译报错。
		arr.add(1);
	}
}
细节二：泛型类型必须是引用类型
public class Demo6 {
	public static void main(String[] args) {
		// 泛型类型必须是引用类型，也就是说集合不能存储基本数据类型
		// ArrayList<int> arr2=new ArrayList<int>();
		// 使用基本数据类型的包装类
		ArrayList<Integer> arr2 = new ArrayList<Integer>();		
	}
}
细节三：使用泛型后取出元素不需要类型转换。
public class Demo6 {
	public static void main(String[] args) {
		ArrayList<String> arr = new ArrayList<String>();
		arr.add("gzitcast");
		arr.add("cditcast");
		arr.add("bjitcast");
		//使用泛型后取出元素不需要类型转换。
		String str=arr.get(0);
		System.out.println();
	}
}
自定义泛型：
定义：可以理解为一个数据类型的占位符，或是一个数据类型的变量。
把 T 字母声明为自定义的泛型；这里的<T>表示泛型类型，随后可以传入具体的类型来替换它。
【变量必须先声明，才能使用。】
泛型方法：
定义格式：
修饰符 < 声明自定义泛型 > 返回值类型 函数名 形参列表…) { }；
注意：
1) 在方法上的自定义泛型的具体数据类型是调用该方法，传入实参的时候确定的；
2) 自定义泛型使用的标识符，只要符合标识符的命名规则即可。
函数上的泛型定义：
	当函数中使用了一个不明确的数据类型，那么在函数上就可以进行泛型的定义。
修饰符 < 泛型的声明 > 返回值类型 函数名 泛型 变量名) { } ；
public static void main(String[] args) {
		int[] arr = { 1，2，3，4，5 };	
		new Demo6().getData(5);
	}
	public <T> T getData(T data) {
		return data;
	}
细节：
使用泛型方法前需要进行泛型声明，使用一对尖括号 <泛型>，声明的位置在 static 后返回值类型前。
当一个类中有多个函数声明了泛型，那么该泛型的声明可以声明在类上。
泛型类 ：
定义格式：
修饰符 class 类名 < 声明自定义的泛型 > { } ；
注意：
1) 在类上自定义泛型的具体数据类型，是在创建对象的时候指定的；
2) 在类上自定义了泛型，如果创建该类对象时，没有指定泛型的具体类型，那么默认是 Object 类型。
类上的泛型声明：
修饰符 class 类名 < 泛型 > { } ；
import java.util.Arrays;
public class Demo6<T> {
	public static void main(String[] args) {
		// 使用泛型类，创建对象的时候需要指定具体的类型
		new Demo6<Integer>().getData(5);
	}
	public T getData(T data) {
		return data;
	}
	// 反序任意类型数组
	public void reverse(T[] arr) {
		int start = 0;
		int end = arr.length - 1;
		for (int i = 0; i < arr.length; i++) {
			if (start < end) {
				T temp = arr[start];
				arr[start] = arr[end];
				arr[end] = temp;
			}
		}	
}
在泛型类中定义一个静态方法
public class Demo6<T> {
	public static void main(String[] args) {
		System.out.println(getData2(100));
	}
	public T getData(T data) {
		return data;
	}
	//静态方法
	public static T getData2(T data) {
		return data;
	}
} 
注意：
静态方法不可以使用类中定义的泛型；
因为类中的泛型需要在对象初始化时指定具体的类型，而静态优先于对象存在。那么类中的静态方法就需要单独进行泛型声明，声明泛型一定要写在 static 后，返回值类型之前。
泛型类细节：
1) 创建对象的时候要指定泛型的具体类型
2) 创建对象时可以不指定泛型的具体类型 (和创建集合对象一眼)。
默认是 Object，例如我们使用集合存储元素的时候没有使用泛型就是那么参数的类型就是 Object
3) 类上面声明的泛型只能应用于非静态成员函数，
如果静态函数需要使用泛型，那么需要在函数上独立声明。
4) 如果建立对象后指定了泛型的具体类型，那么该对象操作方法时，这些方法只能操作一种数据类型。
5) 所以既可以在类上的泛型声明，也可以在同时在该类的方法中声明泛型。
泛型练习：
定义泛型成员：
public class Demo7 {
	public static void main(String[] args) {
		Father<String> f = new Father<String>("jack");
		System.out.println(f.getT());
		Father<Integer> f2 = new Father<Integer>(20);
		System.out.println(f2.getT());
	}
}
class Father<T> {
	private T t;
	public Father() {
	}
	public Father(T t) {
		super();
		this.t = t;
	}
	public T getT() {
		return t;
	}
	public void setT(T t) {
		this.t = t;
	}
}
如果 Father 类有子类，子类该如何实现：
public class Demo7 {
	public static void main(String[] args) {
		Father<String> f = new Father<String>("jack");
		System.out.println(f.getT());
		Father<Integer> f2 = new Father<Integer>(20);
		System.out.println(f2.getT());
	}
}
class Father<T> {
	private T t;
	public Father() {
	}
	public Father(T t) {
		super();
		this.t = t;
	}
	public T getT() {
		return t;
	}
	public void setT(T t) {
		this.t = t;
	}
}
//子类指定了具体的类型
class Son extends Father<String>{	
}
//子类也需要使用泛型
class Son3<T> extends Father<T>{	
}
//错误写法，父类上定义有泛型需要进行处理
class Son2 extends Father<T>{	
}
泛型接口：
定义格式：
interface 接口名< 声明自定义的泛型 > { } ；
在接口上自定义泛型的注意事项：
在接口上自定义泛型具体的数据类型，是在实现该接口的时候指定的。
如果一个接口自定义了泛型，在实现该接口的时候没有指定具体的数据类型，那么默认是 Object 数据类型。
如果想在创建接口实现类对象的时候再指定接口自定义泛型的具体类型：用<T>占位。
public class Demo8 {
	public static void main(String[] args) {
		MyInter<String> my = new MyInter<String>();
		my.print("泛型");
		MyInter2 my2 = new MyInter2();
		my.print("只能传字符串");
	}
}
interface Inter<T> {
	void print(T t);
}
// 实现不知为何类型时可以这样定义
class MyInter<T> implements Inter<T> {
	public void print(T t) {
		System.out.println("myprint：" + t);
	}
}
//使用接口时明确具体类型。
class MyInter2 implements Inter<String> {
	public void print(String t) {
		System.out.println("myprint：" + t);
	}
}

03_IO 流
IO 流：解决设备与设备之间的传输问题；比如：硬盘 -- 内存。
IO 流的分类：
输入流：
输出流：
字节流：
读取数据不需要经过编码或者解码的情况下使用 比如：图片) ；字节流是处理字节的 二进制) ；
输入字节流：	
InputStream：输入字节流；基类；抽象类。
FileInputStream：读取文件的输入字节流；
BufferdInputStream：缓冲输入字节流。
该类内部其实就是维护了 8kb 的字节数组；目的是为了提高读取文件数据的效率。
输出字节流：
OutputStream：输出字节流；基类；抽象类。
FileOutputStream：向文件输出数据的输出字节流；
BufferedOutputStream：缓冲输出字节流。
该类内部其实就是维护了 8kb 的字节数组；目的是为了提高读取文件数据的效率。
字符流：
字符流是处理字符的；字符流 = 字节流 + 编码 解码) 。
输入字符流：
Reader：所有输入字符流的基类；抽象类。
FileReader：读取文件字符的输入字符流；默认使用的是 GBK 编码。
BufferedReader：缓冲输入字符流；该类内部其实就是维护了 8192 个长度的字符数组；
目的是为了提高读取文件数据的效率，并且拓展了功能 newLine) ) 。
输出字符流：
Writer：所有输出字符流的基类；抽象类。
FileReader：读取文件字符的输入字符流；默认使用的是 GBK 编码。
BufferedWriter：缓冲输出字符流；该类内部其实就是维护了 8192 个长度的字符数组；
目的是为了提高读取文件数据的效率，并且拓展了功能 newLine) ) 。
FileReader、FileWriter 这两个类默认使用的是 GBK 编码，不能指定读写文件的数据。
字符流的情况：
如果读写的都是字符数据，就使用字符流。
转换流：
输入字节流的转换流：InputStreamReader；
输出字节流的转换流：OutputStreamWriter。
转换流的作用：
可以把对应的字节流转换成字符流；
可以指定码表进行读写文件的数据。
注意：这几个类都是抽象类。读文件、拷贝文件的代码。

04_多线程
线程：
多线程的好处：
解决了在一个进程中，同时执行多个任务代码的问题。
自定义线程的创建方式：
方式一：继承 Thread：
自定义一个类继承 Thread 类；
重写 Thread 类的 run 方法，把自定义线程的任务自定义在 run 方法上；
创建 Thread 子类的对象，并且在 start 方法启动一个线程。
线程一旦开启就会指定 run 方法中的代码。
方式二：实现 Runnable 接口：
自定义一个类实现 Runnable 接口；
实现 Runnable 接口中的 run 方法，把自定义线程的任务代码定义在 run 方法上；
创建 Runnable 实现类的对象；
创建 Thread 对象，并把 Runnable 实现类的的对象作为参数传递；
调用 Thread 对象的 start 方法。
线程安全问题：
同步代码块：
synchronized 锁) { 需要被同步的代码 }
同步函数：
修饰符 synchronized 返回值类型 函数名 形参列表…) { } ；
注意：
同步代码块的锁可以是任意对象；
同步函数的锁是固定的；非静态函数的锁对象是 this 对象，静态函数的锁对象是 class 对象。
锁对象必须是多线程共享的对象，否则锁不住；
在同步代码块或同步函数中调用 sleep 方法，不会释放锁对象，如果调用了 wait 方法，会释放锁对象。
线程安全问题出现的原因：
必须要存在多个线程共享一个资源；
操作共享资源的代码，必须有多句，如果两个线程都只有一句，就不需要创建多线程。
自定义的类
使用代码为 new Thread(new MyRunnable()).start
代码
以下代码是分别用两种方式启动线程 还是用到了匿名内部类) 

05_Junit 单元测试框架
引入单元测试：
1) 如果方法需要测试，都需要在 main 方法中调用；
2) 目前的结果对需要人工对比。
注意事项：
1) 如果使用 Junit 测试，在 Junit 窗口显示了绿条，表示测试正确；
如果出现红条，表示该方法测试出现异常，测试不通过。
2) 如果点击方法名、类名、包名、项目名，运行 Junit，
分别测试的是对应的方法、类、包中的所有类的 test 方法，项目中的所有 test 方法。
3) @Test 测试的方法不能是 static 修饰，不能带有形参。
如果要测试有形参或者静态的方法，就新建一个测试方法调用需要测试的方法。
Junit 使用规范：
1) 如果一个类需要测试，那么该类就应该对应着一个测试类，测试类的命名规范：被测试类的类名 + Test；
2) 被测试的方法一般都对应着一个测试的方法，测试方法的命名规范：test + 被测试方法的方法名。
@Test ：属于注解。
测试完没有异常，记得要删掉注解。
使用步骤：
一、搭建环境：
	导入 junit.jar 包 junit4) 
二、写测试类：
1) 一般一个类对应一个测试类。
2) 测试类与被测试类最好是放到同一个包中 可以是不同的源文件夹) 
3) 测试类的名字为被测试类的名字加 Test 后缀。
三：写测试方法：
1) 一般一个方法对应一个单元测试方法。
2) 测试方法的名字为 test 前缀加被测试方法的名字，如 testAddPerson()。
3) 单元测试方法上面要加上 @Test 注解 org.junit.Test) ！
4) 单元测试方法不能有参数，也不能有返回值 返回 void) ！测试的方法不能是静态的方法。
四、测试方法的基本使用：
1) 可以单独执行一个测试方法，也可以一次执行所有的、一个包的、一个类中所有的测试方法。
2) 执行完后，显示绿色表示测试成功；显示红色表示测试失败 抛异常后会测试失败) 。

06_Assert 断言工具类
断言方法：
Assert.assertSame expected，actual) ；预期值、真实的值。
Assert.assertEquals expected，actual) ；
Assert.assertNull expected，actual) ；
Assert.assertTrue expected，actual) ；
注意事项：
1) 如果测试一个方法的时候，需要准备测试的环境，或是清理测试的环境，
那么可以使用 @Before、@After、@BeforeClass、@AfterClass 这四个注解。
2) @Before、@After 是在每个测试方法测试的时候，都会调用一次；
如果 @Before 和 @After 之间有多个方法，就会单个依次测试，多次调用 @Before 和 @After。
3) @BeforeClass、@AfterClass 是在所有的测试方法测试之前和测试之后，调用一次而已；
@BeforeClass、@AfterClass 所标注的方法必须是静态方法。

其中有一些静态的工具方法 不符合期望就抛异常) ：
	assertTrue(...)；参数的值应是 true
	assertFalse(...)；参数的值应是 false 
	assertNull(...)；参数的值应是 null 值
	assertNotNull(...)；参数的值应是非 null 的值	
	assertSame(...)；使用==比较的结果为 true 表示同一个对象) 
	AssertNotSame(...)；使用==比较的结果为 false
	assertEquals(...)；两个对象 equals() 方法比较结果为 true
用于准备环境、清理环境的方法。
@Test
	表示单元测试方法。
@Before 
	所修饰的方法应是非 static 的 且没有参数，返回值为 void) 。
	表示这个方法会在本类中的每个单元测试方法之前都执行一次。
@After 
	所修饰的方法应是非 static 的 且没有参数，返回值为 void) 。
	表示这个方法会在本类中的每个单元测试方法之后都执行一次。
@BeforeClass 
	所修饰的方法应是 static 的 且没有参数，返回值为 void) 。
	表示这个方法会在本类中的所有单元测试方法之前执行，只执行一次。
@AfterClass 
	所修饰的方法应是 static 的 且没有参数，返回值为 void) 。
	表示这个方法会在本类中的所有单元测试方法之后执行，只执行一次。

07_内省 Introspector) 
内省：可以理解为一个变态的反射。
为什么要学内省：
开发框架时，经常需要使用 java 对象的属性来封装程序的数据，每次都使用反射技术完成此类操作过于麻烦，所以 sun 公司开发了一套 API，专门用于操作 java 对象的属性。
内省主要解决的问题：把对象的属性数据封装到对象中。
需求：
编写一个工厂方法，根据配置文件的内容，工厂方法返回对应的对象，并且把对象要有对应的属性值。
内省：
实体类：javaBean；
内省类：Introspector；
BeanInfo：获取所有的属性；
BeanUtils：
把对象的属性数据，封装到对象中。
BeanUtils 的好处：
1) BeanUtils 设置属性值的时候，如果属性是基本数据类型，BeanUtils 会自动转换数据类型；
2) BeanUtils 设置属性值的时候，底层是依赖与 get 和 set 方法来数值和获取属性值的；
3) BeanUtils 设置属性值的时候，如果设置的属性是其他引用类型，必须注册一个类型转换器。
ConvertUtils.register converter，Date.class) ；其中转换器需要自己写。
如果代码和文档有出入，需要把工具关联源代码；
convert Class type，Object value) ；type：目前所遇到的数据类型；value：目前参数的值。
BeanUtils.setProperty e，“id”,id) ；
工具类依赖其他工具类，需要日志文件。
使用步骤：
导包：logging、BeanUtils；
【doc：使用文档。】
内省是用于操作 java 对象的属性的，那么以下问题我们必须要清楚。
问题一：什么是 Java 对象的属性和属性的读写方法？
问题二：如何通过内省访问到 javaBean 的属性 ?
1. 通过 PropertyDescriptor 类操作 Bean 的属性.	
public static void testPropertyDescriptor() throws Exception{
	Person p = new Person();
	PropertyDescriptor propertyDescriptor = new PropertyDescriptor("id"，Person.class);
	//获取属性的写的方法。
	Method writeMethod = propertyDescriptor.getWriteMethod();
	Method readMethod = propertyDescriptor.getReadMethod();
	propertyDescriptor.getReadMethod();
	writeMethod.invoke(p，12);
	System.out.println(readMethod.invoke(p，null));
}
2. 通过 Introspector 类获得 Bean 对象的 BeanInfo，然后通过 BeanInfo 来获取属性的描述器 PropertyDescriptor) ，通过这个属性描述器就可以获取某个属性对应的 getter、setter 方法，然后通过反射机制来调用这些方法。
public static void testIntrospector() throws Exception{
	BeanInfo beanInfo = Introspector.getBeanInfo(Person.class);
	PropertyDescriptor[] descriptor = beanInfo.getPropertyDescriptors();
	for(PropertyDescriptor itemProperty ：descriptor){
		System.out.println(itemProperty.getReadMethod().getName());
	}
}
存在的问题：sun 公司的内省 API 过于繁琐；
Apache 组织结合很多实际开发中的应用场景开发了一套简单、易用的 API 操作 Bean 的属性——BeanUtils。
public static void main(String[] args) throws Exception {
	Person p = new Person();
	ConvertUtils.register(new Converter() {		
		public Object convert(Class type，Object value) {
			 try {
				if(value!=null){						 
					 SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy MM dd");
					 Date d = dateFormat.parse((String) value);
					 return d;
				 }
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}				
			return null;
		}
	}，Date.class);		
	BeanUtils.setProperty(p，"id"，"110");
	BeanUtils.setProperty(p，"name"，"狗娃");
	BeanUtils.setProperty(p，"birthDay"，"1992 12 12");
	System.out.println(p.getId() +"=="+ p.getName()+"======"+p.getBirthDay());
	}

08_Properties 类与配置文件
数据库的用户名和密码一般会保存到 properties 配置文件) 里面。
对于经常会发生变化的数据，我们可以定义在配置文件上，比栓数据库的用户名和密码。
配置文件的路径：
Properties 配置文件说明
Properties 类对应.properties 文件。文件内容是键值对，键值对之间使用"="或空格隔开。开头是"#"的表示注释
	Properties 类在加载.properties 文件时使用的 iso8859-1 的编码。所以这个文件中的中文要特殊处理：如果这个配置文件中有中文就必须要进行转义，使用 native2ascii.exe 命令操作：
native2ascii d：/my.properties d：/my2.properties	
	使用 Properties 类中的 load(InputStream) 方法可以加载配置文件，使用其中的 store(OutputStream) 方法可以保存配置到指定文件。
	更多的信息可以看 Properties 类的 API 文档。
加载配置文件
写配置文件
作业：使用 properties 读取配置文件，读取数据库的用户名、密码。并且打包成 jar 包。
使用 Properties 类
public class DBUtil {	
	static Properties properties = new Properties();	
	static{
		try {
			Class clazz = DBUtil.class;
			InputStreamReader fileReader =
			new InputStreamReader(clazz.getResourceAsStream("/db.properties"));
			properties.load(fileReader);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	public static String getUserName(){
		String userName =properties.getProperty("userName");
		return userName;
	}	
	public static String getPassword(){
		return	properties.getProperty("password");
	}
	public static void main(String[] args) {
		System.out.println("用户名："+ getUserName());
		System.out.println("密码："+ getPassword());
	}
}

09_文件路径
绝对路径：
一个文件的完整路径信息；一般是包括盘符的。
绝对路径的缺陷：
绝对路径是以盘符开头，但是有些系统是没有盘符的。
相对路径：
相对于当前程序的路径；就是执行 java 命令的时候，控制台所在的路径。
类文件路径：
使用 classpath 的路径，找对应的资源文件。
如果需要使用到类文件的路径，

以根目录或某盘符开头的路径 或者说完整的路径) 
例如：
c：/a.txt Windows 操作系统中) 
c：/xxx/a.txt Windows 操作系统中) 
/var/xx/aa.txt Linux 操作系统中) 
绝对路径的问题：比如 C：\abc\a.properties 文件路径，该路径在 windows 上执行没有 问题，但是如果把该项目移动到 linux 上面执行，该路径就会出现问题了，因为在 linux 上面没有 c 盘的，只有根目录\。
相对路径：
相对于当前路径的一个路径。例如当前文件夹为 c：/abc 时：相对路径 a.txt 表示 c：/abc/a.txt，相对路径 xx/a.txt = c：/abc/xx/a.txt		
. 表示当前文件夹
.. 表示上级文件夹
相对路径存在的问题：
相对路径是相对于目前执行 class 文件的时候，控制台所在的路径，这样子也会导致出现问题。
Java 程序中的相对路径
在 Java 程序中使用 File 时写相对路径，是指相对于执行 java 命令时当前所在的文件夹。
测试代码：
在命令行中使用 cd 命令切换到不同的路径下试试，可以看到以上所说的效果。
在 Eclipse 中，当前路径是工程的根目录。
classpath 路径
classpath 路径说明
在 Java 程序中，一般情况下使用绝对路径还是相对路径都不太合适，因为 Java 程序的 jar 包所放的位置不确定，执行 java 程序时当前的路径也不确定，所以不合适。一般在 Java 程序中我们会把资源放到 classpath 中，然后使用 classpath 路径查找资源。
Classpath 路径：就是使用 classpath 目前的路径。
获取 classpath 中的资源 InputStream) 



