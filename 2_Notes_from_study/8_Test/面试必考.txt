
面试必考


	Linux 基本操作
		ls，ifconfig，grep，less，tail，cp，scp，mv，mkdir，
	Git 基本操作
		add，commit，pull，push，
	
	数据库设计软件：PowerDesigner；
	建模设计：Rational Rose；
		UML：Unified Modeling Language
		关键：用例图、时序图。
		包括：用例图，类图，时序图，协作图和状态图；

	TCP / IP 四层参考模型：
		应用层：
			负责处理特定的应用程序细节。
			 (FTP，Telnet，Emai，DNS，SMTP，HTTP 等) 
		传输层 (运输层) ：
			主要为两台主机上的应用提供端到端的通信；
			 (TCP 和 UDP) 
		网络层 (网际互联层 / 互联网层) ：
			处理分组在网络中的活动，比如分组的选路；
			 (IP，ICMP，IGMP) 
		链路层 (数据链路层 / 网络接口层) ：
			包括操作系统中的设备驱动程序、计算机中对应的网络接口卡；
			
	SpringMVC 核心
		是什么：
			基于 mvc 模式 和 servlet 的开源框架；
			连接视图和服务的中间件，目前最流行的 web 项目表现层框架。
		为什么使用：
			功能强大，使用方便的轻量级开源框架；
		基本原理：
			http 请求到 web 服务器；
			DispatcherServlet 匹配请求路径；
			HandlerMapping 寻找对应的 Handler；
			HandlerAdapter 调用 Handler；
			Handler 处理数据后返回逻辑视图 ModelAndView；
			ViewResolve 把逻辑视图转化成真正的 View；
			Dispatcher 解析逻辑视图中的参数后放入视图，把结果返回给客户端。
		怎么使用：
			将服务层对象注入 SpringIOC 容器，
			然后配置配置过滤规则，
			编写对应的 controller 为视图提供访问接口。


	Servlet 核心
		是什么：
			处理 http 请求，生成动态网页，响应的技术；
		为什么使用：
			兼容性好；
		基本原理：
			生命周期：
				http 请求；
				服务器解析；
				创建实例：反射；
				初始化：init ( ) ；
				服务：service ( ) ；
				输出响应；
				响应完成；
				销毁：destroy ( )。
		怎么使用：
			继承 HttpServlet：
				HttpServletRequest；
				HttpServletResponce；
				HttpSession；

	多表联合查询
		多表联合查询 + 子查询 SQL 语句
			SELECT * FROM (
				SELECT u.username , ig.title , igp.content 
				FROM ph_interestgroupitem igp
				LEFT JOIN ph_user u 
					ON igp.uid = u.userid
				LEFT JOIN ph_interestgroup ig 
					ON igp.groupid = ig.id
				) js
			WHERE js.username = 'jaypark' ;

		多表联合查询
			select city_name,student_name,score 
			from student,score,city 
			where city.city_code=student.city_code and score.student_id=student.student_id;
			
			// 把城市名为“大蕉”的，分数乘于 2 展示出来
			select city_name,student_name,
			CASE WHEN city.city_name='大蕉' 
			THEN 2*score.score 
			ELSE score 
			END score 
			from student,score,city 
			where city.city_code=student.city_code and score.student_id=student.student_id
		
			// 把城市名为“大蕉”，并且城市 Code 小于 10086 的，分数乘于 2 展示出来
			
			// SearchItemMapper.xml
			SELECT
				a.id,
				a.title,
				a.sell_point,
				a.price,
				a.image,
				b. NAME category_name,
				c.item_desc
			FROM
				tb_item a
			LEFT JOIN tb_item_cat b ON a.cid = b.id
			LEFT JOIN tb_item_desc c ON a.id = c.item_id
			WHERE
				a.`status` = 1
			 AND
				a.id=#{itemId}
				
			// 查询所有学生及他们的选择课程的信息
				select s.*,c.* 
				from tb_student s,tb_course c,tb_select_course sc
				where s.s_id=sc.sc_s_id
				and c.c_id=sc.sc_c_id
		聚合函数
			SELECT productline, AVG(buyprice) 'Avarage Price' 
			FROM products 
			GROUP BY productline 
			HAVING AVG(buyprice) > 50;

	
	泛型
		编译时擦除；
		尖括号注意。
	
	Spring 依赖注入的三种方式：
		interface：
			@Resource
			private UserService userService;
		setter：
			private UserDao userDao;
			@Resource
			public void setUserDao(UserDao userDao) {
				super.setBaseDao(userDao);
				this.userDao = userDao;
			}
		constructor：
			private UserService userService;
			@Resource
			public LoginAction( UserService userService;) {
				this.userService = userService;
			}
		属性注入：
			@Autowired
			private FreeMarkerConfigurer freeMarkerConfigurer;
			
		1、自动装配
			通过配置 applicationContext.xml 中的<beans>标签的 default-autowire 属性，
			或者<bean>标签的 autowire 属性，可以配置 IOC 容器的自动装配机制为 byName，byType 等。

		2、配置文件 ref 配置
			通过配置 applicationContext.xml 中<bean>标签下的<property>的属性 ref 来注入实例。

		3、@Resource 注解注入
			使用 @Resource 注解注释需要注入的依赖声明。
	
	
	Spring 常用注解
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Lamda 表达式
		 () -> 
		
	Hibernate 和 Mybatis；
		Hibernate 更加笨重一点，写的 hql，如果数据库移植的话比较简单；
		MyBatis 写的是原生的 sql 语句，体量大的公司能更好的满足自己的业务需求；
		sql 还是比 hql 更加灵活的。
		
	Git 和 SVN
		Git 处理冲突更好；文件版本管理；分支管理；
		可以新建分支做备份，以及 Feture，需要的时候合并到 master 里面

	快排算法
		将一个数组划分成两个子数组，
		通过递归调用自身来排序；
			需要设定关键字，比关键字小的放左边一组。
			可以设定最右端的数据为关键字。
		核心思想：
			二分法；递归。
		属性：
			关键字：point；
			左起点：left；
			右起点：right；
			左指针：leftPtr；
			右指针：rightPtr；
		// 划分数组
		public static int partition(long arr[], int left, int right, long point) {
			int leftPtr = left - 1;
			int rightPtr = right;
			while (true) {
				// 循环, 将比关键字小的留在左端
				while (leftPtr < rightPtr && arr[++leftPtr] < point) ;
				// 循环，将比关键字大的留在右端
				while (rightPtr > leftPtr && arr[--rightPtr] > point) ;
				if (leftPtr >= rightPtr) {
					break;
				} else {
					long tmp = arr[leftPtr];
					arr[leftPtr] = arr[rightPtr];
					arr[rightPtr] = tmp;
				}
			}
			// 将关键字和当前 leftPtr 所指的这一个进行交换
			long tmp = arr[leftPtr];
			arr[leftPtr] = arr[right];
			arr[right] = tmp;
			return leftPtr;
		}
		public static void quickSort(long[] arr, int left, int right) {
			if (left - right >= 0) {
				return;
			} else {
				// 设置关键字
				long point = arr[right];
				// 获得切入点，同时对数组进行划分
				int partition = partition(arr, left, right, point);
				// 对左边的子数组进行快速排序
				quickSort(arr, left, partition - 1);
				// 对右边的子数组进行快速排序
				quickSort(arr, partition + 1, right);
			}
		}
	
	
		单例模式
		单例模式
			确保一个类最多只有一个实例；
			并提供一个全局访问点。
		实现方式
			私有构造器，保证外部类的 new 不奏效；
			然后在类里面 new 一个实例；
			然后静态 get 方法返回该实例，供全局调用。
		案例：
			巧克力工厂。
		单例类
			private static Single uniqueInstance=null;
			private Single(){};
			public static Single getInstance(){
				if(uniqueInstance==null){
					uniqueInstance=new Single();
				}
				return uniqueInstance;
			}
		经典单例模式
			需求：线程池、缓存、打印机；
			多个实例有可能造成冲突，结果不一致。
			可以使用静态变量、全局变量实现替代。
		经典单例模式的优化
			同步锁解决多线程问题
			使用 getInstance 频率少，性能要求低的情况。
			private static Single uniqueInstance = null;
			private Single(){};
			public static synchronized Single getInstance(){
				if(uniqueInstance == null){
					uniqueInstance=new Single();
				}
				return uniqueInstance;
			}
			急切创建线程
			不需要再进入同步锁；
			private static Single uniqueInstance = new Single;
			双重检查加锁
			同步锁只需要进入一次。
			private volatile static Single uniqueInstance = null;
			private Single(){};
			public static synchronized Single getInstance(){
				if(uniqueInstance == null){
				synchronized (Single.class){
					if(uniqueInstance == null){
						uniqueInstance=new Single();
					}
				}
				)
				return uniqueInstance;
			}
	
	
	
	
		
	JVM
		内存模型，垃圾回收算法，以及垃圾回收器，G1 和 CMS


	锁和 JUC 包


	applicationContext.xml 配置文件如下:
		<bean id="logic" class="com.spring.test.di.LogicImpl"/>
			<bean id="loginAction" class="com.spring.test.di.LoginAction">
				<property name="logic" ref="logic"></property>
			</bean>

	Complain.hbm.xml
		<hibernate-mapping>
		 <class name="cn.itcast.nsfw.complain.entity.Complain" table="complain">
			<id name="compId" type="java.lang.String">
			 <column name="comp_id" length="32" />
			 <generator class="uuid.hex" />
			</id>
			<property name="compCompany" type="java.lang.String">
			 <column name="comp_company" length="100" />
			</property>
			<property name="compName" type="java.lang.String">
			 <column name="comp_name" length="20" />
			</property>
			<property name="compMobile" type="java.lang.String">
			 <column name="comp_mobile" length="20" />
			</property>
			<property name="isNm" type="java.lang.Boolean">
			 <column name="is_NM" />
			</property>
			<property name="compTime" type="java.sql.Timestamp">
			 <column name="comp_time" length="19" />
			</property>
			<property name="compTitle" type="java.lang.String">
			 <column name="comp_title" length="200" not-null="true" />
			</property>
			<property name="toCompName" type="java.lang.String">
			 <column name="to_comp_name" length="20" />
			</property>
			<property name="toCompDept" type="java.lang.String">
			 <column name="to_comp_dept" length="100" />
			</property>
			<property name="compContent" type="text">
			 <column name="comp_content"/>
			</property>
			<property name="state" type="java.lang.String">
			 <column name="state" length="1" />
			</property>
			<set name="complainReplies" inverse="true" cascade="save-update,delete" lazy="false" order-by="reply_time">
			 <key>
				<column name="comp_id" length="32" not-null="true" />
			 </key>
			 <one-to-many class="cn.itcast.nsfw.complain.entity.ComplainReply" />
			</set>
		 </class>
		</hibernate-mapping>
		
	ComplainReply.hbm.xml
		<hibernate-mapping>
		 <class name="cn.itcast.nsfw.complain.entity.ComplainReply" table="complain_reply">
			<id name="replyId" type="java.lang.String">
			 <column name="reply_id" length="32" />
			 <generator class="uuid.hex" />
			</id>
			<many-to-one name="complain" class="cn.itcast.nsfw.complain.entity.Complain" fetch="select">
			 <column name="comp_id" length="32" not-null="true" />
			</many-to-one>
			<property name="replyer" type="java.lang.String">
			 <column name="replyer" length="20" />
			</property>
			<property name="replyDept" type="java.lang.String">
			 <column name="reply_dept" length="100" />
			</property>
			<property name="replyTime" type="java.sql.Timestamp">
			 <column name="reply_time" length="19" />
			</property>
			<property name="replyContent" type="java.lang.String">
			 <column name="reply_content" length="300" />
			</property>
		 </class>
		</hibernate-mapping>
		
	complain-struts.xml
		<struts>
			<package name="complain-action" namespace="/nsfw" extends="base-default,json-default">
				<action name="complain_*" class="cn.itcast.nsfw.complain.action.ComplainAction" method="{1}">
					<result name="{1}">/WEB-INF/jsp/nsfw/complain/{1}.jsp</result>
					<result name="list" type="redirectAction">
						<param name="actionName">complain_listUI</param>
						<param name="complain.compTitle">${strTitle}</param>
						<param name="complain.state">${strState}</param>
						<param name="startTime">${startTime}</param>
						<param name="endTime">${endTime}</param>
						<param name="pageNo">${pageNo}</param>
						<param name="encode">true</param>
					</result>
					<result type="json" name="annualStatisticData">
						<param name="root">statisticMap</param>
					</result>
				</action>
			</package>
		</struts>
		
	第三张表
		public class StudentCourseLink {
		 private Student student;
		 private Course course;
		 private Date date;

		 public StudentCourseLink() {

		 }

		 public StudentCourseLink(Student student, Course course, Date date) {
			this.student = student;
			this.course = course;
			this.date = date;
		 }

		 public Student getStudent() {
			return student;
		 }

		 public void setStudent(Student student) {
			this.student = student;
		 }

		 public Course getCourse() {
			return course;
		 }

		 public void setCourse(Course course) {
			this.course = course;
		 }

		 public Date getDate() {
			return date;
		 }

		 public void setDate(Date date) {
			this.date = date;
		 }

		}
		
	StudentMapper.xml 的配置：
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org/DTD Mapper 3.0" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
		<mapper namespace="gler.mybatis.manytomany.mapper.StudentMapper">
		 <!-- 查询所有学生及他们的选择课程的信息 -->
		 <select id="selectStudentCourse" resultMap="studentCourseMap">
			select
			s.*,c.* from
			tb_student s,tb_course c,tb_select_course sc
			where s.s_id=sc.sc_s_id
			and c.c_id=sc.sc_c_id
		 </select>

		 <!-- 根据学生 id 和课程 id 删除该学生该门课的选课情况 -->
		 <delete id="deleteStudentCourseById" parameterType="StudentCourseLink"> 
			delete from tb_select_course where sc_s_id=#{student.id} and sc_c_id=#{course.id}
		 </delete> 

		 <!-- resultMap:映射实体类和字段之间的一一对应的关系 -->
		 <resultMap id="studentCourseMap" type="Student">
			<id property="id" column="s_id" />
			<result property="name" column="s_name" />
			<result property="sex" column="s_sex" />
			<result property="age" column="s_age" />
			<!-- 多对多关联映射：collection -->
			<collection property="courses" ofType="Course">
			 <id property="id" column="c_id" />
			 <result property="name" column="c_name" />
			 <result property="credit" column="c_credit" />
			</collection>
		 </resultMap>
		</mapper>
		
		
		
		
		
		
		
		
		
		
		
		
		
		