
JavaSE 


JavaSE 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		
	怎么使用：



关键字

goto 和 const 是保留字也是关键字。
1，Java 关键字列表 (依字母排序 共 50 组)：
abstract, assert, boolean, break, byte, case, catch, char, class, const (保留关键字) , continue, default, do, double, else, enum, extends, final, finally, float, for, goto (保留关键字) , if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
2，保留字列表 (依字母排序 共 14 组)，Java 保留字是指现有 Java 版本尚未使用，但以后版本可能会作为关键字使用：
byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto (保留关键字) , const (保留关键字) , null




final 所修饰的成员变量只能赋值一次，可以在类方法中赋值，也可以在声明的时候直接赋值，
而 final 修饰的局部变量可以在声明的时候初始化，也可以在第一次使用的通过方法或者表达式给它赋值。

final 修饰的成员变量为基本数据类型是，在赋值之后无法改变。
当 final 修饰的成员变量为引用数据类型时，在赋值后其指向地址无法改变，但是对象内容还是可以改变的。
final 修饰的成员变量在赋值时可以有三种方式。
1、在声明时直接赋值。2、在构造器中赋值。3、在初始代码块中进行赋值。

final 关键字可用于修饰类、变量和方法。
final 修饰的类不能被继承，final 修饰的方法不能被重写，final 修饰的变量不可被修改，一旦获得初始值，该变量就不能被重新赋值。
1.final 修饰变量，则等同于常量
2.final 修饰方法中的参数，称为最终参数。
3.final 修饰类，则类不能被继承
4.final 修饰方法，则方法不能被重写。

public：访问控制修饰符，用于修饰类、类的方法、属性或者构造器。
abstract：用于修饰抽象类或者抽象方法
static：用于修饰类、方法或者成员变量，表明该类是静态类或者方法、成员变量属于当前类
static 的类是内部类，可以被任何有该内部类访问权限的其他类继承，包括静态、非静态、局部、匿名内部类和外部类
静态成员和静态方法，可以直接通过类名进行调用；其他的成员和方法则需要进行实例化成对象之后，通过对象来调用。
static 不能用来修饰类，除非类是内部类，此时该类作为外部类的成员变量，可以用 static 来修饰

abstract 修饰一个类，这个类肯定可以被继承，但是 final 类是不能继承的，所以不能同时用。


声明为 static 和 transient 类型的成员数据不能被串行化。
因为 static 代表类的状态，transient 代表对象的临时数据。
transient 修饰的变量在对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是 null。


我们都知道一个对象只要实现了 Serilizable 接口，这个对象就可以被序列化，java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serilizable 接口，这个类的所有属性和方法都会自动序列化。

这个类的有些属性需要序列化，而其他属性不需要被序列化；
java 的 transient 关键字为我们提供了便利，你只需要实现 Serilizable 接口，将不需要序列化的属性前添加关键字 transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。


Volatile 修饰符，是针对多线程情况下出现的。
当线程读取它修饰的变量时，都会强迫从主存中重新读取。

volatite 只保证线程在“加载数据阶段”加载的数据是最新的，并不能保证线程安全。

一个线程执行的过程有三个阶段：
加载 (复制) 主存数据到操作栈 --> 对操作栈数据进行修改 --> 将操作栈数据写回主存
volatite 关键字，让编译器不去优化代码使用缓存等，以保证线程在“加载数据阶段”加载的数据都是最新的

一旦一个共享变量 (类的成员变量、类的静态成员变量) 被 volatile 修饰之后，那么就具备了两层语义：

1) 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2) 禁止进行指令重排序。

volatile 只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值。

而对该变量的修改，volatile 并不提供原子性的保证。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。

多线程下计数器必须使用锁保护。

volatile 的措施：
1. 每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile 修饰的共享变量，每次的更新对于其他线程都是可见的。
2. volatile 保证了其他线程的立即可见性，就没有保证原子性。
3. 由于有些时候对 volatile 的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。




<< 表示左移位
>> 为带符号右移，右移后左边的空位被填充为符号位
>>> 为不带符号右移，右移后左边的空位被填充为 0
但是没有<<<运算符

在 java 中一个 unicode 占 2 个字节 (byte) 。
一个字节等于 8 比特位 (bit) 。
所以每个 Unicode 码占用 16 个比特位。

Java 语言中，中文字符所占的字节数取决于字符的编码方式，
一般情况下，采用 ISO8859-1 编码方式时，一个中文字符与一个英文字符一样只占 1 个字节；
采用 GB2312 或 GBK 编码方式时，一个中文字符占 2 个字节；而采用 UTF-8 编码方式时，一个中文字符会占 3 个字节。
在 C++ 中，char 是基础数据类型，8 位，1 个字节。
byte 不是基础数据类型，一般是 typedef unsigned char byte;
也就是说，byte 其实是 unsigned char 类型，那么也是 8 位，1 个字节。
不同的是，char 可以表示的范围是-128-127，而 byte 可以表示的范围是 0-255。
在 java 中，char 和 byte 都是基础数据类型，其中的 byte 和 C++ 中的 char 类型是一样的，8 位，1 个字节，-128-127。
但是，char 类型，是 16 位，2 个字节，'\u0000'-'\uFFFF'。
为什么 java 里的 char 是 2 个字节？

因为 java 内部都是用 unicode 的，所以 java 其实是支持中文变量名的，比如 string 世界 = "我的世界";这样的语句是可以通过的。


1、boolean 类型只有两个直接量值:true 和 false.
2、除成员变量会有默认初始值外，其他变量必须在第一次使用之前初始化。
boolean 类型的默认值是 false；
其余的 7 种基本类型默认值：
byte 是 (byte)0；
short 是 (short)0；
int 是 0；
long 是 0L；
float 是 0.0f；
double 是 0.0d；
char 是 \u0000.
String 是 null.




低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte<char<short<int<long<float<double

char < short < int < float < double 不同类型运算结果类型向右边靠齐。

1. 在表达式中，char 和 short 类型的值，无论有符号还是无符号，都会自动转换成 int 或者 unsigned int (如果 short 的大小和 int 一样，unsigned short 的表示范围就大于 int，在这种情况下，unsigned short 被转换成 unsigned int) 。因为它们被转换成表示范围更大的类型，故而把这种转换称为“升级 (promotion) ”。

2. 按照从高到低的顺序给各种数据类型分等级，依次为：long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int 和 int。这里有一个小小的例外，如果 long 和 int 大小相同，则 unsigned int 的等级应位于 long 之上。char 和 short 并没有出现于这个等级列表，是因为它们应该已经被升级成了 int 或者 unsigned int。

3. 在任何涉及两种数据类型的操作中，它们之间等级较低的类型会被转换成等级较高的类型。




a. 实例方法可以调用超类公有实例方法
b. 实例方法可以直接调用超类的公有类方法
d. 实例方法可以通过类名调用其他类的类方法

类方法即静态方法，加了 static 关键字的，实例方法则没有

非静态可以调用静态，静态不能调用非静态


功能性注释：
java 文档注释包括代码的功能描述，作者，最后一次修改的时间，所以一旦改动了代码，时间肯定会变的！
注释哪些部分：
1、Java 文件：必须写明版权信息以及该文件的创建时间和作者； 
2、类：类的目的、即类所完成的功能，以及该类创建的时间和作者名称；多人一次编辑或修改同一个类时，应在作者名称处出现多人的名称； 
3、接口： 在满足类注释的基础之上，接口注释应该包含设置接口的目的、它应如何被使用以及如何不被使用。在接口注释清楚的前提下对应的实现类可以不加注释； 
4、方法注释： 对于设置 (Set 方法 ) 与获取 (Get 方法 ) 成员的方法，在成员变量已有说明的情况下，可以不加注释；普通成员方法要求说明完成什么功能，参数含义是什么且返回值什么；另外方法的创建时间必须注释清楚，为将来的维护和阅读提供宝贵线索； 
5、方法内部注释： 控制结构，代码做了些什么以及为什么这样做，处理顺序等，特别是复杂的逻辑处理部分，要尽可能的给出详细的注释； 
6、参数： 参数含义、及其它任何约束或前提条件； 
7、属性： 字段描述； 
8、局部 ( 中间 ) 变量： 无特别意义的情况下不加注释。


1. 抽象方法只能定义在抽象类中，抽象方法和抽象类必须由 abstract 修饰，abstract 关键字只能描述类和方法，不能描述变量。
抽象方法只定义方法声明，不定义方法实现。
抽象类不可以被实例化 (创建对象) ，只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，
否则该子类还是一个抽象类。
抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。
abstract 关键字不可以与 final，private,static 关键字共存，因为被 final 修饰的方法不可以被重写，意味着子类不可以重写该方法，
如果 abstract 和 final 共同修饰父类中的方法，子类要实现抽象方法 (abstract 的作用) ，而 final 又不让该方法重写，这相互矛盾。
如果 private 和 abstract 共同修饰父类中的方法，private 修饰则该方法不可以被子类访问，但是 abstract 修饰需要子类去实现，两者产生矛盾。
如果 static 和 abstract 共同修饰父类中的方法，static 表示是静态的方法，随着类的加载而加载，
则该方法不需要在子类中去实现，这与 abstract 关键字矛盾。

 2.static 用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在。
静态方法只能访问静态成员 (静态方法和静态变量) ，不可以访问非静态成员，这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
静态方法中不能使用 this 和 super 关键字，因为 this 代表本类对象，super 代表父类对象，而静态时，有可能没有对象存在，所以 this 和 super 无法使用。

3.final 关键字可以修饰类，方法，变量 (成员变量内，局部变量，静态变量) ，被 final 修饰的类是一个最终类，不可以被继承，被 final 修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。被 final 修饰的变量只能是一个常量，只能赋值一次。内部类被定义在类中的局部位置上时，只能访问局部被 final 修饰的局部变量。

 (1) 对于 public 修饰符，它具有最大的访问权限，可以访问任何一个在 CLASSPATH 下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
 (2) 对于 protected 修饰符，它主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。
 (3) 对于 default 来说，有点的时候也成为 friendly (友员) ，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用 protected 修饰的成员也可以。
 (4) 对于 private 来说，它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是修饰符为 private 的，它们不希望被其他任何外部的类访问。


可以把局部内部类当做一个局部变量，所以它是不需要加任何修饰符的
局部内部类前不能用修饰符 public 和 private,protected
内部类就随意了。


1.Object 中没有 hasNext () 方式，这个方法是迭代器中的
2.Object 没有 copy 方法，但是有 clone() 方法，用于创建并返回该对象的一个副本

Object 中的方法

1．clone 方法
 保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。
2．getClass 方法
 final 方法，获得运行时类型。
3．toString 方法
 该方法用得比较多，一般子类都有覆盖。
4．finalize 方法
 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
5．equals 方法
 该方法是非常重要的一个方法。一般 equals 和==是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。
6．hashCode 方法
 该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。
 一般必须满足 obj1.equals(obj2)==true。可以推出 obj1.hash- Code()==obj2.hashCode()，但是 hashCode 相等不一定就满足 equals。
 不过为了提高效率，应该尽量使上面两个条件接近等价。
7．wait 方法
 wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。
 wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。
 调用该方法后当前线程进入睡眠状态，直到以下事件发生。
 (1) 其他线程调用了该对象的 notify 方法。
 (2) 其他线程调用了该对象的 notifyAll 方法。
 (3) 其他线程调用了 interrupt 中断该线程。
 (4) 时间间隔到了。
 此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。
8．notify 方法
 该方法唤醒在该对象上等待的某个线程。
9．notifyAll 方法
 该方法唤醒在该对象上等待的所有线程。



差异

	过滤器 和 拦截器：


	springMVC 中 @RequestParam 与 @PathVariable：
		@PathVariable 是用来获得请求 url 中的动态参数的
			@PathVariable 用于将请求 URL 中的模板变量映射到功能处理方法的参数上。
		在 SpringMVC 后台控制层获取参数的方式主要有两种:
			一种是 request.getParameter("name")，另外一种是用注解 @RequestParam 直接获取

方法重载 (overload) ：
1. 必须是同一个类
2 方法名 (也可以叫函数) 一样
3 参数类型不一样或参数数量不一样

方法的重写 (override) 两同两小一大原则：
方法名相同，参数类型相同；
子类返回类型小于等于父类方法返回类型，
子类抛出异常小于等于父类方法抛出异常，
子类访问权限大于等于父类方法访问权限。
方法重载的返回值的类型可以不同，因为判断方法重载的方法主要是根据方法的参数不同来判定；方
法重写的返回值类型需要相同，重写就是子类继承了父类的方法，并在此方法上重写属于自己的特征，
既然是继承过来的，那么它的返回值类型就必须要相同



Override：方法重写：在子类中，出现和父类中一模一样的方法声明的现象。
Overload：方法重载：同一个类中，出现的方法名相同，参数列表不同的现象。

方法重载能改变返回值类型，因为它和返回值类型无关。

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。
原则如下：
一. 方法名一定要相同。
二. 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
1. 如果参数个数不同，就不管它的参数类型了！
2. 如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
三. 方法的返回类型、修饰符可以相同，也可不同。







接口中的变量，默认是 public static final 的，接口中的方法，默认是 public abstract 的。
interface 只能被 public，abstract 修饰。这里的数据成员修饰符也就是 public。

在 interface 里面的变量都是 public static final 的。
所以你可以这样写：
public static final int i=10;
int i=10； (可以省略掉一部分) 

注意在声明的时候要给变量赋予初值。

解释：

接口：提供一种统一的’协议’, 而接口中的属性也属于’协议’中的成员. 它们是公共的, 静态的, 最终的常量. 相当于全局常量.
抽象类：不’完全’的类, 相当于是接口和具体类的一个中间层. 即满足接口的抽象, 也满足具体的实现.
如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。
有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。
如果接口 A 中有一个 public 访问权限的静态变量 a。
按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx;就可以改变接口中的变量 a 的值了。
正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，
也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。
这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？
所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。
所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。
通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。
对修改关闭，对扩展 (不同的实现 implements) 开放，接口是对开闭原则的一种体现。



方法的重写需要满足：三同一大一小 (方法名、返回值类型、形参相同；访问权限>=重写前；抛出异常<=重写前) 

接口，比抽象类还要抽象的类。
接口中每一个方法也是隐式抽象的, 接口中的方法会被隐式的指定为 public abstract (只能是 public abstract，其他修饰符都会报错) 。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量 (并且只能是 public，用 private 修饰会报编译错误。) 
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
注：
接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。
接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。
接口中的方法都是公有的。public。




建一个接口，然后一个类 implements 这个接口，并且不能为任何抽象方法提供任何细节或方法体时，
这个类必须是抽象类，并 override 的所有方法。
然后再建一个普通类 extends 这个抽象类，就可以为所欲为了。
这种情况就是 java 设计模式中的适配器模式。

抽象类：
用 abstract 修饰，抽象类中可以没有抽象方法，但抽象方法肯定在抽象类中，且抽象方法定义时不能有方法体；
抽象类不可以实例化只能通过继承在子类中实现其所有的抽象方法；
抽象类如果不被继承就没有任何意义；
抽象类为子类定义了一个公共类型，封装了子类中的重复内容。
接口:
同 Interface 关键字定义接口，是特殊的抽象类因为类中只包含抽象方法；
接口中不能定义成员变量可以定义常量；
接口是其通过其他类使用 implements 关键字定义实现类，
一个类一旦实现接口就必须实现其中的所有抽象方法，一个类可以实现多个接口，
接口名之间用逗号隔开即可；
一个接口可以通过 extends 关键字继承另一个接口，与此同时继承了父类中的所有方法。


包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。
注意，抽象类和普通类的主要有三点区别：
1) 抽象方法必须为 public 或者 protected (因为如果为 private，则不能被子类继承，子类便无法实现该方法) ，缺省情况下默认为 public。
2) 抽象类不能用来创建对象；
3) 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。
在其他方面，抽象类和普通的类并没有区别。

基类是抽象类，子类继承父类，但是没有实现基类的抽象方法，那么子类也是抽象类。
抽象类不能创建对象，所以在主函数中创建对象编译不会通过。

当一个实体类继承一个抽象类，必须实现抽象类中的抽象方法。









构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。

匿名内部类的创建格式为： new 父类构造器 (参数列表) |实现接口 () {
//匿名内部类的类体实现
}

使用匿名内部类时，必须继承一个类或实现一个接口
匿名内部类由于没有名字，因此不能定义构造函数
匿名内部类中不能含有静态成员变量和静态方法



sleep 和 wait 的区别有：
1，这两个方法来自不同的类分别是 Thread 和 Object
2，最主要是 sleep 方法没有释放锁，而 wait 方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。
3，wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在
任何地方使用
synchronized(x){
x.notify()
//或者 wait()
}
4,sleep 必须捕获异常，而 wait，notify 和 notifyAll 不需要捕获异常



equals 重写的源码：会先用 instanceof 比较是否属于该类，如果不属于，直接返回 false。

ABC，不同类型引用的 == 比较，会出现编译错误，不能比较。

DEF，因为此方法先是比较类型，而 i，d，l 是不同的类型，所以返回假。

G，会自动装箱，将 42L 装箱成 Long 类型，所以调用 equals 方法时，类型相同，且值也相同，因此返回真。

包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱；
包装类的 equals() 方法不处理数据转型。

==：比较的是两个对象的地址

equals：比较的是两个对象的内容





重新说下 String 的 equals 方法，不是说所有类的 equals 方法都只判断值。

例如 Object 的 equals 方法的作用和==是相同的，都是判断引用。
只不过 String 类重写了 Object 的 equals 方法而已。

先判断地址是否相等，如果相等直接返回 true.
否则先判断是否是 String 类型的，如果是在判断每个字符是否相等，如果都相等返回 true，其余情况返回 false



String 类是 final 类型的，不能继承和修改这个类。

string 是值传递，stringbuffer 是引用传递。

Java 参数，不管是原始类型还是引用类型，传递的都是副本 (有另外一种说法是传值，但是说传副本更好理解吧，传值通常是相对传址而言)。
如果参数类型是原始类型，那么传过来的就是这个参数的一个副本，也就是这个原始参数的值，这个跟之前所谈的传值是一样的。
如果在函数中改变了副本的 值不会改变原始的值. 
如果参数类型是引用类型，那么传过来的就是这个引用参数的副本，这个副本存放的是参数的地址。
如果在函数中没有改变这个副本的地址，而是改变了地址中的 值，那么在函数内的改变会影响到传入的参数。
如果在函数中改变了副本的地址，如 new 一个，那么副本就指向了一个新的地址，
此时传入的参数还是指向原来的 地址，所以不会改变参数的值。



object 类――众类鼻祖 
1. 取得对象信息：toString():对象输出时，会默认调用 Object 类的 toString() 方法，将对象信息变为字符串返回。
2. 对象相等判断方法：equals():两个对象进行比较时，实际上是比较两个对象的地址值 (从程序看出两个对象内容完全相等，但是结果是不相等的，这是因为 classa 与 classb 的内容分别在不同的内存空间指向了不同的内存地址) 。
所以要对 equals() 进行覆写，判断 equals() 方法里面的 Object 类对象是否与调用 equals() 的类是同一个类的实例 (用 instanceof 判断)，如果是，则进行向下转型，然后再调用 String 类中的 equals 方法对属性进行比较。
3. 对象签名：hashCode():Object 类有两种方法来推断对象的标识：equals() 和 hashCode()。
如果根据 equals() 方法判断两个对象是相等的，那么对这两个对象中的每一个调用 hashCode() 方法都必然生成相同的整数结果。
但是反过来，如果两个 hashCode() 返回的结果相等，两个对象的 equals() 方法却不一定相等。
在默认情况下 equals() 方法用来比较两个对象的地址值，而原始的 hashCode() 方法用来返回其所在对象的物理地址
 (ps：对于非字符串变量而言，equals 和==比较的是地址，对于字符串变量而言 equals() 比较的是内容==比较地址) 



class A {}
class B extends A {}
class C extends A {}
class D extends B {}
Which four statements are true ?
The type List<A>is assignable to List.
The type List<B>is assignable to List<A>.
The type List<Object>is assignable to List<?>.
The type List<D>is assignable to List<?extends B>.
The type List<?extends A>is assignable to List<A>.
The type List<Object>is assignable to any List reference.
The type List<?extends B>is assignable to List<?extends A>.
1. 只看尖括号里边的, 明确点和范围两个概念
2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如 List<A>,List<B>,List<Object>
3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于 A 的范围，<? super A>代表大于等于 A 的范围，<?>代表全部范围
4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点
5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
6. List<?>和 List 是相等的，都代表最大范围
7. 补充：List 既是点也是范围，当表示范围时，表示最大范围



在类方法中调用本类的类方法可直接调用。实例方法也叫做对象方法。
类方法是属于整个类的，而实例方法是属于类的某个对象的。
由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。
即类方法体有如下限制：
(1) 类方法中不能引用对象变量；
(2) 类方法中不能调用类的对象方法；
(3) 在类方法中不能使用 super、this 关键字。
(4) 类方法不能被覆盖。

如果违反这些限制，就会导致程序编译错误。

与类方法相比，对象方法几乎没有什么限制：
(1) 对象方法中可以引用对象变量，也可以引用类变量；
(2) 对象方法中可以调用类方法；
(3) 对象方法中可以使用 super、this 关键字。


构造方法不带返回值，而普通方法是必须有返回值的，这就是区别他们的方法。

1. 构造方法也是类的方法，可以在创建对象时为成员变量赋值；
2. 构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分；
3. 构造方法没有返回值；
4. 构造方法一定要与定义为 public 的类同名；
5. 构造方法不能被对象调用，只会创建对象，使用 new 关键字。


Math 类中提供了三个与取整有关的方法：ceil,floor,round。
这些方法的作用于它们的英文名称的含义相对应：
 ceil 的英文意义是天花板，该方法就表示向上取整，Math.ceil (11.3) 的结果为 12，Math.ceil(-11.6) 的结果为-11；
 floor 的英文是地板，该方法就表示向下取整，Math.floor(11.6) 的结果是 11，Math.floor(-11.4) 的结果-12；
 round 方法，他表示“四舍五入”，算法为 Math.floor(x+0.5), 即将原来的数字加上 0.5 后再向下取整，
所以，Math.round(11.5) 的结果是 12，Math.round(-11.5) 的结果为-11.

ceil 方法上有这么一段注释：
If the argument value is less than zero but greater than -1.0, then the result is negative zero
如果参数小于 0 且大于-1.0，结果为 -0

ceil 和 floor 方法 上都有一句话：
If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument，
如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，
如果是 -0.0，那么其结果是 -0.0





















