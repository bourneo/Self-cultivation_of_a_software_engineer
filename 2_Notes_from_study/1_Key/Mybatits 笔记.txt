
Mybatits


Mybatits 核心
	是什么：
		目前最受欢迎的持久层开源框架；基于 ORM 实现；
	为什么使用：
		提供两级缓存；JavaBean 和 DAO类 实现可以自动生成；简化开发步骤；提供了实用的插件，如：PageHelper。
	基本原理：
		数据库交互：
		数据处理：
		事务管理：
		连接池管理：
		缓存机制：
			一级缓存：会话级别的缓存，判断是否是同一个会话的四个条件；生命周期是 SqlSession 对象的生命周期。
			二级缓存：每一个 Mapper 都可以拥有一个 Cache 对象；
			查询顺序：二级缓存 ——> 一级缓存 ——> 数据库。
	怎么使用：
		配置数据库驱动；
		配置连接池；
		配置事务；
		配置事务声明；
		配置事务切入；
		建表后逆向生成 JavaBean 和 DAO 实现类；
		手写 SQL 语句。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	mybatis 中 # 和 $ 的区别

		1. # 将传入的数据都当成一个字符串，自动为传入的数据加一个双引号。
			如：order by #user_id#，
			如果传入的值是111,那么解析成sql时的值为order by "111", 
			如果传入的值是id，则解析成的sql为order by "id".
		　　
		2. $ 将传入的数据直接显示生成在sql中。
			如：order by $user_id$，
			如果传入的值是111,那么解析成sql时的值为order by user_id,  
			如果传入的值是id，则解析成的sql为order by id.
		　　
		3. # 方式能够很大程度防止sql注入。
		　　
		4.$ 方式无法防止Sql注入。

		5.$ 方式一般用于传入数据库对象。
			例如传入表名.
		　　
		6.一般能用 # 的就别用 $.

		注意：MyBatis 排序时使用 order by  动态参数时需要注意，用 $ 而不是 #。

	字符串替换
	
		默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。
		这样做很安全，很迅速也是首选做法，有时你只是想直接在SQL语句中插入一个不改变的字符串。
			比如，像ORDER BY，你可以这样来使用：
				ORDER BY ${columnName}
			这里MyBatis不会修改或转义字符串。
		注意：
			接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。
			这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。
				
		
缓存机制小结

	MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存：
		一级缓存：Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。
			一级缓存是MyBatis内部实现的一个特性，用户不能配置，
			默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）。

		二级缓存：Application应用级别的缓存，它的是生命周期很长，跟Application的声明周期一样，
			也就是说它的作用范围是整个Application应用。

	一级缓存的工作机制：

		一级缓存是Session会话级别的，
		一般而言，一个SqlSession对象会使用一个Executor对象来完成会话操作，Executor对象会维护一个Cache缓存，以提高查询性能。

	二级缓存的工作机制：

		一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。
		如果用户配置了"cacheEnabled=true"，那么MyBatis在为SqlSession对象创建Executor对象时，
		会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。
		CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，
		如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，
		之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。

		MyBatis的二级缓存设计得比较灵活，你可以使用MyBatis自己定义的二级缓存实现；
		你也可以通过实现org.apache.ibatis.cache.Cache接口自定义缓存；
		也可以使用第三方内存缓存库，如Memcached等


MyBatis 的架构设计

	一、MyBatis的框架设计

		1. 接口层——和数据库交互的方式
		
			MyBatis和数据库的交互有两种方式：
				a. 使用传统的 MyBatis 提供的API；
				b. 使用 Mapper 接口

			1.1. 使用传统的MyBatis提供的API：

				这是传统的传递 Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；
				MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，
				以及对数据库连接信息和MyBatis 自身配置信息的维护操作。

				上述使用MyBatis 的方法，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，
				这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。
				由于面向接口的编程是面向对象的大趋势，MyBatis 增加了第二种使用MyBatis 支持接口（Interface）调用方式。

			1.2. 使用Mapper接口：

				MyBatis 将配置文件中的每一个 <mapper> 节点抽象为一个 Mapper 接口，
				而这个接口中声明的方法和跟 <mapper> 节点中的 <select|update|delete|insert> 节点项对应，
				即 <select|update|delete|insert> 节点的id值为 Mapper 接口中的方法名称，
				parameterType 值表示 Mapper 对应方法的入参类型，
				而resultMap 值则对应了 Mapper 接口表示的返回值类型或者返回结果集的元素类型。

				根据MyBatis 的配置规范配置好后，
				通过SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，
				通过动态代理机制生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，
				MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，
				底层还是通过SqlSession.select("statementId",parameterObject);
				或者SqlSession.update("statementId",parameterObject); 等等来实现对数据库的操作，
				（至于这里的动态机制是怎样实现的，我将准备专门一片文章来讨论，敬请关注~）

				MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。
				（还有一个原因是，面向接口的编程使用户可以在接口上使用注解来配置SQL语句，这样就脱离XML配置文件，实现“0配置”）。

		2. 数据处理层
			数据处理层可以说是MyBatis 的核心，从大的方面上讲，它要完成三个功能：

				a. 通过传入参数构建动态SQL语句；
				b. SQL语句的执行以及封装查询结果集成List<E>
			
			2.1.参数映射和动态SQL语句生成

				动态语句生成可以说是MyBatis框架非常优雅的一个设计，
				MyBatis 通过传入的参数值，使用 Ognl 来动态地构造SQL语句，使得MyBatis 有很强的灵活性和扩展性。

				参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：
				这里有包括两个过程：
					查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；
					另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。
					（至于具体的MyBatis是如何动态构建SQL语句的，我将准备专门一篇文章来讨论，敬请关注~）

			2.2. SQL语句的执行以及封装查询结果集成List<E>

				动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<E> 列表。
				MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，
				并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。

		3. 框架支撑层
		
			3.1. 事务管理机制

				事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准，
				对于数据管理机制我已经在我的博文《深入理解mybatis原理》 MyBatis事务管理机制 中有非常详细的讨论。

			3.2. 连接池管理机制

				由于创建一个数据库连接所占用的资源比较大， 对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要，
				对于连接池管理机制我已经在我的博文《深入理解mybatis原理》 Mybatis数据源与连接池中有非常详细的讨论。

			3.3. 缓存机制

				为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，
				会将对某一次查询，放置到SqlSession 中，
				在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。

			3. 4. SQL语句的配置方式

				传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，
				但是这种方式不能很好地支持面向接口编程的理念，
				为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL 语句成为可能，
				用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，
				但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。

		4. 引导层
		
			引导层是配置和启动MyBatis 配置信息的方式。
			MyBatis 提供两种方式来引导MyBatis ：基于XML配置文件的方式和基于Java API 的方式；
			读者可以参考我的另一片博文：Java Persistence with MyBatis 3(中文版) 第二章 引导MyBatis。


	二、MyBatis的主要构件及其相互关系
		从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：
			SqlSession            	作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能
			Executor              	MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
			StatementHandler   	封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。
			ParameterHandler   	负责对用户传递的参数转换成JDBC Statement 所需要的参数，
			ResultSetHandler    	负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；
			TypeHandler          	负责java数据类型和jdbc数据类型之间的映射和转换
			MappedStatement   	MappedStatement维护了一条<select|update|delete|insert>节点的封装， 
			SqlSource            	负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
			BoundSql             	表示动态生成的SQL语句以及相应的参数信息
			Configuration        	MyBatis所有的配置信息都维持在Configuration对象之中。
			（注：这里只是列出了我个人认为属于核心的部件，请读者不要先入为主，认为MyBatis就只有这些部件。）







一级缓存实现详解

	1. 什么是一级缓存？ 为什么使用一级缓存？

		每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。
		在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，
		如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，
		那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。

		为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，
		当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。

		如下图所示，MyBatis会在一次会话的表示----一个SqlSession对象中创建一个本地缓存(local cache)，
		对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，
		如果在缓存中，就直接从缓存中取出，然后返回给用户；
		否则，从数据库读取数据，将查询结果存入缓存并返回给用户。

		对于会话（Session）级别的数据缓存，我们称之为一级数据缓存，简称一级缓存。

	2. MyBatis中的一级缓存是怎样组织的？（即SqlSession中的缓存是怎样组织的？）

		由于MyBatis使用SqlSession对象表示一次数据库的会话，那么，对于会话级别的一级缓存也应该是在SqlSession中控制的。

			实际上, MyBatis只是一个MyBatis对外的接口，SqlSession将它的工作交给了Executor执行器这个角色来完成，
			负责完成对数据库的各种操作。
			当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，
			而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。
			SqlSession、Executor、Cache之间的关系如下列类图所示：

			如上述的类图所示，Executor接口的实现类BaseExecutor中拥有一个Cache接口的实现类PerpetualCache，
			则对于BaseExecutor对象而言，它将使用PerpetualCache对象维护缓存。

		综上，SqlSession对象、Executor对象、Cache对象之间的关系如下图所示：

		由于Session级别的一级缓存实际上就是使用PerpetualCache维护的，那么PerpetualCache是怎样实现的呢？

		PerpetualCache实现原理其实很简单，其内部就是通过一个简单的HashMap<k,v> 来实现的，没有其他的任何限制。

	3.一级缓存的生命周期有多长？

		a. MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，
			Executor对象中持有一个新的PerpetualCache对象；
			当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。

		b. 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；

		c. 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；

		d.SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，
			都会清空PerpetualCache对象的数据，但是该对象可以继续使用；

	4. SqlSession 一级缓存的工作流程：

		1.对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；
		2. 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；
		3. 如果命中，则直接将缓存结果返回；
		4. 如果没命中：
			4.1  去数据库中查询数据，得到查询结果；
			4.2  将key和查询到的结果分别作为key,value对存储到Cache中；
			4.3. 将查询结果返回；
		5. 结束。
		[关于上述工作过程中 key值的构建，我们将在第下一节中重点探讨，这也是MyBatis缓存机制中非常重要的一个概念。]

	5. Cache接口的设计以及CacheKey的定义（非常重要）

		如下图所示，MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，
		所有的MyBatis内部的Cache缓存，都应该实现这一接口。
		MyBatis定义了一个PerpetualCache实现类实现了Cache接口，
		实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。

		（MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类，Cache的其他实现将会放到二级缓存中介绍）。

		我们知道，Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。
		现在最核心的问题出现了：怎样来确定一次查询的特征值？
		换句话说就是：怎样判断某两次查询是完全相同的查询？
		也可以这样说：如何确定Cache中的key值？

		MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询：

			1. 传入的 statementId 
			2. 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；
			3. 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）
			4. 传递给java.sql.Statement要设置的参数值

		现在分别解释上述四个条件：

			1. 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql；
			2. MyBatis自身提供的分页功能是通过RowBounds来实现的，
				它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，
				这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；
			
			由于MyBatis底层还是依赖于JDBC实现的，
			对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。
			而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。

			上述的第3个条件正是要求保证传递给JDBC的SQL语句完全一致；第4条则是保证传递给JDBC的参数也完全一致；
				3、4讲的有可能比较含糊，举一个例子：
					   <select id="selectByCritiera" parameterType="java.util.Map" resultMap="BaseResultMap">
						select employee_id,first_name,last_name,email,salary
						from louis.employees
						where  employee_id = #{employeeId}
						and first_name= #{firstName}
						and last_name = #{lastName}
						and email = #{email}
					  </select>
				如果使用上述的"selectByCritiera"进行查询，那么，MyBatis会将上述的SQL中的#{} 都替换成 ? 如下：
					select employee_id,first_name,last_name,email,salary
					from louis.employees
					where  employee_id = ?
					and first_name= ?
					and last_name = ?
					and email = ?
			MyBatis最终会使用上述的SQL字符串创建JDBC的java.sql.PreparedStatement对象，
			对于这个PreparedStatement对象，还需要对它设置参数，调用setXXX()来完成设值，
			第4条的条件，就是要求对设置JDBC的PreparedStatement的参数值也要完全一致。
				即3、4两条MyBatis最本质的要求就是：
					调用JDBC的时候，传入的SQL语句要完全相同，传递给JDBC的参数值也要完全相同。
			综上所述,CacheKey由以下条件决定：
				statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值

		CacheKey的创建

			对于每次的查询请求，Executor都会根据传递的参数信息以及动态生成的SQL语句，
			将上面的条件根据一定的计算规则，创建一个对应的CacheKey对象。

			我们知道创建CacheKey的目的，就两个：
				1. 根据CacheKey作为key,去Cache缓存中查找缓存结果；
				2. 如果查找缓存命中失败，则通过此CacheKey作为key，
					将从数据库查询到的结果作为value，组成key,value对存储到Cache缓存中。

		CacheKey的hashcode生成算法
			Cache接口的实现，本质上是使用的HashMap<k,v>,而构建CacheKey的目的就是为了作为HashMap<k,v>中的key值。
			而HashMap是通过key值的hashcode 来组织和存储的，那么，构建CacheKey的过程实际上就是构造其hashCode的过程。


	6. 一级缓存的性能分析

		我将从两个 一级缓存的特性来讨论SqlSession的一级缓存性能问题：

			1. MyBatis 对会话（Session）级别的缓存设计比较简单，简单地使用了HashMap来维护，并没有对HashMap的容量和大小进行限制。

				读者有可能就觉得不妥了：如果我一直使用某一个SqlSession对象查询数据，这样会不会导致HashMap太大，而导致 java.lang.OutOfMemoryError错误啊？ 读者这么考虑也不无道理，不过MyBatis的确是这样设计的。

				MyBatis这样设计也有它自己的理由：

					a.  一般而言SqlSession的生存时间很短。一般情况下使用一个SqlSession对象执行的操作不会太多，执行完就会消亡；
					b.  对于某一个SqlSession对象而言，只要执行update操作（update、insert、delete），
						都会将这个SqlSession对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题；
					c.  可以手动地释放掉SqlSession对象中的缓存。

			2.  一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念

				MyBatis的一级缓存就是使用了简单的HashMap，MyBatis只负责将查询数据库的结果存储到缓存中去， 不会去判断缓存存放的时间是否过长、是否过期，因此也就没有对缓存的结果进行更新这一说了。

		根据一级缓存的特性，在使用的过程中，我认为应该注意：
			1、对于数据变化频率很大，并且需要高时效准确性的数据要求，
				我们使用SqlSession查询的时候，要控制好SqlSession的生存时间，
				SqlSession的生存时间越长，它其中缓存的数据有可能就越旧，从而造成和真实数据库的误差；
				同时对于这种情况，用户也可以手动地适时清空SqlSession中的缓存；

			2、对于只执行、并且频繁执行大范围的select操作的SqlSession对象，SqlSession对象的生存时间不应过长。

	7. 举例：
		例1、看下面这个例子，下面的例子使用了同一个SqlSession指令了两次完全一样的查询，将两次查询所耗的时间打印出来。
			运行结果：
				由上面的结果你可以看到，第一次查询耗时464ms，而第二次查询耗时不足1ms,这是因为第一次查询后，
				MyBatis会将查询结果存储到SqlSession对象的缓存中，当后来有完全相同的查询时，直接从缓存中将结果取出。

		例2、对上面的例子做一下修改：在第二次调用查询前，对参数 HashMap类型的params多增加一些无关的值进去，然后再执行。
			运行结果：
				虽然第二次查询时传递的params参数不一致，但还是从一级缓存中取出了第一次查询的缓存。

		读到这里，请读者晓得这一个问题：
			MyBatis认为的完全相同的查询，不是指使用sqlSession查询时传递给算起来Session的所有参数值完完全全相同，
			你只要保证statementId，rowBounds,最后生成的SQL语句，以及这个SQL语句所需要的参数完全一致就可以了。



二级缓存的设计原理

	1.MyBatis的缓存机制整体设计以及二级缓存的工作模式
		 
		如上图所示，当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，
		MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。
		如果用户配置了"cacheEnabled=true"，那么MyBatis在为SqlSession对象创建Executor对象时，
		会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。
		CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，
		如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，
		之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。

		CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，

		CachingExecutor和Executor的接口的关系如下类图所示：


	2 . MyBatis二级缓存的划分
		MyBatis并不是简单地对整个Application就只有一个Cache缓存对象，它将缓存划分的更细，是Mapper级别的，
		即每一个Mapper都可以拥有一个Cache对象，具体如下：

			a.为每一个Mapper分配一个Cache缓存对象（使用<cache>节点配置）；
				MyBatis将Application级别的二级缓存细分到Mapper级别，
				即对于每一个Mapper.xml,如果在其中使用了<cache> 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象。
				注：  上述的每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID；

			b.多个Mapper共用一个Cache缓存对象（使用<cache-ref>节点配置）；
				如果你想让多个Mapper公用一个Cache的话，你可以使用<cache-ref namespace="">节点，
				来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。

	3. 使用二级缓存，必须要具备的条件

		MyBatis对二级缓存的支持粒度很细，它会指定某一条查询语句是否使用二级缓存。

		虽然在Mapper中配置了<cache>,并且为此Mapper分配了Cache对象，
		这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，
		我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在<select> 节点中配置useCache="true"，Mapper才会对此Select的查询支持缓存特性，
		否则，不会对此Select查询，不会经过Cache缓存。
		如下所示，Select语句配置了useCache="true"，则表明这条Select语句的查询会使用二级缓存。
			<select id="selectByMinSalary" resultMap="BaseResultMap" parameterType="java.util.Map" useCache="true">

		总之，要想使某条Select查询支持二级缓存，你需要保证：
			1.  MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true
			2. 该select语句所在的Mapper，配置了<cache> 或<cached-ref>节点，并且有效
			3. 该select语句的参数 useCache=true

	4. 一级缓存和二级缓存的使用顺序
		请注意，如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，
		那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，即MyBatis查询数据的顺序是：
			二级缓存 ——> 一级缓存 ——> 数据库

	5. 二级缓存实现的选择
		MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等；
		另外，MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，
		然后将Cache实现类配置在<cache  type="">节点的type属性上即可；
		除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成，
		总之，使用MyBatis的二级缓存有三个选择:
			1. MyBatis自身提供的缓存实现；
			2. 用户自定义的Cache接口实现；
			3. 跟第三方内存缓存库的集成；

	6.  MyBatis自身提供的二级缓存的实现
		MyBatis自身提供了丰富的，并且功能强大的二级缓存的实现，它拥有一系列的Cache接口装饰者，可以满足各种对缓存操作和更新的策略。

		MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。

		对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。
		
		MyBatis主要提供了以下几个刷新和置换策略：
			LRU：（Least Recently Used）,最近最少使用算法，
				即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；
			FIFO：（First in first out）,先进先出算法，
				如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；
			Scheduled：指定时间间隔清空算法，
				该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；

	7. 写在后面（关于涉及到的设计模式）
		在二级缓存的设计上，MyBatis大量地运用了装饰者模式，如CachingExecutor, 以及各种Cache接口的装饰器。












PageHelper
	PageHelper：Mybatis 分页插件。
	使用方法
		第一步：把PageHelper依赖的jar包添加到工程中。
			官方提供的代码对逆向工程支持的不好，使用参考资料中的pagehelper-fix。

		第二步：在Mybatis配置xml中配置拦截器插件:
			<plugins>
				<!-- com.github.pagehelper为PageHelper类所在包名 -->
				<plugin interceptor="com.github.pagehelper.PageHelper">
				<!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库-->        
				<property name="dialect" value="mysql"/>
				</plugin>
			</plugins>
		
		第三步：在代码中使用
			1、设置分页信息：
				//获取第1页，10条内容，默认查询总数count
				PageHelper.startPage(1, 10);
				//紧跟着的第一个select方法会被分页
				List<Country> list = countryMapper.selectIf(1);
			2、取分页信息
				//分页后，实际返回的结果list类型是Page<E>，如果想取出分页信息，需要强制转换为Page<E>，
				Page<Country> listCountry = (Page<Country>)list;
				listCountry.getTotal();
			3、取分页信息的第二种方法
				//获取第1页，10条内容，默认查询总数count
				PageHelper.startPage(1, 10);
				List<Country> list = countryMapper.selectAll();
				//用PageInfo对结果进行包装
				PageInfo page = new PageInfo(list);
				//测试PageInfo全部属性
				//PageInfo包含了非常全面的分页属性
				assertEquals(1, page.getPageNum());
				assertEquals(10, page.getPageSize());
				assertEquals(1, page.getStartRow());
				assertEquals(10, page.getEndRow());
				assertEquals(183, page.getTotal());
				assertEquals(19, page.getPages());
				assertEquals(1, page.getFirstPage());
				assertEquals(8, page.getLastPage());
				assertEquals(true, page.isFirstPage());
				assertEquals(false, page.isLastPage());
				assertEquals(false, page.isHasPreviousPage());
				assertEquals(true, page.isHasNextPage());













