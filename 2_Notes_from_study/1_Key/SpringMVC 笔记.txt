
SpringMVC


SpringMVC 核心
	是什么：
		基于 mvc 模式 和 servlet 的开源框架；
		连接视图和服务的中间件，目前最流行的 web 项目表现层框架。
	为什么使用：
		功能强大，使用方便的轻量级开源框架；
	基本原理：
		http 请求到 web 服务器；
		DispatcherServlet 匹配请求路径；
		HandlerMapping 寻找对应的 Handler；
		HandlerAdapter 调用 Handler；
		Handler 处理数据后返回逻辑视图 ModelAndView；
		ViewResolve 把逻辑视图转化成真正的 View；
		Dispatcher 解析逻辑视图中的参数后放入视图，把结果返回给客户端。
	怎么使用：
		将服务层对象注入 SpringIOC 容器，
		然后配置配置过滤规则，
		编写对应的 controller 为视图提供访问接口。
		

SpringMVC 工作原理
	1、客户端发出一个 http 请求给 web 服务器，web 服务器对 http 请求进行解析，
		如果匹配 DispatcherServlet 的请求映射路径 (在 web.xml 中指定) ，web 容器将请求转交给 DispatcherServlet.
	2、DipatcherServlet 接收到这个请求之后将根据请求的信息 (包括 URL、Http 方法、请求报文头和请求参数 Cookie 等) 
		以及 HandlerMapping 的配置找到处理请求的处理器 (Handler) 。
	3-4、DispatcherServlet 根据 HandlerMapping 找到对应的 Handler，将处理权交给 Handler (Handler 将具体的处理进行封装) ，
		再由具体的 HandlerAdapter 对 Handler 进行具体的调用。
	5、Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给 DispatcherServlet。
	6、Handler 返回的 ModelAndView() 只是一个逻辑视图并不是一个正式的视图，
		DispatcherSevlet 通过 ViewResolver 将逻辑视图转化为真正的视图 View。
	7、Dispatcher 通过 model 解析出 ModelAndView() 中的参数进行解析最终展现出完整的 view 并返回给客户端。

Spring MVC 工作流程
	Spring 的 MVC 框架主要由 DispatcherServlet、处理器映射、处理器 (控制器)、视图解析器、视图组成。
	Spring Web MVC 框架是围绕 DispatcherServlet 设计的，
		DispathcerServlet 相当于与一个调度器，将请求根据处理流程一步一步分发给相应的解析器解析处理。
	工作流程：
		1、客户端将请求发送给后台 (一般都是通过浏览器进行发送的) ，请求到了后台都是交给 DispatcherServlet 处理，
			所有相当于是直接发送给了 DispatcherServlet。
		2、DispatcherServlet 根据请求的信息 (URL、Http 方法、请求报文头、请求参数 Cookie 等) 
			调用 HandlerMapping 解析器解析该请求对应的 handler。
		3、解析到对应的 handler 后，DispatcherServlet 将控制权移交给 HandlerAdapter 来处理请求，
			HandlerAdapter 将处理器包装为适配器，从而支持多种类型的处理器。
		4、HandlerAdapter 会根据实际需要的 Handler 调用真正的处理器来处理请求，处理器根据要求处理业务逻辑。
		5、处理器处理完业务逻辑之后会返回一个 ModelAndView 对象，这里的 Model 是处理器处理完成之后的数据，
			View 是一个逻辑上的 View。
		6、ViewResolver 会根据逻辑 View 查找实际对应的是那个 View。
		7、DispatcherServlet 最后将 5 中返回的 Model 放入到 6 中解析的正真的 View 中生成结果，并返回给请求者。

	DispatcherServlet
		DispatcherServlet 介绍
			在 Web MVC 框架中，每个 DispatcherServlet 都拥有自己的 WebApplicationContext，
			它继承了在 root WebApplicationContextContext 中定义的所有 beans。
			root WebApplicationContext 包含了在其上下文和 Sevlet 实例之间共享的所有基础框架 beans。
		DispatcherServlet 的上下文继承：
			对于上下文的继承，特殊情况是可以把 Controller、ViewResolver、HandlerMapping 放在 Root WebApplicationContext 中。
		DispatcherServlet 就像一个“Front Controller”设计模式，Spring farmwork 文档中给出 DispathcerServlet 的处理流程如：
			在初始化 DispatherServlet 时，在初始化 DispatcherServlet 时，
			Spring MVC 会查找一个在 WEB-INF 下名为 [servlet-name]-servlet.xml 的文件且在这里创建 beans。
		例如在 web.xml 中声明 servlet-name 如下图：
			<web-app>
				<servlet>
					<servlet-name>golfing</servlet-name>
					<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
					<load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping>
					<servlet-name>golfing</servlet-name>
					<url-pattern>/golfing/*</url-pattern>
				</servlet-mapping>
			</web-app>
		则必须在/WEB-INF/下建立文件 golfing-servlet.xml 文件，这个文件会包含所有 beans。
		现在比较流行注解方式，使用注解方式在项目初始化的时候会把注解类注入到 Servlet WebApplicationContext 中，
		所以 DispatcherServlet 也可以读取到注解的 bean。

		DispatcherServlet 的对请求的处理流程：
			● 在请求中搜索并绑定 WebApplicationContext 作为 controlelr 和程序中其他元素可以使用的属性。
			● 当处理请求时，将区域解析器 (Locale resolver) 绑定到请求中，
				以便于在进程中的元素可以解决区域问题。区域解析器是可选的。
			● 主题解析器 (Theme resolver) 被绑定到请求中，用于诸如视图之类的元素使用哪种主题的请求。可选。
			● 检查请求中是否指定多部分文件解析器 (multipart file resolver)，
				若有则使用使用 MultipartHttpServletRequest 作为处理程序。
			● 查找合适的 handler，如果找到合适的 handler，
				则执行与处理程序 (预处理程序、后处理程序和 Controller) 关联的执行链，以便准备模型或呈现。
			● 如果 model 返回，则 view 就呈现；如果 model 没有返回，就没有 view 呈现。

	HandlerMappings
			在以前的版本的 Spring 中，为寻找合适的 handlers，
			我们需要在 web application context 中定义一个或多个 HandlerMapping beans 去匹配 web 请求。
			而现在的注解控制器，不需要这样做了，
			因为 RequestMappingHandlerMapping 会自动地寻找在所有 @Controller beans 的 @RequestMapping 注解来寻找合适的 handlers。

		由于 HandlerMapping 是从 AbstractHandlerMapping 中扩展而来，因此 HandlerMapping 拥有以下特性：
			● 有一系列的拦截器可以使用。
			● 当 handler mapping 没有匹配到 handler 时，会默认使用 defaultHandler。
			● 匹配的顺序是基于 order 属性的，Spirng 会对所有在环境中可用的 handler mapping 进行排序，
				并且使用第一个匹配的到 handler。
			● 如果设置 alwaysUseFullPath 为 true，Spring 将会使用完整路径去匹配合适的 handler；否则会使用相对路径。
				例如，如果 Servlet 的映射是使用/testing/*且 alwaysUseFullPath 属性是 true，
				当使用/testing/viewPage.html，不管这个属性是真是假，都返回/viewPage.html。
			● urlDecode 默认是 true，如果选择比较 encoded 的路径，需要设置该标识为 false。
				注：当比较 encoded 路径是不会匹配 Servlet 路径的。

		一共有三种拦截器：
			● preHandle()：在真正的 handler 执行之前调用。
			● postHandle()：在 handler 执行之后调用。
			● afterCompletion()：在完成请求之后调用。

		preHandle() 方法返回一个布尔值。
		当返回的是 true 时，handler 执行链才会继续执行；
		当返回的 false 时，DispatcherServlet 假设拦截器本身可以处理请求 (例如呈现视图) ，
		并且不会执行在执行链中的其他拦截器和 handler。
		可以使用 preHandle() 来筛选、预处理请求。

		使用拦截器的例子如下：
			<beans>
				<bean id="handlerMapping"
						class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping">
					<property name="interceptors">
						<list>
							<ref bean="officeHoursInterceptor"/>
						</list>
					</property>
				</bean>
				<bean id="officeHoursInterceptor"
						class="samples.TimeBasedAccessInterceptor">
					<property name="openingTime" value="9"/>
					<property name="closingTime" value="18"/>
				</bean>
			</beans>
			
			package samples;
			public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {
				private int openingTime;
				private int closingTime;

				public void setOpeningTime(int openingTime) {
					this.openingTime = openingTime;
				}
				public void setClosingTime(int closingTime) {
					this.closingTime = closingTime;
				}

				public boolean preHandle(HttpServletRequest request，HttpServletResponse response，
						Object handler) throws Exception {
					Calendar cal = Calendar.getInstance();
					int hour = cal.get(HOUR_OF_DAY);
					if (openingTime <= hour && hour < closingTime) {
						return true;
					}
					response.sendRedirect("http：//host.com/outsideOfficeHours.html");
					return false;
				}
			}
			
		任何请求都会被 TimeBasedAccessInterceptor 处理。
		如果当前时间不是工作时间，用户将会重定向到一个指向静态 HTML 的文件，只能在工作时间使用该网站。

		注：postHandle 方法并不是特别适用于 @ResponseBody 和 ResponseEntity 方法中，
		postHandle() 是在 HttpMessageConverter 写入并提交响应之后执行，因此 postHandle 有可能会改变响应。

		
	HandlerAdapter

		HandlerAdapter 用于调用具体的 handler 来处理业务逻辑。
		HandlerAdapter 实现了每种不同类型的 handler，DispatcherServlet 将控制权交给 HandlerAdapter，
		并通过 HandlerAdapter 接口访问所有已安装的处理程序，允许 DispatcherServlet 无限扩展，
		这也意味着 HandlerAdapter 不包含任何特定于处理程序的特定代码，相当于一个中间件，用于调用具体的 Handler。

		从 spring3.1 版本开始，废除了 AnnotationMethodHandlerAdapter 的使用，
		推荐使用 RequestMappingHandlerAdapter 完成注解式处理器适配来对标记 @ResquestMapping 的方法进行适配。
		springmvc 使用<mvc：annotation-driven>自动加载 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter，
		可用在 springmvc.xml 配置文件中使用<mvc：annotation-driven>替代注解处理器和适配器的配置。

	Handler

		默认的 Handler 是基于 @Controller 和 @RequestMapping 注解的，提供了广泛的灵活 handling 方法。
		而 @Controller 又会调用 Service 和 Dao 来完成一些业务逻辑处理。@RequestMapping 注解用于去匹配 URL。

		新特性：
		在 Spring4.3 还有 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping 等直接筛选请求类型的注解。
		例如 @GetMapping("/owners/{ownerId}") 可以在请求路径上设置参数，在函数参数中使用 @PathVariable String owner 获取参数。
		在 RFC 3986 规范中还可以使用 Matrix Variables。还可以使用 Consumable Media Types 来限制 media 的类型。

	Model And View
		ModelAndView 对象是连接业务逻辑层与 view 展示层的桥梁，对 spring MVC 来说它也是连接 Handler 与 view 的桥梁。
		ModelAndView 对象顾名思义会持有一个 ModelMap 对象和一个 View 对象或者 View 的名称。
		这个 View 的名称知识一个逻辑上的 View 名称，怎么理解呢，
		假设我们最后返回一个 jsp 对象，那么只需在 controller 中返回 success 或 error，即可，这个是逻辑上的，
		而实际上的就是返回/WEB-INF/jsp/success.jsp 或/WEB-INF/jsp/error.jsp 才是真实的 View。

	ViewResolver
		所有的 handler 都必须明确返回一个 ModelAndView 对象，其中的 View 是一个逻辑上的视图，比如明确返回 String，View，or ModelAndView 或隐式地 (基于约定) 。逻辑视图由 ViewResolver 解析，以下是 Spring 中的拥有的视图解析器：
			AbstractCachingViewResolver：
				抽象视图解析器器即 caches 视图。通常 views 在使用之前需要准备，扩展此视图解析器是提供缓存。
			* XmlViewResolver*：
				实现 ViewResolver，它接受 XML 编写的配置文件 (与 Spring XML bean 相同的 DTD) ，默认的配置的文件是/WEB-INF/view.xml。
			ResourceBundleViewResolver：
				实现 ViewResolver，它使用 ResourceBundle 中的 bean 定义，由 bundle 基本名称指定。
				默认的文件名是在 classpath 中的 views.properties。
			UrlBasedViewResolver：
				简单地实现 ViewResolver 接口，它影响了逻辑视图名到 URL 的直接解析，而不需要明确的映射定义。
				适用于逻辑名称和视图资源的直接名称匹配，这种方式不需要映射。
			InternalResourceViewResolver：
				是 UrlBasedViewResolver 的子类，支持 InternalResourceView (Servlets 和 JSP) 和子类，
				例如 JstlView 和 TilesView。也可以公国 setViewClass 来具体制定那种视图类。
			FreeMarkerViewResolver：
				UrlBasedViewResolver 的子类，支持 FreeMarkerView 和它的常规子类。
			ContentNegotiatingViewResolver：
				实现 ViewResolver 接口，它解析基于请求文件名或 Accept 头的视图。

		例如常见的返回 JSP 视图的配置如下：
			<bean id="viewResolver"
					class="org.springframework.web.servlet.view.UrlBasedViewResolver">
				<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
				<property name="prefix" value="/WEB-INF/jsp/"/>
				<property name="suffix" value=".jsp"/>
			</bean>
		在 controller 中返回的逻辑视图名为 test，而最终视图的地址为：前缀+ 逻辑视图名+ 后缀，
		所以 RequestDispatcher 的视图解析器最后返回/WEB-INF/jsp/test.jsp。
		pring 支持多视图解析器，可以在程序上下文中添加多个视图解析器，还可以设置“order”属性来指定匹配优先级。
		Spring 会找到合适的第一个视图解析器来返回结果。如果没有找到视图，则返回 null。

	View
		现在业务逻辑处理的数据存放在 Model 中，返回的 View 也确定了，
		最后一步只需将 Model 中的数据项 View 中填充即可，最后将数据返回给请求者。
		View 可以是支持：
			字符串、JSON Mapping View、JSP & JSTL、XML Marshalling View、Document views (PDF/Excel)、
			Thymeleaf、Groovy Markup Templates、FreeMarker、Script templates、Tiles、Feed View 多种格式的视图，
			DispatcherServlet 根据不同 handler 的不同配置选择不同的 View 返回。


Spring MVC 常用注解

@RequestMapping：
	这个注解类型指示 Spring 用哪一个类或方法来处理请求动作，该注解可以用于类或方法；

	@RequestMapping 注解支持的属性：
		value 属性
			这个属性将 URL 映射到方法上，由于 value 属性是 @RequestMapping 注解的默认属性，因此如果只有唯一属性，则可以省略属性名；
			即如下两个标注含义相同：
			@RequestMapping("value="/hello")
			@RequestMapping ("/hello") 
			但如果超过一个属性，就必须写上 value 属性名称
		method 属性
			该属性用来指示该方法仅仅处理哪些 HTTP 请求方式，如果没有指定 method 属性值，则请求处理方法可以处理任意的 HTTP 请求方式。
		consumes 属性
			该属性指定处理请求的提交内容类型 (Content-Type) 
			@RequestMapping (value="/hello"，method=RequestMethod.POST，consumes="application/json") 
			表示方法仅处理 request Content-Type 为"application/json"类型的请求。
		produces 属性
			该属性指定返回的内容类型，返回的内容类型必须是 request 请求头 (Accept) 中所包含的类型。
			@RequestMapping (value="/hello"，method=RequestMethod.POST，produces="application/json") 
			方法仅处理 request 请求中 Accept 头中包含了"application/json"的请求，同时指明了返回的内容类型为 application/json。
		params 属性
			该属性指定 request 中必须包含某些参数值时，才让该方法处理。
			@RequestMapping (value="/hello"，method=RequestMethod.POST，params="myparam=myvalue") 
			方法仅处理其中名为"myparam"、值为"myvalue"的请求。
		headers 属性


Model 和 ModelMap
	Spring MVC 在内部使用了一个 org.springframework.ui.Model 接口存储模型数据，它的功能类似 java.util.Map 接口，但是比 Map 易于使用。
	org.springframework.ui.ModelMap 接口实现了 Map 接口。

	Spring MVC 在调用处理方法之前会创建一个隐含的模型对象，作为模型数据的存储容器。
	如果处理方法的参数为 Model 或 ModelMap 类型，则 Spring MVC 会将隐含模型的引用传递给这些参数。
	在处理方法内部，开发者就可以通过这个参数对象访问模型中的所有数据，也可以向模型中添加新的属性数据。

	在处理方法中，Model 和 ModelMap 对象都可以使用如下方法添加模型数据：
	addObject(String attributeName，Object attributeValue)

@RequestParam
	org.springframework.web.bind.annotation.RequestParam 注解类型用于将指定的请求参数赋值给方法中的形参。
	使用 @RequestParam 注解可指定如下表所示的属性：

	属性	类型	是否必要	是否说明
	name	String	否	指定请求头绑定的名称
	value	String	否	name 属性的别名
	required	boolean	否	指定参数是否必须绑定
	defaultValue	String	否	如果没有传递参数而使用的默认值
	
@PathVariable 注解
	org.springframework.web.bind.annotation.PathVariale 注解类型可以非常方便地获得请求 URL 中的动态参数。@PathVariable 注解只支持一个属性 value，类型为 String，表示绑定的名称，如果省略则默认绑定同名参数. 示例代码如下:
		@RequestMapping(value="/pathVariableTest/{userId}")
		public void pathVariableTest(@PathVariable Integer userId)
		URL 模版变量 {userId} 绑定到通过 @PathVariable 注解的同名参数上

@ReuqestHeader 注解
	org.springframework.web.bind.annotation.RequestHeader 注解类型用于将请求的头信息区数据映射到功能处理方法的参数上。
@CookieValue 注解
	org.springframework.web.bind.annotation.CookieValue 用于将请求的 Cookie 数据映射到功能处理方法的参数上。
@SessionAttributes 注解
	org.spingframework.web.bind.annotation.SessionAttribute 注解类型
	允许我们有选择地指定 Model 中的哪些属性需要转存到 HttpSession 对象当中。
	属性	类型	是否必要	是否说明
	names	String[]	否	Model 中属性的名称，即存储在 HttpSession 当中的属性名称
	value	String[]	否	names 属性的别名
	types	Class<?>[]	否	指定放入对象的类型
	@SessionAttributes 只能声明在类上，而不能声明在方法上。
	使用方法如下：

		// 将 Model 中的属性名为 user 的属性放入 HttpSession 对象当中
		@SessionAttributes("user")
		@SessionAttributes (types={User.class}，value="user") 
		// 也可以设置多个对象到 HttpSession 当中：
		@SessionAttributes (types={User.class，Dept.class}，value={"user"，"dept"}) 
		types 属性用来指定放入 HttpSession 当中的对象类型。
	
信息转换

HttpMessageConverter< T >接口

	HttpMessageConverter< T > 是 Spring3.0 之后新增的一个重要接口，它负责将请求信息转换为一个对象 (类型为 T) ，
	并将对象 (类型为 T) 绑定到请求方法的参数中或输出为响应信息。
	DispatcherServlet 默认已经装配了 RequestMappingHandlerAdapter 作为 HandlerAdapter 组件的实现类，
	即 HttpMessageConverter 由 RequestMappingHandlerAdapter 使用，将请求信息转换为对象，或将对象转换为响应信息。
	
	HttpMessageConverter< T >接口中定义了以下几个方法：

		boolean canRead(Class< ? > clazz，MediaType mediaType)。该方法指定转换器可以读取的对象类型，即转换器可将请求信息转换为 clazz 类型的对象，同时指定支持的 MIME 类型 (text/html、application/json 等)。MIME 媒体类型在 RFC2616 中定义，具体请参考 https://tools.ietf.org/html/rfc2616#section-3.7
		boolean canWrite(Class< ? >clazz，MediaType mediaType)。该方法指定转换器可以将 clazz 类型的对象写到响应流当中，响应流支持的媒体类型在 mediaType 中定义。
		List<MediaType> getSupportedMediaTypes()。该方法返回当前转换器支持的媒体类型。
		T read(Class< ? extends T> clazz，HttpInputMessage inputMessage)。该方法将请求信息流转换为 T 类型的对象。
		void write (T t，MediaType contentType，HttpOutputMessage outMessage)。该方法将 T 类型的对象写到响应流当中，同时指定响应的媒体类型为 contentType。
		
	Spring 为 HttpMessageConverter< T> 提供了多个实现类，这些实现类组成了一个功能强大、用途广泛的信息转换家族：

		StringHttpMessageConverter。将请求信息转换为字符串。泛型 T 为 String 类型，可以读取所有媒体类型 ( /) 的请求信息，可通过设置 supportedMediaTypes 属性指定媒体类型。响应信息的媒体类型为 text/plain(即 Content-Type 的值)。
		FormHttpMessageConverter。将表单数据读取到 MultiValueMap 中。泛型 T 为 org.springframework.util.MultiValueMap< String，? >类型，支持读取 application/x-www-form-urlencoded 的类型，但不支持读取 multipart/form-data 的类型。可以写 application/x-www-form-urlencoded 及 multipart/form-data 类型的响应信息。
		XmlAwareFormHttpMessageConverter。继承自 FormHttpMessageConverter，如果部分表单属性是 XML 数据，则可以用该转换器进行转换。
		ResourceHttpMessageConverter。读写 org.springframework.core.io.Resource 对象。泛型 T 为 org.springframework.core.io.Resource 对象，可以读取所有媒体类型 ( /) 的请求信息。如果类路径下提供了 JAF(Java Activation Framework)，则根据 Resource 的类型指定响应的类型，否则响应的类型为 application/octet-stream。
		BufferedImageHttpMessageConverter。读写 BufferedImage 对象。泛型 T 为 BufferedImage 对象，可以读取所有类型 ( /) 的请求信息，返回 BufferedImage 相应的类型，也可以通过 contentType 显示指定。
		ByteArrayHttpMessageConverter。读写二进制数据。泛型 T 为 byte[] 类型，可以读取所有类型 ( /) 的请求信息，可以设置 supportMediaTypes 属性指定类型，响应信息的媒体类型为 application/octet-stream。
		SourceHttpMessageConverter。读写 javax.xml.transform.Source 类型的数据。泛型 T 为 javax.xml.transform.Source 类型及其扩展类，包括 javax.xml.transform.dom.DOMSource、javax.xml.transform.sax.SAXSource、javax.xml.transform.stream.StreamSource，可以读取 text/xml 和 application/xml 类型请求，响应信息的类型为 text/xml 和 application/xml。
		MarshallingHttpMessageConverter。通过 Spring 的 org.springframework.oxm.Marshalling (将 Java 对象转换成 XML) 和 Unmarshaller(将 XML 解析为 Java 对象) 读写 XML 消息。泛型 T 为 Object 类型，可以读取 text/xml 和 application/xml 类型请求，响应消息的类型为 text/xml 和 application/xml。
		Jaxb2RootElementHttpMessageConverter。通过 JAXB2 读写 XML 消息，将请求消息转换到注解 XmlRootElement 和 XmlType 作用的类中。泛型 T 为 Object 类型，可以读取 text/xml 和 application/xml 类型的请求，响应消息的类型为 text/xml 和 application/xml。
		MappingJackson2HttpMessageConverter。利用 Jackson 开源类包读写 JSON 数据。泛型 T 为 Object 类型，可以读取 application/json 类型数据，响应信息的类型为 application/jspon。
		
	RequestMappingHandlerAdapter 默认已经装配了以下的 HttpMessageConverter：

		StringHttpMessageConverter
		ByteArrayHttpMessageConverter
		SourceHttpMessageConverter
		XmlAwareFormHttpMessageConverter
		
	如果需要装配其他类型的 HttpMessageConverter，则可以再 Spring 的 Web 容器的上下文中自行定义一个 RequestMappingHandlerAdapter，
	如下所示：
		<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
			<property name="messageConverters">
			<list>
				<bean class="org.springframework.http.converter.StringHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.BufferedImageHttpMessageConverter"/>
			</list>
			</property>
		</bean>
	注意：如果 Spring Web 容器中显示定义了一个 RequestMappingHandlerAdapter，
	则 Spring MVC 的 RequestMappingHandlerAdapter 默认装配的 HttpMessageConverter 将不再起作用。

转换 JSON 数据

	Spring MVC 提供了处理 JSON 格式请求/响应的 HttpMessageConverter：
	MappingJackson2HttpMessageConverter。
	
		利用 Jackson 开源类包处理 JSON 格式的请求或响应消息。
		因此只需要在 Spring Web 容器中为 RequestMappingHandlerAdapter 装配处理 JSON 的 HttpMessageConverter，
		并在交互过程中通过请求的 Accept 指定 MIME 类型，Spring MVC 就可以使服务端的处理方法和客户端 JSON 格式的消息进行通信了。

		org.springframework.web.bind.annotation.RequestBody 注解用于读取 Request 请求的 body 部分数据，
			使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到 Controller 中方法的参数上。

		当前台页面使用 GET 或 POST 方式提交数据时，数据编码格式由请求头的 ContentType 指定。可以分为如下几种情况：
			application/x-www.form-urlencoded，
				这种情况的数据 @RequestParam、@ModelAttribute 也可以处理，并且很方便，当然 @RequestBody 也能处理。
			multipart/form-data，@RequestBody 不能处理这种格式的数据。
			application/json、application/xml 等格式的数据，必须使用 @RequestBody 来处理。




Spring MVC 常用注解
	
	启用包扫描逐渐功能：
		<context：component-scan base-package="org.xxx.xxx""/>
		例如：<context：component-scan base-package="org.springframework.samples.petclinic.web"/>
	@Controller：
		指示一个控制器。

	@RequestMapping：
		请求动作映射，@RequestMapping 注释来将 URL 映射/appointments 到整个类或特定的处理程序方法
		属性：
			value：String[] 类型，非必需，用于将请求的实际地址映射到方法上
			name：String 类型，非必需，给映射地址一个别名
			method：RequestMethod[]，非必需，指定请求类型，GET，POST，HEAD，OPTIONS，PUT，PATCH，DELETE，TRACE
			consumes：String[] 类型，非必需，指定请求的提交内容类型 (Content-Type) 如：application/json，text/html 等
			produces：String 类型，非必需，指定返回的内容类型，必须是 request 请求头重所包含的类型。
			params：String[] 类型，非必需，指定 request 中必须包含某些值时，才用这个方法处理。
			headers：String[] 类型，非必需，指定 request 中有指定的 header 时，才用这个方法处理。
			Path：String[] 类型，非必需，在 Servlet 环境中，只用 uri 映射
		请求方法中可以出现的参数类型：
			org.springframework.web.context.request.WebRequest
			org.springframework.web.context.request.NativeWebRequest
			java.util.Locale 当前请求的语言环境
			java.util.TimeZone 时区
			java.io.InputStream 或 java.io.Reader
			java.io.OutputStream 或 java.io.Writer
			org.springframework.http.HttpMethod
			java.security.Principal
			HttpEntity <?>参数用于访问 Servlet 的 HTTP 请求的标题和内容
			java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap 视图隐含模型
			org.springframework.web.servlet.mvc.support.RedirectAttributes 重定向
			命令或表单对象
			基本数据类型，如 int，String，double...
			复杂数据类型，如自定义的 POJO 对象
			HandlerAdapter
			org.springframework.validation.Errors / org.springframework.validation.BindingResult 验证结果
			org.springframework.web.bind.support.SessionStatus 会话状态
			org.springframework.web.util.UriComponentsBuilder
			@PathVariable 注解参数访问 URI 模板变量。
			@MatrixVariable 注释参数用于访问位于 URI 路径段键值对对，矩阵变量。
			@RequestParam 注解参数访问特定的 Servlet 请求参数，请求参数绑定。
			@RequestHeader 注解参数访问特定的 se​​rvlet 请求 HTTP 标头，映射请求头。
			@RequestBody 注解参数访问 HTTP 请求主体，注解映射请求体
			@RequestPart 注解参数访问“的 multipart / form-data 的”请求部分的内容。处理客户端上传文件，多部分文件上传的支持
			@SessionAttribute 注解参数会话属性
			@RequestAttribute 注解参数访问请求属性
		可简记如下：
			 (1) HttpServlet 对象，主要包括 HttpServletRequest 、HttpServletResponse 和 HttpSession 对象。
				这些参数 Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，
				可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。
				但是有一点需要注意的是在使用 HttpSession 对象的时候，如果此时 HttpSession 对象还没有建立起来的话就会有问题。
			 (2) Spring 自己的 WebRequest 对象。使用该对象可以访问到存放在 HttpServletRequest 和 HttpSession 中的属性值。
			 (3) InputStream 、OutputStream 、Reader 和 Writer。
				InputStream 和 Reader 是针对 HttpServletRequest 而言的，
				可以从里面取数据；OutputStream 和 Writer 是针对 HttpServletResponse 而言的，可以往里面写数据。
			 (4) 使用 @PathVariable 、@RequestParam 、@CookieValue 和 @RequestHeader 标记的参数。
			 (5) 使用 @ModelAttribute 标记的参数。
			 (6) java.util.Map 、Spring 封装的 Model 和 ModelMap。这些都可以用来封装模型数据，用来给视图做展示。
			 (7) 实体类。可以用来接收上传的参数。
			 (8) Spring 封装的 MultipartFile。用来接收上传文件的。
			 (9) Spring 封装的 Errors 和 BindingResult 对象。这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。
		请求处理方法可以返回的类型：
			 (1) 一个包含模型和视图的 ModelAndView 对象。
			 (2) 一个模型对象，这主要包括 Spring 封装好的 Model 和 ModelMap，以及 java.util.Map，
				当没有视图返回的时候视图名称将由 RequestToViewNameTranslator 来决定。
			 (3) 一个 View 对象。
				这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。
			 (4) 一个 String 字符串。这往往代表的是一个视图名称。
				这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。
			 (5) 返回值是 void。这种情况一般是我们直接把返回结果写到 HttpServletResponse 中了，如果没有写的话，那么 Spring 将会利用 RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。
			 (6) 如果处理器方法被注解 @ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过 HttpMessageConverters 转换之后写到 HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。
			 (7) 
				除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，
				而返回的视图还是由 RequestToViewNameTranslator 来决定，
				添加到模型中的属性名称可以在该方法上用 @ModelAttribute(“attributeName”) 来定义，
				否则将使用返回类型的类名称的首字母小写形式来表示。
				使用 @ModelAttribute 标记的方法会在 @RequestMapping 标记的方法执行之前执行。

	@RequestParam
		用于将指定的请求参数赋值给方法中的形参。
		属性：
			name：String 类型，非必需，指定请求头绑定的名称。
			value：String 类型，非必需，namme 属性的别名。
			required：boolean 类型，非必需，指定参数是否必须绑定。
			defaultValue：String 类型，非必需，参数默认值。
	
	@PathVariable
		属性：
		value：String 类型，非必需，如果省略则默认绑定同名参数，表示取值 uri 中的变量值。

	@RequestHeader
		将请求头数据映射到处理方法的参数上。
		属性：
			name：String 类型，非必需，请求头绑定的名称。
			value：String 类型，非必需，name 的别名。
			required：boolean 类型，非必需，指定参数是否必须绑定。
			defaultValue：String 类型，非必需，参数默认值。
	
	@CookieValue
		映射请求头的 Cookie 信息到处理方法的参数上。
		属性：
			name：String 类型，非必需，请求头绑定的名称。
			value：String 类型，非必需，name 的别名。
			required：boolean 类型，非必需，指定参数是否必须绑定。
			defaultValue：String 类型，非必需，参数默认值。
	
	@SessionAttributes
		允许我们有选择的指定 Model 中的哪些属性需要转存到 HttpSession 对象中。
		属性：
			names：String[] 类型，非必需，Model 中属性的名称，即存在 HttpSession 中的名称。
			value：String[] 类型，非必需，names 属性的别名。
			types：Class<?>[]，非必需，指定参数是否必须绑定。
			只能声明在类上，不能声明到方法上。

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
Spring MVC 工作原理

	Spring MVC 简介
		Spring 是一个开源框架，Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架。
		它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
		Spring 使用基本的 JavaBean 来完成以前只可能由 EJB 完成的事情。然而，Spring 的用途不仅限于服务器端的开发。
		从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。
		Spring 的核心是控制反转 (IoC) 和面向切面 (AOP) 。简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级开源框架。

	补充知识点
		Spring Web MVC 框架是以请求为驱动，围绕中央 Servlet 设计，将请求发送给控制器，并提供了其他促进 Web 应用程序开发的功能。
		DispatcherServlet 就是这个中央 Servlet，DispatcherServlet 是一个真正的 Servlet。
		DispatcherServlet 的功能很强大，它与 Spring IOC 容器完全兼容，因此可以使用任何 Spring 拥护的特征。

	DispatcherServlet 拥有一些特别的 beans 来处理请求和呈现适当的视图：
		HandlerMapping：
			用于 handlers 映射请求和一系列的对于拦截器的前处理和后处理，大部分时候使用 @controller 注解，也可以使用其他接口。
		HandlerAdapter	：
			帮助 DispatcherServlet 处理映射请求处理程序，而不管实际调用的是那个处理程序。
			具体些就是 HandlerAdapter 是隐藏在 DispatcherServlet 之下的。一般情况下调用的处理器是 @Controller 注解的处理器。
		HandlerExceptionResolver：
			处理映射异常。
		ViewResolver：
			根据实际配置解析实际的 View 类型。
		LocaleResolver & LocaleContextResolver：
			解决客户端正在使用的的区域设置以及可能的时区，以便能够提供国际化视野。
		ThemeResolver：
			解决 Web 应用程序可以使用的主题，例如提供个性化布局。
		MultipartResolver：
			解析多部分请求，以支持从 HTML 表单中上传文件
		FlashMapManager：
			存储并检索可用于将一个请求属性传递到另一个请求的 input 和 output 的 FlashMap，通常用于在重定向中




















































核心配置
	配置扫描路径：
		<context：component-scan base-package="com.taotao.controller" />
	配置注解驱动来支持注解：
		<mvc：annotation-driven />
	解析器过滤资源的前缀和后缀：
		<bean
			class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" value="/WEB-INF/jsp/" />
			<property name="suffix" value=".jsp" />
		</bean>	












