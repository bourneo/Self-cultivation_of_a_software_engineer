
SpringMVC


SpringMVC 核心
	是什么：
		基于 mvc 模式 和 servlet 的开源框架；
		连接视图和服务的中间件，目前最流行的 web 项目表现层框架。
	为什么使用：
		功能强大，使用方便的轻量级开源框架；
	基本原理：
		http 请求到 web 服务器；
		DispatcherServlet 匹配请求路径；
		HandlerMapping 寻找对应的 Handler；
		HandlerAdapter 调用 Handler；
		Handler 处理数据后返回逻辑视图 ModelAndView；
		ViewResolve 把逻辑视图转化成真正的 View；
		Dispatcher 解析逻辑视图中的参数后放入视图，把结果返回给客户端。
	怎么使用：
		将服务层对象注入 SpringIOC 容器，
		然后配置配置过滤规则，
		编写对应的 controller 为视图提供访问接口。
		

SpringMVC 工作原理
	1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，
		如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.
	2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）
		以及HandlerMapping的配置找到处理请求的处理器（Handler）。
	3-4、DispatcherServlet根据HandlerMapping找到对应的Handler，将处理权交给Handler（Handler将具体的处理进行封装），
		再由具体的HandlerAdapter对Handler进行具体的调用。
	5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。
	6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，
		DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。
	7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。

Spring MVC工作流程
	Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。
	Spring Web MVC 框架是围绕 DispatcherServlet 设计的，
		DispathcerServlet 相当于与一个调度器，将请求根据处理流程一步一步分发给相应的解析器解析处理。
	工作流程：
		1、客户端将请求发送给后台（一般都是通过浏览器进行发送的），请求到了后台都是交给DispatcherServlet处理，
			所有相当于是直接发送给了 DispatcherServlet。
		2、DispatcherServlet 根据请求的信息（URL、Http方法、请求报文头、请求参数Cookie等）
			调用HandlerMapping解析器解析该请求对应的handler。
		3、解析到对应的handler后，DispatcherServlet将控制权移交给HandlerAdapter来处理请求，
			HandlerAdapter将处理器包装为适配器，从而支持多种类型的处理器。
		4、HandlerAdapter会根据实际需要的Handler调用真正的处理器来处理请求，处理器根据要求处理业务逻辑。
		5、处理器处理完业务逻辑之后会返回一个ModelAndView对象，这里的Model是处理器处理完成之后的数据，
			View是一个逻辑上的View。
		6、ViewResolver会根据逻辑View查找实际对应的是那个View。
		7、DispatcherServlet最后将5中返回的Model放入到6中解析的正真的View中生成结果，并返回给请求者。

	DispatcherServlet
		DispatcherServlet 介绍
			在Web MVC框架中，每个DispatcherServlet都拥有自己的WebApplicationContext，
			它继承了在root WebApplicationContextContext中定义的所有beans。
			root WebApplicationContext包含了在其上下文和Sevlet实例之间共享的所有基础框架beans。
		DispatcherServlet的上下文继承：
			对于上下文的继承，特殊情况是可以把Controller、ViewResolver、HandlerMapping放在Root WebApplicationContext中。
		DispatcherServlet 就像一个“Front Controller”设计模式，Spring farmwork 文档中给出 DispathcerServlet 的处理流程如：
			在初始化 DispatherServlet 时，在初始化 DispatcherServlet 时，
			Spring MVC 会查找一个在 WEB-INF 下名为 [servlet-name]-servlet.xml 的文件且在这里创建 beans。
		例如在 web.xml 中声明 servlet-name 如下图：
			<web-app>
				<servlet>
					<servlet-name>golfing</servlet-name>
					<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
					<load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping>
					<servlet-name>golfing</servlet-name>
					<url-pattern>/golfing/*</url-pattern>
				</servlet-mapping>
			</web-app>
		则必须在/WEB-INF/下建立文件golfing-servlet.xml文件，这个文件会包含所有beans。
		现在比较流行注解方式，使用注解方式在项目初始化的时候会把注解类注入到Servlet WebApplicationContext中，
		所以DispatcherServlet也可以读取到注解的bean。

		DispatcherServlet的对请求的处理流程：
			● 在请求中搜索并绑定WebApplicationContext作为controlelr和程序中其他元素可以使用的属性。
			● 当处理请求时，将区域解析器（Locale resolver)绑定到请求中，
				以便于在进程中的元素可以解决区域问题。区域解析器是可选的。
			● 主题解析器（Theme resolver）被绑定到请求中，用于诸如视图之类的元素使用哪种主题的请求。可选。
			● 检查请求中是否指定多部分文件解析器（multipart file resolver)，
				若有则使用使用MultipartHttpServletRequest作为处理程序。
			● 查找合适的handler，如果找到合适的handler，
				则执行与处理程序（预处理程序、后处理程序和Controller）关联的执行链，以便准备模型或呈现。
			● 如果model返回，则view就呈现；如果model没有返回，就没有view呈现。

	HandlerMappings
			在以前的版本的Spring中，为寻找合适的handlers，
			我们需要在web application context中定义一个或多个HandlerMapping beans去匹配web 请求。
			而现在的注解控制器，不需要这样做了，
			因为 RequestMappingHandlerMapping 会自动地寻找在所有 @Controller beans 的 @RequestMapping 注解来寻找合适的 handlers。

		由于HandlerMapping是从AbstractHandlerMapping中扩展而来，因此HandlerMapping拥有以下特性：
			● 有一系列的拦截器可以使用。
			● 当handler mapping没有匹配到handler时，会默认使用defaultHandler 。
			● 匹配的顺序是基于order属性的，Spirng会对所有在环境中可用的handler mapping进行排序，
				并且使用第一个匹配的到handler。
			● 如果设置alwaysUseFullPath为true，Spring将会使用完整路径去匹配合适的handler；否则会使用相对路径。
				例如，如果Servlet的映射是使用/testing/*且alwaysUseFullPath属性是true，
				当使用/testing/viewPage.html，不管这个属性是真是假，都返回/viewPage.html。
			● urlDecode默认是true，如果选择比较encoded的路径，需要设置该标识为false。
				注：当比较encoded路径是不会匹配Servlet路径的。

		一共有三种拦截器：
			● preHandle()：在真正的handler执行之前调用。
			● postHandle()：在handler执行之后调用。
			● afterCompletion()：在完成请求之后调用。

		preHandle()方法返回一个布尔值。
		当返回的是true时，handler执行链才会继续执行；
		当返回的false时，DispatcherServlet假设拦截器本身可以处理请求（例如呈现视图），
		并且不会执行在执行链中的其他拦截器和handler。
		可以使用preHandle()来筛选、预处理请求。

		使用拦截器的例子如下：
			<beans>
				<bean id="handlerMapping"
						class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping">
					<property name="interceptors">
						<list>
							<ref bean="officeHoursInterceptor"/>
						</list>
					</property>
				</bean>
				<bean id="officeHoursInterceptor"
						class="samples.TimeBasedAccessInterceptor">
					<property name="openingTime" value="9"/>
					<property name="closingTime" value="18"/>
				</bean>
			</beans>
			
			package samples;
			public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {
				private int openingTime;
				private int closingTime;

				public void setOpeningTime(int openingTime) {
					this.openingTime = openingTime;
				}
				public void setClosingTime(int closingTime) {
					this.closingTime = closingTime;
				}

				public boolean preHandle(HttpServletRequest request， HttpServletResponse response，
						Object handler) throws Exception {
					Calendar cal = Calendar.getInstance();
					int hour = cal.get(HOUR_OF_DAY);
					if (openingTime <= hour && hour < closingTime) {
						return true;
					}
					response.sendRedirect("http：//host.com/outsideOfficeHours.html");
					return false;
				}
			}
			
		任何请求都会被TimeBasedAccessInterceptor处理。
		如果当前时间不是工作时间，用户将会重定向到一个指向静态HTML的文件，只能在工作时间使用该网站。

		注：postHandle 方法并不是特别适用于@ResponseBody 和 ResponseEntity 方法中，
		postHandle()是在HttpMessageConverter写入并提交响应之后执行，因此postHandle有可能会改变响应。

		
	HandlerAdapter

		HandlerAdapter用于调用具体的handler来处理业务逻辑。
		HandlerAdapter实现了每种不同类型的handler，DispatcherServlet将控制权交给HandlerAdapter，
		并通过HandlerAdapter接口访问所有已安装的处理程序，允许DispatcherServlet无限扩展，
		这也意味着HandlerAdapter不包含任何特定于处理程序的特定代码，相当于一个中间件，用于调用具体的Handler。

		从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，
		推荐使用RequestMappingHandlerAdapter完成注解式处理器适配来对标记@ResquestMapping的方法进行适配。
		springmvc使用<mvc：annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，
		可用在springmvc.xml配置文件中使用<mvc：annotation-driven>替代注解处理器和适配器的配置。

	Handler

		默认的Handler是基于@Controller 和 @RequestMapping注解的，提供了广泛的灵活handling 方法。
		而@Controller又会调用Service和Dao来完成一些业务逻辑处理。@RequestMapping注解用于去匹配URL。

		新特性：
		在Spring4.3还有@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping等直接筛选请求类型的注解。
		例如@GetMapping("/owners/{ownerId}")可以在请求路径上设置参数，在函数参数中使用@PathVariable String owner获取参数。
		在RFC 3986规范中还可以使用Matrix Variables。还可以使用Consumable Media Types来限制media的类型。

	Model And View
		ModelAndView对象是连接业务逻辑层与view展示层的桥梁，对spring MVC来说它也是连接Handler与view的桥梁。
		ModelAndView对象顾名思义会持有一个ModelMap对象和一个View对象或者View的名称。
		这个View的名称知识一个逻辑上的View名称，怎么理解呢，
		假设我们最后返回一个jsp对象，那么只需在controller中返回success或error，即可，这个是逻辑上的，
		而实际上的就是返回/WEB-INF/jsp/success.jsp或/WEB-INF/jsp/error.jsp才是真实的View。

	ViewResolver
		所有的handler都必须明确返回一个ModelAndView对象，其中的View是一个逻辑上的视图，比如明确返回String，View，or ModelAndView或隐式地（基于约定）。逻辑视图由ViewResolver解析，以下是Spring中的拥有的视图解析器：
			AbstractCachingViewResolver：
				抽象视图解析器器即caches视图。通常views在使用之前需要准备，扩展此视图解析器是提供缓存。
			* XmlViewResolver*：
				实现ViewResolver，它接受XML编写的配置文件（与Spring XML bean相同的DTD），默认的配置的文件是/WEB-INF/view.xml。
			ResourceBundleViewResolver：
				实现ViewResolver，它使用ResourceBundle中的bean定义，由bundle基本名称指定。
				默认的文件名是在classpath中的views.properties。
			UrlBasedViewResolver：
				简单地实现ViewResolver接口，它影响了逻辑视图名到URL的直接解析，而不需要明确的映射定义。
				适用于逻辑名称和视图资源的直接名称匹配，这种方式不需要映射。
			InternalResourceViewResolver：
				是UrlBasedViewResolver 的子类，支持InternalResourceView（Servlets和JSP）和子类，
				例如JstlView和TilesView。也可以公国setViewClass来具体制定那种视图类。
			FreeMarkerViewResolver：
				UrlBasedViewResolver 的子类，支持FreeMarkerView和它的常规子类。
			ContentNegotiatingViewResolver：
				实现ViewResolver接口，它解析基于请求文件名或Accept 头的视图。

		例如常见的返回JSP视图的配置如下：
			<bean id="viewResolver"
					class="org.springframework.web.servlet.view.UrlBasedViewResolver">
				<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
				<property name="prefix" value="/WEB-INF/jsp/"/>
				<property name="suffix" value=".jsp"/>
			</bean>
		在controller中返回的逻辑视图名为test，而最终视图的地址为：前缀+逻辑视图名+后缀，
		所以RequestDispatcher的视图解析器最后返回/WEB-INF/jsp/test.jsp。
		pring支持多视图解析器，可以在程序上下文中添加多个视图解析器，还可以设置“order”属性来指定匹配优先级。
		Spring会找到合适的第一个视图解析器来返回结果。如果没有找到视图，则返回null。

	View
		现在业务逻辑处理的数据存放在Model中，返回的View也确定了，
		最后一步只需将Model中的数据项View中填充即可，最后将数据返回给请求者。
		View可以是支持：
			字符串、JSON Mapping View、JSP & JSTL、XML Marshalling View、Document views (PDF/Excel)、
			Thymeleaf、Groovy Markup Templates、FreeMarker、Script templates、Tiles、Feed View多种格式的视图，
			DispatcherServlet根据不同handler的不同配置选择不同的View返回。


Spring MVC 常用注解

@RequestMapping：
	这个注解类型指示Spring用哪一个类或方法来处理请求动作，该注解可以用于类或方法；

	@RequestMapping注解支持的属性：
		value属性
			这个属性将URL映射到方法上，由于value属性是@RequestMapping注解的默认属性，因此如果只有唯一属性，则可以省略属性名；
			即如下两个标注含义相同：
			@RequestMapping("value="/hello")
			@RequestMapping（"/hello"）
			但如果超过一个属性，就必须写上value属性名称
		method属性
			该属性用来指示该方法仅仅处理哪些HTTP请求方式，如果没有指定method属性值，则请求处理方法可以处理任意的HTTP请求方式。
		consumes 属性
			该属性指定处理请求的提交内容类型（Content-Type）
			@RequestMapping（value="/hello"，method=RequestMethod.POST， consumes="application/json"）
			表示方法仅处理request Content-Type 为"application/json"类型的请求。
		produces属性
			该属性指定返回的内容类型，返回的内容类型必须是request请求头（Accept）中所包含的类型。
			@RequestMapping（value="/hello"，method=RequestMethod.POST， produces="application/json"）
			方法仅处理request请求中Accept头中包含了"application/json"的请求，同时指明了返回的内容类型为application/json。
		params属性
			该属性指定request中必须包含某些参数值时，才让该方法处理。
			@RequestMapping（value="/hello"，method=RequestMethod.POST， params="myparam=myvalue"）
			方法仅处理其中名为"myparam"、值为"myvalue"的请求。
		headers属性


Model和ModelMap
	Spring MVC 在内部使用了一个org.springframework.ui.Model接口存储模型数据，它的功能类似java.util.Map接口，但是比Map易于使用。
	org.springframework.ui.ModelMap接口实现了Map接口。

	Spring MVC 在调用处理方法之前会创建一个隐含的模型对象，作为模型数据的存储容器。
	如果处理方法的参数为Model或ModelMap类型，则Spring MVC会将隐含模型的引用传递给这些参数。
	在处理方法内部，开发者就可以通过这个参数对象访问模型中的所有数据，也可以向模型中添加新的属性数据。

	在处理方法中，Model和ModelMap对象都可以使用如下方法添加模型数据：
	addObject(String attributeName，Object attributeValue)

@RequestParam
	org.springframework.web.bind.annotation.RequestParam 注解类型用于将指定的请求参数赋值给方法中的形参。
	使用@RequestParam 注解可指定如下表所示的属性：

	属性	类型	是否必要	是否说明
	name	String	否	指定请求头绑定的名称
	value	String	否	name属性的别名
	required	boolean	否	指定参数是否必须绑定
	defaultValue	String	否	如果没有传递参数而使用的默认值
	
@PathVariable注解
	org.springframework.web.bind.annotation.PathVariale 注解类型可以非常方便地获得请求URL中的动态参数。@PathVariable注解只支持一个属性value，类型为String，表示绑定的名称，如果省略则默认绑定同名参数.示例代码如下:
		@RequestMapping(value="/pathVariableTest/{userId}")
		public void pathVariableTest(@PathVariable Integer userId)
		URL模版变量{userId}绑定到通过@PathVariable注解的同名参数上

@ReuqestHeader注解
	org.springframework.web.bind.annotation.RequestHeader注解类型用于将请求的头信息区数据映射到功能处理方法的参数上。
@CookieValue注解
	org.springframework.web.bind.annotation.CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上。
@SessionAttributes注解
	org.spingframework.web.bind.annotation.SessionAttribute注解类型
	允许我们有选择地指定Model中的哪些属性需要转存到HttpSession对象当中。
	属性	类型	是否必要	是否说明
	names	String[]	否	Model中属性的名称，即存储在HttpSession当中的属性名称
	value	String[]	否	names属性的别名
	types	Class<?>[]	否	指定放入对象的类型
	@SessionAttributes 只能声明在类上，而不能声明在方法上。
	使用方法如下：

		// 将Model中的属性名为user的属性放入HttpSession对象当中
		@SessionAttributes("user")
		@SessionAttributes（types={User.class}，value="user"）
		// 也可以设置多个对象到HttpSession当中：
		@SessionAttributes（types={User.class，Dept.class}，value={"user"，"dept"}）
		types属性用来指定放入HttpSession当中的对象类型。
	
信息转换

HttpMessageConverter< T >接口

	HttpMessageConverter< T > 是Spring3.0之后新增的一个重要接口，它负责将请求信息转换为一个对象（类型为T），
	并将对象(类型为T)绑定到请求方法的参数中或输出为响应信息。
	DispatcherServlet默认已经装配了RequestMappingHandlerAdapter作为HandlerAdapter组件的实现类，
	即HttpMessageConverter由RequestMappingHandlerAdapter使用，将请求信息转换为对象，或将对象转换为响应信息。
	
	HttpMessageConverter< T >接口中定义了以下几个方法：

		boolean canRead(Class< ? > clazz，MediaType mediaType)。该方法指定转换器可以读取的对象类型，即转换器可将请求信息转换为clazz类型的对象，同时指定支持的MIME类型(text/html、application/json等)。MIME媒体类型在RFC2616中定义，具体请参考https://tools.ietf.org/html/rfc2616#section-3.7
		boolean canWrite(Class< ? >clazz， MediaType mediaType)。该方法指定转换器可以将clazz类型的对象写到响应流当中，响应流支持的媒体类型在mediaType中定义。
		List<MediaType> getSupportedMediaTypes()。该方法返回当前转换器支持的媒体类型。
		T read(Class< ? extends T> clazz，HttpInputMessage inputMessage)。该方法将请求信息流转换为T类型的对象。
		void write (T t，MediaType contentType，HttpOutputMessage outMessage)。该方法将T类型的对象写到响应流当中，同时指定响应的媒体类型为contentType。
		
	Spring为HttpMessageConverter< T> 提供了多个实现类，这些实现类组成了一个功能强大、用途广泛的信息转换家族：

		StringHttpMessageConverter。 将请求信息转换为字符串。泛型T为String类型，可以读取所有媒体类型( /)的请求信息，可通过设置supportedMediaTypes属性指定媒体类型。响应信息的媒体类型为text/plain(即Content-Type的值)。
		FormHttpMessageConverter。 将表单数据读取到MultiValueMap中。泛型T为org.springframework.util.MultiValueMap< String，? >类型，支持读取application/x-www-form-urlencoded的类型，但不支持读取multipart/form-data的类型。可以写application/x-www-form-urlencoded及multipart/form-data类型的响应信息。
		XmlAwareFormHttpMessageConverter。继承自FormHttpMessageConverter，如果部分表单属性是XML数据，则可以用该转换器进行转换。
		ResourceHttpMessageConverter。读写org.springframework.core.io.Resource对象。泛型T为org.springframework.core.io.Resource对象，可以读取所有媒体类型( /)的请求信息。如果类路径下提供了JAF(Java Activation Framework)，则根据Resource的类型指定响应的类型，否则响应的类型为application/octet-stream。
		BufferedImageHttpMessageConverter。读写BufferedImage对象。泛型T为BufferedImage对象，可以读取所有类型( /)的请求信息，返回BufferedImage相应的类型，也可以通过contentType显示指定。
		ByteArrayHttpMessageConverter。读写二进制数据。泛型T为byte[]类型，可以读取所有类型( /)的请求信息，可以设置supportMediaTypes属性指定类型，响应信息的媒体类型为application/octet-stream。
		SourceHttpMessageConverter。读写javax.xml.transform.Source类型的数据。泛型T为javax.xml.transform.Source类型及其扩展类，包括javax.xml.transform.dom.DOMSource、javax.xml.transform.sax.SAXSource、javax.xml.transform.stream.StreamSource，可以读取text/xml和application/xml类型请求，响应信息的类型为text/xml和application/xml。
		MarshallingHttpMessageConverter。通过Spring 的 org.springframework.oxm.Marshalling（将Java对象转换成XML）和 Unmarshaller(将XML解析为Java对象)读写XML消息。泛型T为Object类型，可以读取text/xml和application/xml类型请求，响应消息的类型为text/xml和application/xml。
		Jaxb2RootElementHttpMessageConverter。通过JAXB2读写XML消息，将请求消息转换到注解XmlRootElement和XmlType作用的类中。泛型T为Object类型，可以读取text/xml和application/xml类型的请求，响应消息的类型为text/xml和application/xml。
		MappingJackson2HttpMessageConverter。利用Jackson开源类包读写JSON数据。泛型T为Object类型，可以读取application/json类型数据，响应信息的类型为application/jspon。
		
	RequestMappingHandlerAdapter默认已经装配了以下的HttpMessageConverter：

		StringHttpMessageConverter
		ByteArrayHttpMessageConverter
		SourceHttpMessageConverter
		XmlAwareFormHttpMessageConverter
		
	如果需要装配其他类型的HttpMessageConverter，则可以再Spring的Web容器的上下文中自行定义一个RequestMappingHandlerAdapter，
	如下所示：
		<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
			<property name="messageConverters">
			<list>
				<bean class="org.springframework.http.converter.StringHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter"/>
				<bean class="org.springframework.http.converter.BufferedImageHttpMessageConverter"/>
			</list>
			</property>
		</bean>
	注意：如果Spring Web容器中显示定义了一个RequestMappingHandlerAdapter，
	则Spring MVC 的RequestMappingHandlerAdapter默认装配的HttpMessageConverter将不再起作用。

转换JSON 数据

	Spring MVC提供了处理JSON格式请求/响应的HttpMessageConverter：
	MappingJackson2HttpMessageConverter。
	
		利用Jackson开源类包处理JSON格式的请求或响应消息。
		因此只需要在Spring Web容器中为RequestMappingHandlerAdapter装配处理JSON的HttpMessageConverter，
		并在交互过程中通过请求的Accept指定MIME类型，Spring MVC就可以使服务端的处理方法和客户端JSON格式的消息进行通信了。

		org.springframework.web.bind.annotation.RequestBody注解用于读取Request请求的body部分数据，
			使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到Controller中方法的参数上。

		当前台页面使用GET 或 POST 方式提交数据时，数据编码格式由请求头的ContentType指定。可以分为如下几种情况：
			application/x-www.form-urlencoded，
				这种情况的数据@RequestParam、@ModelAttribute也可以处理，并且很方便，当然@RequestBody也能处理。
			multipart/form-data，@RequestBody不能处理这种格式的数据。
			application/json、application/xml等格式的数据，必须使用@RequestBody来处理。




Spring MVC 常用注解
	
	启用包扫描逐渐功能：
		<context：component-scan base-package="org.xxx.xxx""/>
		例如：<context：component-scan base-package="org.springframework.samples.petclinic.web"/>
	@Controller：
		指示一个控制器。

	@RequestMapping：
		请求动作映射，@RequestMapping注释来将URL映射/appointments到整个类或特定的处理程序方法
		属性：
			value：String[]类型，非必需，用于将请求的实际地址映射到方法上
			name：String 类型，非必需，给映射地址一个别名
			method：RequestMethod[]，非必需，指定请求类型，GET，POST，HEAD，OPTIONS，PUT，PATCH，DELETE，TRACE
			consumes：String[]类型，非必需，指定请求的提交内容类型（Content-Type）如：application/json，text/html等
			produces：String类型，非必需，指定返回的内容类型，必须是request请求头重所包含的类型。
			params：String[]类型，非必需，指定request中必须包含某些值时，才用这个方法处理。
			headers：String[]类型，非必需，指定request中有指定的header时，才用这个方法处理。
			Path：String[]类型，非必需，在Servlet环境中，只用uri映射
		请求方法中可以出现的参数类型：
			org.springframework.web.context.request.WebRequest
			org.springframework.web.context.request.NativeWebRequest
			java.util.Locale 当前请求的语言环境
			java.util.TimeZone 时区
			java.io.InputStream或java.io.Reader
			java.io.OutputStream或java.io.Writer
			org.springframework.http.HttpMethod
			java.security.Principal
			HttpEntity <?>参数用于访问Servlet的HTTP请求的标题和内容
			java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap 视图隐含模型
			org.springframework.web.servlet.mvc.support.RedirectAttributes 重定向
			命令或表单对象
			基本数据类型，如int，String，double...
			复杂数据类型，如自定义的POJO对象
			HandlerAdapter
			org.springframework.validation.Errors / org.springframework.validation.BindingResult 验证结果
			org.springframework.web.bind.support.SessionStatus 会话状态
			org.springframework.web.util.UriComponentsBuilder
			@PathVariable 注解参数访问URI模板变量。
			@MatrixVariable 注释参数用于访问位于URI路径段键值对对，矩阵变量。
			@RequestParam 注解参数访问特定的Servlet请求参数，请求参数绑定。
			@RequestHeader 注解参数访问特定的se​​rvlet请求HTTP标头，映射请求头。
			@RequestBody 注解参数访问HTTP请求主体，注解映射请求体
			@RequestPart 注解参数访问“的multipart / form-data的”请求部分的内容。处理客户端上传文件，多部分文件上传的支持
			@SessionAttribute 注解参数会话属性
			@RequestAttribute 注解参数访问请求属性
		可简记如下：
			（1）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 
				这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，
				可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。
				但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。
			（2）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。
			（3）InputStream 、OutputStream 、Reader 和Writer 。 
				InputStream 和Reader 是针对HttpServletRequest 而言的，
				可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。
			（4）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。
			（5）使用@ModelAttribute 标记的参数。
			（6）java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。
			（7）实体类。 可以用来接收上传的参数。
			（8）Spring 封装的MultipartFile 。 用来接收上传文件的。
			（9）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。
		请求处理方法可以返回的类型：
			（1）一个包含模型和视图的ModelAndView 对象。
			（2）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，
				当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。
			（3）一个View 对象。
				这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。
			（4）一个String 字符串。这往往代表的是一个视图名称。
				这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。
			（5）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。
			（6）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。
			（7）
				除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，
				而返回的视图还是由RequestToViewNameTranslator 来决定，
				添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，
				否则将使用返回类型的类名称的首字母小写形式来表示。
				使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。

	@RequestParam
		用于将指定的请求参数赋值给方法中的形参。
		属性：
			name：String类型，非必需，指定请求头绑定的名称。
			value：String类型， 非必需，namme属性的别名。
			required：boolean类型，非必需，指定参数是否必须绑定。
			defaultValue：String类型，非必需，参数默认值。
	
	@PathVariable
		属性：
		value：String类型，非必需，如果省略则默认绑定同名参数，表示取值uri中的变量值。

	@RequestHeader
		将请求头数据映射到处理方法的参数上。
		属性：
			name：String类型，非必需，请求头绑定的名称。
			value：String类型，非必需，name的别名。
			required：boolean类型，非必需，指定参数是否必须绑定。
			defaultValue：String类型，非必需，参数默认值。
	
	@CookieValue
		映射请求头的Cookie信息到处理方法的参数上。
		属性：
			name：String类型，非必需，请求头绑定的名称。
			value：String类型，非必需，name的别名。
			required：boolean类型，非必需，指定参数是否必须绑定。
			defaultValue：String类型，非必需，参数默认值。
	
	@SessionAttributes
		允许我们有选择的指定Model中的哪些属性需要转存到HttpSession对象中。
		属性：
			names：String[]类型，非必需，Model中属性的名称，即存在HttpSession中的名称。
			value：String[]类型，非必需，names属性的别名。
			types：Class<?>[]，非必需，指定参数是否必须绑定。
			只能声明在类上，不能声明到方法上。

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
Spring MVC 工作原理

	Spring MVC简介
		Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架。
		它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
		Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。
		从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。
		Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。

	补充知识点
		Spring Web MVC框架是以请求为驱动，围绕中央Servlet设计，将请求发送给控制器，并提供了其他促进Web应用程序开发的功能。
		DispatcherServlet就是这个中央Servlet，DispatcherServlet是一个真正的Servlet。
		DispatcherServlet的功能很强大，它与Spring IOC容器完全兼容，因此可以使用任何Spring拥护的特征。

	DispatcherServlet拥有一些特别的beans来处理请求和呈现适当的视图：
		HandlerMapping：
			用于handlers映射请求和一系列的对于拦截器的前处理和后处理，大部分时候使用@controller注解，也可以使用其他接口。
		HandlerAdapter	：
			帮助DispatcherServlet处理映射请求处理程序，而不管实际调用的是那个处理程序。
			具体些就是HandlerAdapter是隐藏在DispatcherServlet之下的。 一般情况下调用的处理器是@Controller注解的处理器。
		HandlerExceptionResolver：
			处理映射异常。
		ViewResolver：
			根据实际配置解析实际的View类型。
		LocaleResolver & LocaleContextResolver：
			解决客户端正在使用的的区域设置以及可能的时区，以便能够提供国际化视野。
		ThemeResolver：
			解决Web应用程序可以使用的主题，例如提供个性化布局。
		MultipartResolver：
			解析多部分请求，以支持从HTML表单中上传文件
		FlashMapManager：
			存储并检索可用于将一个请求属性传递到另一个请求的input和output的FlashMap，通常用于在重定向中




















































核心配置
	配置扫描路径：
		<context：component-scan base-package="com.taotao.controller" />
	配置注解驱动来支持注解：
		<mvc：annotation-driven />
	解析器过滤资源的前缀和后缀：
		<bean
			class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" value="/WEB-INF/jsp/" />
			<property name="suffix" value=".jsp" />
		</bean>	












