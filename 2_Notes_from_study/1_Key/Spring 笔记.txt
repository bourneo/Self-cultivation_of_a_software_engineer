
Spring


Spring 核心
	是什么：
		提供 依赖注入 的容器框架；
	为什么使用：
		可以创建和维护 Bean 之间的关系；可以管理表现层、服务层、持久层，并且维护各层之间的关系。
	基本原理：
		IOC 容器：
		AOP 切面：
		启动过程：
	怎么使用：
		配置核心配置文件的路径；
		配置核心配置文件；
		
		
	Spring 依赖注入的三种方式：
		interface：
			@Resource
			private UserService userService;
		setter：
			private UserDao userDao;
			@Resource
			public void setUserDao(UserDao userDao) {
				super.setBaseDao(userDao);
				this.userDao = userDao;
			}
		constructor：
			private DataBase db; 
			public Business (DataBase db) { 
			this.db = db; 
			} 

Spring 对 json 数据转换成对象的处理
	
	一：@RequestBody

		面对前端传输过来的json数据 ，通过该注解可以让它自动装配成map对象或自定义对象（前提要用二中的注解先作匹配）


	二：@JsonProperty(value = "register_id")
	     1：在实体类中：

		  @JsonProperty(value = "register_id")

		   private String registerId;
	     2：在浏览器前端输入json格式：

		   {

		    "register_id":"12345"

		   }
		
	后台可以使用  @ModelAttribute 、 @RequestBody 

	    都是根据被转换的对象的字段依次从请求参数中获取对应的字段设置值。


	前端有所不同：

	data   一个要的json字符串， 一个是 json对象

	    1.    @RequestBody  

		$.ajax({
		    type: "post",
		    contentType: 'application/json;charset=UTF-8', //必须这么写； 表示传递的参数 是 json类型的  
		    dataType:'json',//非必须
		    data: JSON.stringify({  //必须转换为json字符串传递 ，要直接传该字符，否则就是错误。
			userName: 'xxx'
		    } ),
		    url: 'user/save',
		    success: function (res) {
			console.log(res);
		    }

	    });


	    2.    @ModelAttribute  

		$.ajax({

		    type: "post",

	//    contentType: 'application/x-www-form-urlencoded;charset=UTF-8',//这是默认的 请求类型
		    data: {  //必须转换为json字符串 ，直接传json
			userName: 'xxx'
		    } ,
		    url: 'user/save',
		    success: function (res) {
			console.log(res);
		    }

	    });
		
		
	@requestbody 
		放在controller层有@requestmapping注解的方法参数前面的注解，
			例如：
				@RequestMapping(value = "user/login")
				@ResponseBody
				// 将ajax（datas）发出的请求写入 User 对象中
				public User login(@RequestBody User user) {   
				// 这样就不会再被解析为跳转路径，而是直接将user对象写入 HTTP 响应正文中
				    return user;    
				}
	@jsonproperty是放在实体类参数上的注解 ，
		该注解的目的是为了让前台穿过来的json数据按照@jsonproperty注释过的实体类的格式拼装成一个跟实体类一样的对象 这样间接实现了前台传输对象到后台（该对象是通过注解拼装而成的）
	
	
	
	
	
	
	
	
	
	
	
		
Spring 基本概念
	BOP (Bean Oriented Programming)：面向 Bean 的编程；
	POJO (Plain Old Java Object)：普通 Java™ 对象；
	DI（Dependency Injection）：依赖注入；
	IoC（Inversion of Control）：控制倒转
	AOP（Aspect-Oriented Programming）：面向切面编程。
	
	1）spring是容器框架，创建bean，维护bean之间的关系；truts2是web框架，hibernate是orm框架；
	2）spring可以管理web层，业务层，dao层，spring可以配置各个层的组件，并且维护各个层的关系。

	Bean和Bean之间的合作关系既然不写在代码中，那这些信息保存在哪里？
		IoC是将Bean之间的依赖关系告诉容器，让容器统一管理。
		而这个告诉的方式一定不是以代码的形式（如果是这样，就不需要这个框架了）。
		所以可能的方式是：一个文件，一个外部资源，一个URI。 反正它一定存在于Java 运行时之外的。
		既然在内存之外，我们就需要将它以流的方式读入内存，然后对它做一定的封装，使我们可以读取这些内容的信息，然后处理。
	
	容器是什么：
		容器当然是一个全局对象。而我们能通过getBean方法从它手中获得一个Bean，它应该有个map保存这些beans。
		第一步从外部读取的信息，最终处理的结果就是存放到这个map里。

	两个设计主线：
		BeanFactory：
			只定义最简单的IoC容器的基本功能。如getBean。
		ApplicationContext：
			ApplicationContext 继承BeanFactory，也就是它也是IoC容器，只是它的功能更丰富：
				它同时继承 ResourcePatternResolver，MessageSource等接口，是高级容器。
				
	Spring 到底是怎么运行的：
		首先，我们定义一个 Bean 类，这个类用来存放一个 Bean 拥有的属性；
			一个Bean包括id,type,和Properties。 
		接下来 Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个 HashMap 中，
			HashMap 的 key 就是 Bean 的 Id ，HasMap 的 value 是这个 Bean，
			只有这样我们才能通过 context.getBean("animal") 这个方法获得 Animal 这个类。
			我们都知道 Spirng 可以注入基本类型，而且可以注入像 List，Map 这样的类型，
		其实依赖注入的思想也很简单，它是通过反射机制实现的，在实例化一个类时，
			它通过反射调用类中 set 方法将事先保存在 HashMap 中的类属性注入到类中。
		最后它将这个类的实例返回给我们，我们就可以用了。

	Spring启用注解(通常有两种方式)：
		1.在Spring配置文件中的<beans>标签中配置
			<context:annotation-config />
			通过这种配置方式可使整个项目中的Spring注解生效
		2.在<beans>标签里配置扫描的包名
			<context:component-scan base-package=”com.veegn”>
			这样可使指定包目录下的Spring注解生效



















		
Spring 核心原理

	1.IOC 控制反转

		概念：控制权由对象本身转向容器，由容器根据配置文件创建对象实例并实现各个对象的依赖关系。
		核心：bean工厂

		内部最核心的就是 IOC，动态注入，让一个对象的创建不用new了，可以自动的生产；
		这其实就是利用 java 里的反射，反射其实就是在运行时动态的去创建、调用对象，
		Spring 就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。  

	2.AOP 面向切面编程

		Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过  配置类达到的。  

		a. 静态代理

			就是通过接口继承复用的方式来完成的， 代理类与被代理对象实现相同的接口，
			然后代理类里面会拥有一个被代理对象，代理类与被代理对象相同的方法，活调用被代理对象的方法，
			不过中间会加以限制，您翻开任何一本设计模式相关的书，翻到代理模式这一节，讲的就是它了。

			根据每个具体类分别编写代理类
			根据一个接口编写一个代理类

		b. 动态代理

			动态代理就是允许我们在程序运行过程中，为动态生成的对象，动态的生成代理。显然，这比静态代理灵活太多了。
			Java默认提供了动态代理的实现方式，但是有限制，它要求被代理对象必须实现某一个接口。
			为了突破这一限制，为普通类也可以提供代理，CGLib这个库横空出世。
			CGLib：针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类
			动态代理：
				不用写代理类，虚拟机根据真实对象实现的接口产生一个类，
				通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，
				当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，
				将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。     
					 1、产生动态代理的类：
						java.lang.refect.Proxy
					 2、装备必须实现InvocationHandler接口实现invoke方法

		 

Spring 原理小结

	1. 使用spring ，没有new对象，我们把创建对象的任务交给spring框架
	2. spring 实际上是一个容器框架，可以配置各种 bean (action/service/domain/dao)，
		并且可以维护bean与bean的关系，当我们需要使用某个bean的时候，我们可以 getBean(id)，使用即可.

	Spring目的：
		让对象与对象（模块与模块）之间的关系没有通过代码来关联，
		都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）  

	Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。  
	Spring里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)， 
	Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring.

	


Spring 框架的架构
	Spring 框架是一个分层架构，由 7 个定义良好的模块组成。
		Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，
		组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。
	
	每个模块的功能如下：

		核心容器：
			核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。
			BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。

		Spring 上下文：
			Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。
			Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。

		Spring AOP：
			通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。
			所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。
			Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。
			通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。

		Spring DAO：
			JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。
			异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。
			Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。

		Spring ORM：
			Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。
			所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。

		Spring Web 模块：
			Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。
			所以，Spring 框架支持与 Jakarta Struts 的集成。
			Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。

		Spring MVC 框架：
			MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。
			通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

	
Spring七大模块

	1. Spring Core： Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。

	2.Spring Context: 构建于Core封装包基础上的 Context封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。

	3．Spring DAO:  DAO (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。

	4.Spring ORM: ORM 封装包提供了常用的“对象/关系”映射APIs的集成层。 其中包括JPA、JDO、Hibernate 和 iBatis 。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。

	5.Spring AOP: Spring的 AOP 封装包提供了符合AOP Alliance规范的面向方面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。

	6.Spring Web: Spring中的 Web 包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。

	7.Spring Web MVC: Spring中的MVC封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。



Spring 的核心接口及核类配置文件：
	FactoryBean：工厂bean主要实现ioc/di
	ApplicationContext ac=new FileXmlApplicationContext("applicationContext.xml");
	Object obj=ac.getBean("id值");

Spring 中设计模式分析
		Spring 中使用的设计模式也很多，比如工厂模式、单例模式、模版模式、代理模式、策略模式等。
	代理模式原理
		代理模式就是给某一个对象创建一个代理对象，而由这个代理对象控制对原对象的引用，
			而创建这个代理对象就是可以在调用原对象时增加一些额外的操作。
		代理模式的结构
			Subject：抽象主题，它是代理对象的真实对象要实现的接口，当然这可以由多个接口组成。
			ProxySubject：代理类除了实现抽象主题定义的接口外，还必须持有所代理对象的引用
			RealSubject：被代理的类，是目标对象。
		Spring 中如何实现代理模式
			Spring Aop 中 Jdk 动态代理就是利用代理模式技术实现的。
			在 Spring 中除了实现被代理对象的接口外，
			还会有 org.springframework.aop.SpringProxy 和 org.springframework.aop.framework.Advised 两个接口。
		Spring 中使用代理模式的结构：
			$Proxy 就是创建的代理对象，而 Subject 是抽象主题，代理对象是通过 InvocationHandler 来持有对目标对象的引用的。

	策略模式原理
		策略模式顾名思义就是做某事的策略，这在编程上通常是指完成某个操作可能有多种方法，
			这些方法各有千秋，可能有不同的适应的场合，然而这些操作方法都有可能用到。
			各一个操作方法都当作一个实现策略，使用者可能根据需要选择合适的策略。
		下面是策略模式的结构：
			Context：使用不同策略的环境，它可以根据自身的条件选择不同的策略实现类来完成所要的操作。
				它持有一个策略实例的引用。创建具体策略对象的方法也可以由他完成。
			Strategy：抽象策略，定义每个策略都要实现的策略方法
			ConcreteStrategy：具体策略实现类，实现抽象策略中定义的策略方法
		Spring 中策略模式的实现
			Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。
			这里主要看一下代理对象创建的策略模式的实现。
			前面已经了解 Spring 的代理方式有两个 Jdk 动态代理和 CGLIB 代理。
			这两个代理方式的使用正是使用了策略模式。

	
Spring IOC 原理

	IOC 总结
	
		Spring IOC 容器主要有继承体系底层的 BeanFactory、高层的 ApplicationContext 和 WebApplicationContext；

		Bean有自己的生命周期

		容器启动原理：
		
			Spring 应用的 IOC 容器通过 tomcat 的 Servlet 或 Listener 监听启动加载；
			Spring MVC 的容器由 DispatchServlet 作为入口加载；
			Spring 容器是 Spring MVC 容器的父容器

		容器加载Bean原理：

			BeanDefinitionReader 读取 Resource 所指向的配置文件资源，然后解析配置文件。
			配置文件中每一个解析成一个 BeanDefinition 对象，并保存到 BeanDefinitionRegistry 中；

			容器扫描 BeanDefinitionRegistry 中的 BeanDefinition；
			调用 InstantiationStrategy 进行 Bean 实例化的工作；
			使用 BeanWrapper 完成 Bean 属性的设置工作；

			单例Bean缓存池：
				Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，
				它是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。
			
			
	Spring 容器高层视图

		Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，
		然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。

	IOC容器介绍
		Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，
		利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。
		Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。
		BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；
		ApplicationContext 面向使用 Spring 框架的开发者，
		几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。

	BeanFactory
		BeanDefinitionRegistry：
		Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。
		而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。

		BeanFactory 接口位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，
		该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：

		ListableBeanFactory：
		该接口定义了访问容器中 Bean 基本信息的若干方法，
		如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；

		HierarchicalBeanFactory：
		父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 
		通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，
		子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。
		Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，
		展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。
		这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。

		ConfigurableBeanFactory：
		是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；

		AutowireCapableBeanFactory：
		定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；

		SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例 Bean 的方法；
		
		例子：
			使用 Spring 配置文件为 Car 提供配置信息：beans.xml：
			通过 BeanFactory 装载配置文件，启动 Spring IoC 容器：
			
			XmlBeanFactory 通过 Resource 装载 Spring 配置信息并启动 IoC 容器，
			然后就可以通过 BeanFactory#getBean(beanName)方法从 IoC 容器中获取 Bean 了。
			通过 BeanFactory 启动IoC 容器时，并不会初始化配置文件中定义的 Bean，初始化动作发生在第一个调用时。

			对于单实例（ singleton）的 Bean 来说，BeanFactory会缓存 Bean 实例，
			所以第二次使用 getBean() 获取 Bean 时将直接从 IoC 容器的缓存中获取 Bean 实例。
			Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，
			它是一个用HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个HashMap 中。

			值得一提的是，在初始化 BeanFactory 时，必须为其提供一种日志框架，
			比如使用Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。

	ApplicationContext
		ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。
		在BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。

		ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，
		在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：

			ClassPathXmlApplicationContext：默认从类路径加载配置文件

			FileSystemXmlApplicationContext：默认从文件系统中装载配置文件

			ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件 ， 并对事件进行响应处理 。 在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。

			MessageSource：为应用提供 i18n 国际化消息访问的功能；

			ResourcePatternResolver：所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。

			LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。

		ConfigurableApplicationContext 扩展于 ApplicationContext，
		它新增加了两个主要的方法：refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。
			在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，
			调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。
			这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。

		使用：
			如果配置文件放置在类路径下，用户可以优先使用 ClassPathXmlApplicationContext 实现类：

			如果配置文件放置在文件系统的路径下，则可以优先考虑使用 FileSystemXmlApplicationContext 实现类：

			Spring 3.0 支持基于类注解的配置方式，主要功能来自于 Spring 的一个名为 JavaConfig 子项目，
			目前 JavaConfig已经升级为 Spring核心框架的一部分。

			ApplicationContext 在初始化应用上下文时就实例化所有单实例的 Bean。

	WebApplicationContext

		WebApplication体系架构：

			WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。
			从WebApplicationContext 中可以获得 ServletContext 的引用，
			整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。
			WebApplicationContext 定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，
			在上下文启动时， WebApplicationContext 实例即以此为键放置在 ServletContext 的属性列表中，
			因此我们可以直接通过以下语句从 Web 容器中获取WebApplicationContext：

		Spring 和 Web 应用的上下文融合：

			WebApplicationContext 的初始化方式：WebApplicationContext 需要 ServletContext 实例，
			它必须在拥有 Web 容器的前提下才能完成启动的工作。
			可以在 web.xml 中配置自启动的 Servlet 或定义 Web 容器监听器（ ServletContextListener），
			借助这两者中的任何一个就可以完成启动 Spring Web 应用上下文的工作。
			Spring 分别提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器：
				org.springframework.web.context.ContextLoaderServlet；
				org.springframework.web.context.ContextLoaderListener。

			由于 WebApplicationContext 需要使用日志功能，比如日志框架使用Log4J，
			用	户可以将 Log4J 的配置文件放置到类路径 WEB-INF/classes 下，这时 Log4J 引擎即可顺利启动。
			如果 Log4J 配置文件放置在其他位置，用户还必须在 web.xml 指定 Log4J 配置文件位置。

	Bean 的生命周期
		1．当调用者通过 getBean(beanName)向容器请求某一个 Bean 时，
			如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 接口，
			在实例化 Bean 之前，将调用接口的 postProcessBeforeInstantiation()方法；

		2．根据配置情况调用 Bean 构造函数或工厂方法实例化 Bean；

		3．如果容器注册了 InstantiationAwareBeanPostProcessor 接口，在实例化 Bean 之后，
			调用该接口的 postProcessAfterInstantiation()方法，可在这里对已经实例化的对象进行一些“梳妆打扮”；

		4．如果 Bean 配置了属性信息，容器在这一步着手将配置值设置到 Bean 对应的属性中，
		不过在设置每个属性之前将先调用InstantiationAwareBeanPostProcessor 接口的postProcessPropertyValues()方法；

		5．调用 Bean 的属性设置方法设置属性值；

		6．如果 Bean 实现了 org.springframework.beans.factory.BeanNameAware 接口，
			将调用setBeanName()接口方法，将配置文件中该 Bean 对应的名称设置到 Bean 中；

		7．如果 Bean 实现了 org.springframework.beans.factory.BeanFactoryAware 接口，
			将调用 setBeanFactory()接口方法，将 BeanFactory 容器实例设置到 Bean 中；

		8．如果 BeanFactory 装配了 org.springframework.beans.factory.config.BeanPostProcessor后处理器，
			将调用 BeanPostProcessor 的 Object postProcessBeforeInitialization(Object bean, String beanName)接口方法对 Bean 进行加工操作。
			其中入参 bean 是当前正在处理的 Bean，而 beanName 是当前 Bean 的配置名，返回的对象为加工处理后的 Bean。
			用户可以使用该方法对某些 Bean 进行特殊的处理，甚至改变 Bean 的行为， 
			BeanPostProcessor 在 Spring 框架中占有重要的地位，为容器提供对 Bean 进行后续加工处理的切入点， 
			Spring 容器所提供的各种“神奇功能”（如 AOP，动态代理等）都通过 BeanPostProcessor 实施；

		9．如果 Bean 实现了 InitializingBean 的接口，将调用接口的 afterPropertiesSet()方法；

		10．如果在通过 init-method 属性定义了初始化方法，将执行这个方法；

		11．BeanPostProcessor 后处理器定义了两个方法：
			其一是 postProcessBeforeInitialization() 在第 8 步调用；
			其二是 Object postProcessAfterInitialization(Object bean, String beanName)方法，
			这个方法在此时调用，容器再次获得对 Bean 进行加工处理的机会；

		12．如果在中指定 Bean 的作用范围为 scope=“prototype”，将 Bean 返回给调用者，
			调用者负责 Bean 后续生命的管理， Spring 不再管理这个 Bean 的生命周期。
			如果作用范围设置为 scope=“singleton”，则将 Bean 放入到 Spring IoC 容器的缓存池中，
			并将 Bean引用返回给调用者， Spring 继续对这些 Bean 进行后续的生命管理；

		13．对于 scope=“singleton”的 Bean，当容器关闭时，将触发 Spring 对 Bean 的后续生命周期的管理工作，
			首先如果 Bean 实现了 DisposableBean 接口，则将调用接口的afterPropertiesSet()方法，
			可以在此编写释放资源、记录日志等操作；

		14．对于 scope=“singleton”的 Bean，如果通过的 destroy-method 属性指定了 Bean 的销毁方法， 
			Spring 将执行 Bean 的这个方法，完成 Bean 资源的释放等操作。

	可以将这些方法大致划分为三类：

		Bean 自身的方法：
			如调用 Bean 构造函数实例化 Bean，
			调用 Setter 设置 Bean 的属性值以及通过的 init-method 和 destroy-method 所指定的方法；

		Bean 级生命周期接口方法：
			如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，
			这些接口方法由 Bean 类直接实现；

		容器级生命周期接口方法：
			在上图中带“★” 的步骤是由 InstantiationAwareBean PostProcessor 和BeanPostProcessor 这两个接口实现，
			一般称它们的实现类为“ 后处理器” 。 
			后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，
			实现类以容器附加装置的形式注册到 Spring 容器中并通过接口反射为 Spring 容器预先识别。
			当Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。
			当然，用户可以通过合理地编写后处理器，让其仅对感兴趣Bean 进行加工处理

	ApplicationContext 和 BeanFactory 另一个最大的不同之处在于：
		ApplicationContext会利用 Java 反射机制自动识别出配置文件中定义的 BeanPostProcessor、 InstantiationAwareBeanPostProcessor 和 BeanFactoryPostProcessor，并自动将它们注册到应用上下文中；
		而后者需要在代码中通过手工调用 addBeanPostProcessor()方法进行注册。
		这也是为什么在应用开发时，我们普遍使用 ApplicationContext 而很少使用 BeanFactory 的原因之一。


IOC 容器工作机制

	容器启动过程

	web环境下Spring容器、SpringMVC容器启动过程：

		首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，
		这个上下文就是ServletContext，为后面的spring IoC容器提供宿主环境；

		其次，在web.xml中会提供有contextLoaderListener（或ContextLoaderServlet）。
		在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，
		其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，
		这个上下文被称为根上下文，即WebApplicationContext，
		这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。
		这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。
		在这个IoC容器初始化完毕后，
		spring容器以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，
		将其存储到ServletContext中，便于获取；

		再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，
		这个servlet可以配置多个，以最常见的DispatcherServlet为例（Spring MVC），
		这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。
		DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文容器，用以持有spring mvc相关的bean，
		这个servlet自己持有的上下文默认实现类也是XmlWebApplicationContext。
		在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文（即第2步中初始化的XmlWebApplicationContext作为自己的父容器）。
		有了这个parent上下文之后，再初始化自己持有的上下文（这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等）。
		初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换)的属性为属性Key，也将其存到ServletContext中，以便后续使用。
		这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文定义的那些bean。


	Bean加载过程

		Spring的高明之处在于，它使用众多接口描绘出了所有装置的蓝图，构建好Spring的骨架，
		继而通过继承体系层层推演，不断丰富，最终让Spring成为有血有肉的完整的框架。
		所以查看Spring框架的源码时，有两条清晰可见的脉络：

			1）接口层描述了容器的重要组件及组件间的协作关系；
			2）继承体系逐步实现组件的各项功能。

		接口层清晰地勾勒出Spring框架的高层功能，框架脉络呼之欲出。
		有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同实现， 可以说Spring完善的接口层使框架的扩展性得到了很好的保证。
		纵向继承体系的逐步扩展，分步骤地实现框架的功能，
		这种实现方案保证了框架功能不会堆积在某些类的身上，造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。

		Spring组件按其所承担的角色可以划分为两类：

			1）物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，
			它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料；

				BeanDefinition：Spring通过BeanDefinition将配置文件中的配置信息转换为容器的内部表示，
				并将这些BeanDefinition注册到BeanDefinitionRegistry中。
				Spring容器的后续操作直接从BeanDefinitionRegistry中读取配置信息。
			2）加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件进行加工处理。

				InstantiationStrategy：
				负责实例化Bean操作，相当于Java语言中new的功能，并不会参与Bean属性的配置工作。
				属性填充工作留待BeanWrapper完成

				BeanWrapper：继承了PropertyAccessor和PropertyEditorRegistry接口，
				BeanWrapperImpl内部封装了两类组件：（1）被封装的目标Bean（2）一套用于设置Bean属性的属性编辑器；
				具有三重身份：（1）Bean包裹器（2）属性访问器 （3）属性编辑器注册表。
				PropertyAccessor：定义了各种访问Bean属性的方法。
				PropertyEditorRegistry：属性编辑器的注册表

		Spring 容器从加载配置文件到创建出一个完整Bean的作业流程：

			１、ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件的资源；

			２、BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。
			配置文件中每一个解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；

			３、容器扫描BeanDefinitionRegistry中的BeanDefinition，
			使用Java的反射机制自动识别出Bean工厂后处理后器（实现BeanFactoryPostProcessor接口）的Bean，
			然后调用这些Bean工厂后处理器对BeanDefinitionRegistry中的BeanDefinition进行加工处理。

				主要完成以下两项工作：

					1）对使用到占位符的元素标签进行解析，得到最终的配置值，
					这意味对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象；

					2）对BeanDefinitionRegistry中的BeanDefinition进行扫描，
					通过Java反射机制找出所有属性编辑器的Bean（实现java.beans.PropertyEditor接口的Bean），
					并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）；

			4．Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，
			并调用InstantiationStrategy着手进行Bean实例化的工作；

			5．在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，
			BeanWrapper提供了很多以Java反射机制操作Bean的方法，
			它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作；

			6．利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，
			直接装配出一个准备就绪的Bean。




