
Spring 体系


Spring 体系 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		
	怎么使用：




Spring常用注解

	Spring
	
		@Autowired：
			默认按类型装配，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，
			如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：
				@Autowired @Qualifier("personDaoBean") 存在多个实例配合使用

		@Resource：
			它的作用相当于 @Autowired，只不过 @Autowired 按 byType 自动注入，
			@Resource 默认按 byName 自动注入，当找不到与名称匹配的bean才会按类型装配

		@Controller：用于标注控制层组件。

		@Service：用于标注业务层组件。

		@Repository：标注一个DAO组件类。

		@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

	SpringMVC
	
		@RequestMapping：
			请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；
			最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。

		@PathVariable：用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。

		@RequestParam：主要用于在SpringMVC后台控制层获取参数。

		@ModelAttribute：
			可以应用在方法参数上或方法上，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；
			当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会首先调用该方法。

		@ResponseBody：
			该注解用于将Controller的方法返回的对象，
			通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。

		@RequestBody：该注解用于读取Request请求的body部分数据，
			使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上，
			再把HttpMessageConverter返回的对象数据绑定到controller中方法的参数上。

	SpringBoot
	
		@RestController：@ResponseBody和@Controller的合集。

		@EnableAutoConfiguration：尝试根据你添加的jar依赖自动配置你的Spring应用。

		@ComponentScan：表示将该类自动发现（扫描）并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。

		@ImportResource：用来加载xml配置文件。

		@Configuration：
			相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，
			建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。

		@SpringBootApplication：相当于@EnableAutoConfiguration、@ComponentScan和@Configuration的合集。

	Lombok
	
		@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，
			此外还提供了equals、canEqual、hashCode、toString 方法（需要安装lombok 安装）。


	
Spring 常用注解
	
	@Controller：
		注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写
		
	@Service：
		注释表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean，
		例如Chinese实例化为chinese，American实例化为american，如果需要自己改名字则：@Service(“你自己改的bean名”)。 
		
	@Repository：
		用于注解dao层，在daoImpl类上面注解。与@Controller 、@Service 类似，都是向spring 上下文中注册bean。
	
	@Autowired：
		根据bean 类型从spring 上下文中进行查找，注册类型必须唯一，否则报异常。 
		与@Resource 的区别：
			@Resource 允许通过bean 名称或bean 类型两种方式进行查找。 
			@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();

		@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。

		@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
	
	@Resource：
		或者：@Resource(name=”dataSource”) ；@Resource(type=DataSource.class)
		@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， 
		此时与@Autowired 类似 
		在没有为 @Resource 注解显式指定 name 属性的前提下，
		如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，
		那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
		此时 name 属性不需要指定 ( 或者指定为”“)，否则注入失败； 
	
	@Qualifier：
		使用@Autowired 时，如果找到多个同一类型的bean，则会抛异常，
		此时可以使用 @Qualifier(“beanName”)，明确指定bean的名称进行注入，此时与 @Resource指定name属性作用相同。
		例如：
			@Autowired
			@Qualifier("softService")
			private ISoftPMService softPMService;
	
	@Scope 
		在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，同样可以通过@Scope 注解来完成。
		@Scope 中可以指定如下值：
			singleton：定义bean的范围为每个spring容器一个实例（默认值） 
			prototype：定义bean可以被多次实例化（使用一次就创建一次） 
			request：定义bean的范围是http请求（springMVC中有效） 
			session：定义bean的范围是http会话（springMVC中有效） 
			global-session：定义bean的范围是全局http会话（portlet中有效）
	
	@Component （不推荐使用） 
		@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：
			@repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。 
		目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@repository 、@Service 、@Controller 来替代@Component 。
	
	@RequestMapping：
		可以声明到类或方法上；
		RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。
		用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
		RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应实例）
		value,method;
			value: 指定请求的实际地址，指定的地址可以是URI Template模式；
			method:指定请求的method类型，GET、POST、PUT、DELETE等；
		consumes,produces
			consumes:指定处理请求的提交内容类型（Content-Type），例如application/json,text/html;
			produces:指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回；
		params，headers
			params:指定request中必须包含某些参数值，才让该方法处理。
			headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。
		参数绑定说明 
			如果我们使用以下的 URL 请求：
			http：//localhost/bbtForum.do?method=listBoardTopic&topicId=1&userId=10&userName=tom 
			topicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。
			和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，
			但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。
			如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。
	
	@RequestParam：
		主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter("name")，
		它有三个常用参数：defaultValue = "0", required = false, value = "isApp"；
		defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。
		参数绑定说明
		@RequestParam("id")
		http：//localhost/bbtForum.do?method=listBoardTopic&id=1&userId=10&userName=tom
		listBoardTopic(@RequestParam("id")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的
		@RequestParam(required=false)：参数不是必须的，默认为true ；
		@RequestParam(value=”id”,required=false)
	
	@ResponseBody：
		用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
		使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用。
	
	@ModelAttribute：
		@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里”queryBean”，
		并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到 model 里。
		该Controller的所有方法在调用前，先执行此@ModelAttribute方法，
		可用于注解和方法参数中，可以把这个 @ModelAttribute 特性，应用在BaseController当中，
		所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。
	
	@SessionAttributes：
		将值放到session作用域中，写在class上面。
		Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中， 
		以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。 
		这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。 
		@SessionAttributes 只能声明在类上，而不能声明在方法上。 
		
	@PathVariable：
		用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。
		
	@Cacheable：
		声明一个方法的返回值应该被缓存；
		例如：@Cacheable(modelId = “testCaching”)

	@CacheFlush：
		声明一个方法是清空缓存的触发器；
		例如：@CacheFlush(modelId = “testCaching”)
	
	@PostConstruct：
		在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行 
		（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。

	@PreDestroy：
		在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。

	
	@InitBinder：
		如果希望某个属性编辑器仅作用于特定的 Controller ， 
		可以在 Controller 中定义一个标注 @InitBinder 注解的方法， 
		可以在该方法中向 Controller 了注册若干个属性编辑器
	
	@Required：
		@Required 负责检查一个bean在初始化时其声明的 set 方法是否被执行，
		当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。
		@Required 注解只能标注在 Setter 方法之上。
		因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。
		如果将该注解标注在非 setXxxx() 类型的方法则被忽略。
	
	
	 一、声明实体
		@Entity
			对实体注释。任何Hibernate映射对象都要有这个注释
		@Table
			声明此对象映射到数据库的数据表，通过它可以为实体指定表(talbe),目录(Catalog)和schema的名字。
			该注释不是必须的，如果没有则系统使用默认值(实体的短类名)。
		 @Version
			该注释可用于在实体Bean中添加乐观锁支持。
	
	二、声明主键
		@Id
		   声明此属性为主键。该属性值可以通过应该自身创建，但是Hibernate推荐通过Hibernate生成
		@GeneratedValue
			指定主键的生成策略。有如下四个值
		       TABLE：使用表保存id值
		       IDENTITY：identitycolumn
		       SEQUENCR ：sequence
		       AUTO：根据数据库的不同使用上面三个
		
	三、声明普通属性
		@Column
			声明该属性与数据库字段的映射关系。
			注意：
				1、当POJO有属性不需要映射的时候一定要用@Transitent修饰，该注释表示此属性与表没有映射关系，只是一个暂时的属性。
			2、@Lob注释表示该属性持久化为Blob或者Clob类型，具体取决于属性的类型。
	
	四、声明关联关系
		一对多关联关系
			一对多声明
				@OneToMany(mappedBy=” person”,cascade=CascadeType.ALL,fetch=FetchType.LAZY)
			多对一声明 ,声明为双向关联
				@ManyToOne(cascade=CascadeType.REFRESH,)
				@JoinColumn
		
		一对一关联关系
			一对一关联声明
				@OneToOne(optional= true,cascade =CascadeType.ALL, mappedBy = “person”)
			声明为双向关联
				@OneToOne(optional = false, cascade = CascadeType.REFRESH)
				@JoinColumn(name = “Person_ID”, referencedColumnName = “personid”,unique = true)
		
		多对多关联关系
			多对多关联声明。
				@ManyToMany(mappedBy= “students”)
				@ManyToMany(cascade = CascadeType.PERSIST, fetch = FetchType.LAZY)
				@JoinTable(name = “Teacher_Student”,
	
	
Spring常用注解
	
	@Controller：用于标注控制层组件（如struts中的action）；
	@Service：用于标注业务层组件；
	@Repository：用于标注数据访问组件，即DAO组件；
	@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；
	@Autowired：注释使得接口可以被容器注入；
	
	@Value(“${ShortURLAPIAddress}”)：读取.properties文件：
	@JSONField(format = “yyyy-MM-dd hh：mm：ss”)：FastJson时间格式化：

	单元测试加载Spring配置：
		@RunWith(SpringJUnit4ClassRunner.class) 
		@ContextConfiguration(locations = “classpath：spring/spring-context.xml”) 
		@WebAppConfiguration
	



Spring 常用注解总结

	传统的Spring做法是使用.xml文件来对bean进行注入或者是配置aop、事物，这么做有两个缺点：
		1、如果所有的内容都配置在.xml文件中，那么.xml文件将会十分庞大；
			如果按需求分开.xml文件，那么.xml文件又会非常多。总之这将导致配置文件的可读性与可维护性变得很低。
		2、在开发中在.java文件和.xml文件之间不断切换，是一件麻烦的事，同时这种思维上的不连贯也会降低开发的效率。
			为了解决这两个问题，Spring引入了注解，通过"@XXX"的方式，让注解与Java Bean紧密结合，
			既大大减少了配置文件的体积，又增加了Java Bean的可读性与内聚性。

	1、@Autowired

		@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。
		当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。

		@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。
			<context：component-scan base-package="com.spring" />
			<bean id="zoo" class="com.spring.model.Zoo" />
			<bean id="tiger" class="com.spring.model.Tiger" />
			<bean id="monkey" class="com.spring.model.Monkey" />

		@Autowired注解：
			当Spring发现@Autowired注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。

		假如bean里面有两个property，Zoo.java里面又去掉了属性的getter/setter并使用@Autowired注解标注这两个属性那会怎么样？
		答案是Spring会按照xml优先的原则去Zoo.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错。 

		@Autowired注解要去寻找的是一个Bean，Tiger和Monkey的Bean定义都给去掉了，自然就不是一个Bean了，Spring容器找不到。
		那么，如果属性找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？可以的，
		其实异常信息里面也给出了提示了，就是将@Autowired注解的required属性设置为false即可；
		此时，找不到tiger、monkey两个属性，Spring容器不再抛出异常而是认为这两个属性为null。

	2、Qualifier（指定注入Bean的名称）

		如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称
			<context：component-scan base-package="com.spring" />
			<!-- Autowired注解配合Qualifier注解 -->
			<bean id="carFactory" class="com.spring.model.CarFactory" />
			<bean id="bmwCar" class="com.spring.service.impl.BMWCar" />
			<bean id="benz" class="com.spring.service.impl.BenzCar" />

		不用@Qualifier注解两种解决办法：
			(1)、在配置文件中删除其中一个实现类，Spring会自动去base-package下寻找Car接口的实现类，
				发现Car接口只有一个实现类，便会直接引用这个实现类。
			(2)、实现类就是有多个该怎么办？此时可以使用@Qualifier注解来指定Bean的名称：

	3、Resource

		@Resource注解与@Autowired注解作用非常相似

		@Resource的装配顺序：
			(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
			(2)、指定了name或者type则根据指定的类型去匹配bean
			(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错

		@Autowired和@Resource两个注解的区别：
			(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
			(2)、@Autowired是Spring的注解，@Resource是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了

		Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。

	4、Service
	
		上面这个例子，还可以继续简化，因为spring的配置文件里面还有15行~17行三个bean，下一步的简化是把这三个bean也给去掉，
		使得spring配置文件里面只有一个自动扫描的标签，增强Java代码的内聚性并进一步减少配置文件。

		要继续简化，可以使用@Service。

		这样，Zoo.java在Spring容器中存在的形式就是"zoo"，即可以通过ApplicationContext的getBean("zoo")方法来得到Zoo.java。
		@Service注解，其实做了两件事情：
			(1)、声明Zoo.java是一个bean，这点很重要，
				因为Zoo.java是一个bean，其他的类才可以使用@Autowired将Zoo作为一个成员变量自动注入。
			(2)、Zoo.java在bean中的id是"zoo"，即类名且首字母小写。

		@Service("Zoo")
		@Scope("prototype")
		可以通过ApplicationContext的getBean("Zoo")方法来得到Zoo.java了。

		这里我还多加了一个@Scope注解，应该很好理解。
		因为Spring默认产生的bean是单例的，假如我不想使用单例怎么办，xml文件里面可以在bean里面配置scope属性。
		注解也是一样，配置@Scope即可，默认是"singleton"即单例，"prototype"表示原型即每次都会new一个新的出来。


使用注解来构造IoC容器

	用注解来向Spring容器注册Bean。
		<context：component-scan base-package="cn.gacl.java"/>
	表明 cn.gacl.java包及其子包中，如果某个类的头上带有特定的注解【@Component/@Repository/@Service/@Controller】，
	就会将这个对象作为Bean注册进Spring容器。
	也可以在<context：component-scan base-package=” ”/>中指定多个包，多个包逗号隔开。
	<context：component-scan base-package="cn.gacl.dao.impl,cn.gacl.service.impl,cn.gacl.action"/>

	1、@Component
		@Component是所有受Spring 管理组件的通用形式，@Component 注解可以放在类的头上，@Component 不推荐使用。

	2、@Controller
		@Controller 对应表现层的Bean，也就是Action，

		使用@Controller注解标识UserAction之后，就表示要把UserAction交给Spring容器管理，
		在Spring容器中会存在一个名字为"userAction"的action，这个名字是根据UserAction类名来取的。
		注意：如果@Controller不指定其value【@Controller】，则默认的bean名字为这个类的类名首字母小写，
		如果指定value【@Controller(value="UserAction")】或者【@Controller("UserAction")】，则使用value作为bean的名字。

		这里的UserAction还使用了@Scope注解，@Scope("prototype")表示将Action的范围声明为原型，可以利用容器的scope="prototype"来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring 默认scope 是单例模式(scope="singleton")，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope="prototype" 可以保证当有请求的时候都创建一个Action对象。

	3、@Service
		@Service 对应的是业务层Bean

		 @Service("userService")注解是告诉Spring，当Spring要创建UserServiceImpl的的实例时，bean的名字必须叫做"userService"，
		 这样当Action需要使用UserServiceImpl的的实例时,就可以由Spring创建好的"userService"，
		 然后注入给Action：在Action只需要声明一个名字叫"userService"的变量来接收由Spring注入的"userService"即可，

		注意：在Action声明的"userService"变量的类型必须是"UserServiceImpl"或者是其父类"UserService"，
		否则由于类型不一致而无法注入，由于Action中的声明的"userService"变量使用了@Resource注解去标注，
		并且指明了其name = "userService"，这就等于告诉Spring，说我Action要实例化一个"userService"，你Spring快点帮我实例化好，然后给我，
		当Spring看到userService变量上的@Resource的注解时，根据其指明的name属性可以知道，
		Action中需要用到一个UserServiceImpl的实例，
		此时Spring就会把自己创建好的名字叫做"userService"的UserServiceImpl的实例注入给Action中的"userService"变量，
		帮助Action完成userService的实例化，
		这样在Action中就不用通过"UserService userService = new UserServiceImpl();"这种最原始的方式去实例化userService了。
		如果没有Spring，那么当Action需要使用UserServiceImpl时，必须通过"UserService userService = new UserServiceImpl();"主动去创建实例对象，
		但使用了Spring之后，Action要使用UserServiceImpl时，就不用主动去创建UserServiceImpl的实例了，
		创建UserServiceImpl实例已经交给Spring来做了，Spring把创建好的UserServiceImpl实例给Action，Action拿到就可以直接用了。
		Action由原来的主动创建UserServiceImpl实例后就可以马上使用，
		变成了被动等待由Spring创建好UserServiceImpl实例之后再注入给Action，Action才能够使用。
		这说明Action对"UserServiceImpl"类的“控制权”已经被“反转”了，原来主动权在自己手上，自己要使用"UserServiceImpl"类的实例，自己主动去new一个出来马上就可以使用了，
		但现在自己不能主动去new "UserServiceImpl"类的实例，new "UserServiceImpl"类的实例的权力已经被Spring拿走了，
		只有Spring才能够new "UserServiceImpl"类的实例，而Action只能等Spring创建好"UserServiceImpl"类的实例后，
		再“恳求”Spring把创建好的"UserServiceImpl"类的实例给他，这样他才能够使用"UserServiceImpl"，
		这就是Spring核心思想“控制反转”，也叫“依赖注入”，
		“依赖注入”也很好理解，Action需要使用UserServiceImpl干活，那么就是对UserServiceImpl产生了依赖，
		Spring把Acion需要依赖的UserServiceImpl注入(也就是“给”)给Action，这就是所谓的“依赖注入”。
		对Action而言，Action依赖什么东西，就请求Spring注入给他，对Spring而言，Action需要什么，Spring就主动注入给他。

	4、@ Repository
		@Repository 对应数据访问层Bean

		@Repository(value="userDao")注解是告诉Spring，让Spring创建一个名字叫"userDao"的UserDaoImpl实例。

		当Service需要使用Spring创建的名字叫"userDao"的UserDaoImpl实例时，
		就可以使用@Resource(name = "userDao")注解告诉Spring，Spring把创建好的userDao注入给Service即可。


	Spring常用注解汇总 
		本文汇总了Spring的常用注解，以方便大家查询和使用，具体如下：
			使用注解之前要开启自动扫描功能，其中base-package为需要扫描的包(含子包)。
				<context：component-scan base-package="cn.test"/> 
		@Configuration：把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。
		@Scope：注解 作用域
		@Lazy(true)：表示延迟初始化
		@Controller：用于标注控制层组件（如struts中的action）
		@Service：用于标注业务层组件
		@Repository：用于标注数据访问组件，即DAO组件。
		@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
		@Scope：用于指定scope作用域的（用在类上）
		@PostConstruct：用于指定初始化方法（用在方法上）
		@PreDestory：用于指定销毁方法（用在方法上）
		@DependsOn：定义Bean初始化及销毁时的顺序
		@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常
		
		@Autowired：默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：
		@Autowired @Qualifier("personDaoBean")：存在多个实例配合使用
		@Resource：默认按名称装配，当找不到与名称匹配的bean才会按类型装配。
		@PostConstruct：初始化注解
		@PreDestroy：摧毁注解 默认 单例  启动就加载
		@Async：异步方法调用








