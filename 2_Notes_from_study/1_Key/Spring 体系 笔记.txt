
Spring 体系


Spring 体系 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		
	怎么使用：




Spring 常用注解

	Spring
	
		@Autowired：
			默认按类型装配，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，
			如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。如下：
				@Autowired @Qualifier("personDaoBean") 存在多个实例配合使用

		@Resource：
			它的作用相当于 @Autowired，只不过 @Autowired 按 byType 自动注入，
			@Resource 默认按 byName 自动注入，当找不到与名称匹配的 bean 才会按类型装配

		@Controller：用于标注控制层组件。

		@Service：用于标注业务层组件。

		@Repository：标注一个 DAO 组件类。

		@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

	SpringMVC
	
		@RequestMapping：
			请求路径映射，如果标注在某个 controller 的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；
			最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。

		@PathVariable：用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 uri 模板中的变量作为参数。

		@RequestParam：主要用于在 SpringMVC 后台控制层获取参数。

		@ModelAttribute：
			可以应用在方法参数上或方法上，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到 Model 中；
			当注解在请求处理方法 Action 上时会将该方法变成一个非请求处理的方法，但其它 Action 被调用时会首先调用该方法。

		@ResponseBody：
			该注解用于将 Controller 的方法返回的对象，
			通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区。

		@RequestBody：该注解用于读取 Request 请求的 body 部分数据，
			使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上，
			再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。

	SpringBoot
	
		@RestController：@ResponseBody 和 @Controller 的合集。

		@EnableAutoConfiguration：尝试根据你添加的 jar 依赖自动配置你的 Spring 应用。

		@ComponentScan：表示将该类自动发现 (扫描) 并注册为 Bean，可以自动收集所有的 Spring 组件，包括 @Configuration 类。

		@ImportResource：用来加载 xml 配置文件。

		@Configuration：
			相当于传统的 xml 配置文件，如果有些第三方库需要用到 xml 文件，
			建议仍然通过 @Configuration 类作为项目的配置主类——可以使用 @ImportResource 注解加载 xml 配置文件。

		@SpringBootApplication：相当于 @EnableAutoConfiguration、@ComponentScan 和 @Configuration 的合集。

	Lombok
	
		@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，
			此外还提供了 equals、canEqual、hashCode、toString 方法 (需要安装 lombok 安装) 。


	
Spring 常用注解
	
	@Controller：
		注册一个 bean 到 spring 上下文中，bean 的 ID 默认为类名称开头字母小写
		
	@Service：
		注释表示定义一个 bean，自动根据 bean 的类名实例化一个首写字母为小写的 bean，
		例如 Chinese 实例化为 chinese，American 实例化为 american，如果需要自己改名字则：@Service(“你自己改的 bean 名”)。
		
	@Repository：
		用于注解 dao 层，在 daoImpl 类上面注解。与 @Controller 、@Service 类似，都是向 spring 上下文中注册 bean。
	
	@Autowired：
		根据 bean 类型从 spring 上下文中进行查找，注册类型必须唯一，否则报异常。
		与 @Resource 的区别：
			@Resource 允许通过 bean 名称或 bean 类型两种方式进行查找。
			@Autowired(required=false) 表示，如果 spring 上下文中没有找到该类型的 bean 时，才会使用 new SoftPMServiceImpl();

		@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。

		@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
	
	@Resource：
		或者：@Resource(name=”dataSource”) ；@Resource(type=DataSource.class)
		@Resource 默认按 bean 的 name 进行查找，如果没有找到会按 type 进行查找，
		此时与 @Autowired 类似 
		在没有为 @Resource 注解显式指定 name 属性的前提下，
		如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，
		那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
		此时 name 属性不需要指定 ( 或者指定为”“)，否则注入失败； 
	
	@Qualifier：
		使用 @Autowired 时，如果找到多个同一类型的 bean，则会抛异常，
		此时可以使用 @Qualifier(“beanName”)，明确指定 bean 的名称进行注入，此时与 @Resource 指定 name 属性作用相同。
		例如：
			@Autowired
			@Qualifier("softService")
			private ISoftPMService softPMService;
	
	@Scope 
		在使用 XML 定义 Bean 时，可以通过 bean 的 scope 属性来定义一个 Bean 的作用范围，同样可以通过 @Scope 注解来完成。
		@Scope 中可以指定如下值：
			singleton：定义 bean 的范围为每个 spring 容器一个实例 (默认值) 
			prototype：定义 bean 可以被多次实例化 (使用一次就创建一次) 
			request：定义 bean 的范围是 http 请求 (springMVC 中有效) 
			session：定义 bean 的范围是 http 会话 (springMVC 中有效) 
			global-session：定义 bean 的范围是全局 http 会话 (portlet 中有效) 
	
	@Component (不推荐使用) 
		@Component 是所有受 Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：
			@repository 、@Service 、@Controller，它们分别对应存储层 Bean，业务层 Bean，和展示层 Bean。
		目前版本 (2.5) 中，这些注解与 @Component 的语义是一样的，完全通用，在 Spring 以后的版本中可能会给它们追加更多的语义。所以，我们推荐使用 @repository 、@Service 、@Controller 来替代 @Component。
	
	@RequestMapping：
		可以声明到类或方法上；
		RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。
		用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
		RequestMapping 注解有六个属性，下面我们把她分成三类进行说明 (下面有相应实例) 
		value,method;
			value: 指定请求的实际地址，指定的地址可以是 URI Template 模式；
			method:指定请求的 method 类型，GET、POST、PUT、DELETE 等；
		consumes,produces
			consumes:指定处理请求的提交内容类型 (Content-Type) ，例如 application/json,text/html;
			produces:指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回；
		params，headers
			params:指定 request 中必须包含某些参数值，才让该方法处理。
			headers:指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。
		参数绑定说明 
			如果我们使用以下的 URL 请求：
			http：//localhost/bbtForum.do?method=listBoardTopic&topicId=1&userId=10&userName=tom 
			topicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。
			和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，
			但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0。
			如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。
	
	@RequestParam：
		主要用于在 SpringMVC 后台控制层获取参数，类似一种是 request.getParameter("name")，
		它有三个常用参数：defaultValue = "0", required = false, value = "isApp"；
		defaultValue 表示设置默认值，required 铜过 boolean 设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。
		参数绑定说明
		@RequestParam("id")
		http：//localhost/bbtForum.do?method=listBoardTopic&id=1&userId=10&userName=tom
		listBoardTopic(@RequestParam("id")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数，那么可以通过对入参使用 @RequestParam 注解来达到目的
		@RequestParam(required=false)：参数不是必须的，默认为 true ；
		@RequestParam(value=”id”,required=false)
	
	@ResponseBody：
		用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区。
		使用时机：返回的数据不是 html 标签的页面，而是其他某种格式的数据时 (如 json、xml 等) 使用。
	
	@ModelAttribute：
		@ModelAttribute 声明在属性上，表示该属性的 value 来源于 model 里”queryBean”，
		并被保存到 model 里 @ModelAttribute 声明在方法上，表示该方法的返回值被保存到 model 里。
		该 Controller 的所有方法在调用前，先执行此 @ModelAttribute 方法，
		可用于注解和方法参数中，可以把这个 @ModelAttribute 特性，应用在 BaseController 当中，
		所有的 Controller 继承 BaseController，即可实现在调用 Controller 时，先执行 @ModelAttribute 方法。
	
	@SessionAttributes：
		将值放到 session 作用域中，写在 class 上面。
		Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，
		以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。
		这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。
		@SessionAttributes 只能声明在类上，而不能声明在方法上。
		
	@PathVariable：
		用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 uri 模板中的变量作为参数。
		
	@Cacheable：
		声明一个方法的返回值应该被缓存；
		例如：@Cacheable(modelId =“testCaching”)

	@CacheFlush：
		声明一个方法是清空缓存的触发器；
		例如：@CacheFlush(modelId =“testCaching”)
	
	@PostConstruct：
		在方法上加上注解 @PostConstruct，这个方法就会在 Bean 初始化之后被 Spring 容器执 行 
		 (注：Bean 初始化包括，实例化 Bean，并装配 Bean 的属性 (依赖注入) ) 。

	@PreDestroy：
		在方法上加上注解 @PreDestroy，这个方法就会在 Bean 被销毁前被 Spring 容器执行。

	
	@InitBinder：
		如果希望某个属性编辑器仅作用于特定的 Controller，
		可以在 Controller 中定义一个标注 @InitBinder 注解的方法，
		可以在该方法中向 Controller 了注册若干个属性编辑器
	
	@Required：
		@Required 负责检查一个 bean 在初始化时其声明的 set 方法是否被执行，
		当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。
		@Required 注解只能标注在 Setter 方法之上。
		因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。
		如果将该注解标注在非 setXxxx() 类型的方法则被忽略。
	
	
	 一、声明实体
		@Entity
			对实体注释。任何 Hibernate 映射对象都要有这个注释
		@Table
			声明此对象映射到数据库的数据表，通过它可以为实体指定表 (talbe), 目录 (Catalog) 和 schema 的名字。
			该注释不是必须的，如果没有则系统使用默认值 (实体的短类名)。
		 @Version
			该注释可用于在实体 Bean 中添加乐观锁支持。
	
	二、声明主键
		@Id
		 声明此属性为主键。该属性值可以通过应该自身创建，但是 Hibernate 推荐通过 Hibernate 生成
		@GeneratedValue
			指定主键的生成策略。有如下四个值
		 TABLE：使用表保存 id 值
		 IDENTITY：identitycolumn
		 SEQUENCR ：sequence
		 AUTO：根据数据库的不同使用上面三个
		
	三、声明普通属性
		@Column
			声明该属性与数据库字段的映射关系。
			注意：
				1、当 POJO 有属性不需要映射的时候一定要用 @Transitent 修饰，该注释表示此属性与表没有映射关系，只是一个暂时的属性。
			2、@Lob 注释表示该属性持久化为 Blob 或者 Clob 类型，具体取决于属性的类型。
	
	四、声明关联关系
		一对多关联关系
			一对多声明
				@OneToMany(mappedBy=”person”,cascade=CascadeType.ALL,fetch=FetchType.LAZY)
			多对一声明 , 声明为双向关联
				@ManyToOne(cascade=CascadeType.REFRESH,)
				@JoinColumn
		
		一对一关联关系
			一对一关联声明
				@OneToOne(optional= true,cascade =CascadeType.ALL, mappedBy =“person”)
			声明为双向关联
				@OneToOne(optional = false, cascade = CascadeType.REFRESH)
				@JoinColumn(name =“Person_ID”, referencedColumnName =“personid”,unique = true)
		
		多对多关联关系
			多对多关联声明。
				@ManyToMany(mappedBy=“students”)
				@ManyToMany(cascade = CascadeType.PERSIST, fetch = FetchType.LAZY)
				@JoinTable(name =“Teacher_Student”,
	
	
Spring 常用注解
	
	@Controller：用于标注控制层组件 (如 struts 中的 action) ；
	@Service：用于标注业务层组件；
	@Repository：用于标注数据访问组件，即 DAO 组件；
	@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；
	@Autowired：注释使得接口可以被容器注入；
	
	@Value(“${ShortURLAPIAddress}”)：读取.properties 文件：
	@JSONField(format =“yyyy-MM-dd hh：mm：ss”)：FastJson 时间格式化：

	单元测试加载 Spring 配置：
		@RunWith(SpringJUnit4ClassRunner.class) 
		@ContextConfiguration(locations =“classpath：spring/spring-context.xml”) 
		@WebAppConfiguration
	



Spring 常用注解总结

	传统的 Spring 做法是使用.xml 文件来对 bean 进行注入或者是配置 aop、事物，这么做有两个缺点：
		1、如果所有的内容都配置在.xml 文件中，那么.xml 文件将会十分庞大；
			如果按需求分开.xml 文件，那么.xml 文件又会非常多。总之这将导致配置文件的可读性与可维护性变得很低。
		2、在开发中在.java 文件和.xml 文件之间不断切换，是一件麻烦的事，同时这种思维上的不连贯也会降低开发的效率。
			为了解决这两个问题，Spring 引入了注解，通过"@XXX"的方式，让注解与 Java Bean 紧密结合，
			既大大减少了配置文件的体积，又增加了 Java Bean 的可读性与内聚性。

	1、@Autowired

		@Autowired 顾名思义，就是自动装配，其作用是为了消除代码 Java 代码里面的 getter/setter 与 bean 属性中的 property。
		当然，getter 看个人需求，如果私有属性需要对外提供的话，应当予以保留。

		@Autowired 默认按类型匹配的方式，在容器查找匹配的 Bean，当有且仅有一个匹配的 Bean 时，Spring 将其注入 @Autowired 标注的变量中。
			<context：component-scan base-package="com.spring" />
			<bean id="zoo" class="com.spring.model.Zoo" />
			<bean id="tiger" class="com.spring.model.Tiger" />
			<bean id="monkey" class="com.spring.model.Monkey" />

		@Autowired 注解：
			当 Spring 发现 @Autowired 注解时，将自动在代码上下文中找到和其匹配 (默认是类型匹配) 的 Bean，并自动注入到相应的地方去。

		假如 bean 里面有两个 property，Zoo.java 里面又去掉了属性的 getter/setter 并使用 @Autowired 注解标注这两个属性那会怎么样？
		答案是 Spring 会按照 xml 优先的原则去 Zoo.java 中寻找这两个属性的 getter/setter，导致的结果就是初始化 bean 报错。

		@Autowired 注解要去寻找的是一个 Bean，Tiger 和 Monkey 的 Bean 定义都给去掉了，自然就不是一个 Bean 了，Spring 容器找不到。
		那么，如果属性找不到我不想让 Spring 容器抛出异常，而就是显示 null，可以吗？可以的，
		其实异常信息里面也给出了提示了，就是将 @Autowired 注解的 required 属性设置为 false 即可；
		此时，找不到 tiger、monkey 两个属性，Spring 容器不再抛出异常而是认为这两个属性为 null。

	2、Qualifier (指定注入 Bean 的名称) 

		如果容器中有一个以上匹配的 Bean，则可以通过 @Qualifier 注解限定 Bean 的名称
			<context：component-scan base-package="com.spring" />
			<!-- Autowired 注解配合 Qualifier 注解 -->
			<bean id="carFactory" class="com.spring.model.CarFactory" />
			<bean id="bmwCar" class="com.spring.service.impl.BMWCar" />
			<bean id="benz" class="com.spring.service.impl.BenzCar" />

		不用 @Qualifier 注解两种解决办法：
			(1)、在配置文件中删除其中一个实现类，Spring 会自动去 base-package 下寻找 Car 接口的实现类，
				发现 Car 接口只有一个实现类，便会直接引用这个实现类。
			(2)、实现类就是有多个该怎么办？此时可以使用 @Qualifier 注解来指定 Bean 的名称：

	3、Resource

		@Resource 注解与 @Autowired 注解作用非常相似

		@Resource 的装配顺序：
			(1)、@Resource 后面没有任何内容，默认通过 name 属性去匹配 bean，找不到再按 type 去匹配
			(2)、指定了 name 或者 type 则根据指定的类型去匹配 bean
			(3)、指定了 name 和 type 则根据指定的 name 和 type 去匹配 bean，任何一个不匹配都将报错

		@Autowired 和 @Resource 两个注解的区别：
			(1)、@Autowired 默认按照 byType 方式进行 bean 匹配，@Resource 默认按照 byName 方式进行 bean 匹配
			(2)、@Autowired 是 Spring 的注解，@Resource 是 J2EE 的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了

		Spring 属于第三方的，J2EE 是 Java 自己的东西，因此，建议使用 @Resource 注解，以减少代码和 Spring 之间的耦合。

	4、Service
	
		上面这个例子，还可以继续简化，因为 spring 的配置文件里面还有 15 行~17 行三个 bean，下一步的简化是把这三个 bean 也给去掉，
		使得 spring 配置文件里面只有一个自动扫描的标签，增强 Java 代码的内聚性并进一步减少配置文件。

		要继续简化，可以使用 @Service。

		这样，Zoo.java 在 Spring 容器中存在的形式就是"zoo"，即可以通过 ApplicationContext 的 getBean("zoo") 方法来得到 Zoo.java。
		@Service 注解，其实做了两件事情：
			(1)、声明 Zoo.java 是一个 bean，这点很重要，
				因为 Zoo.java 是一个 bean，其他的类才可以使用 @Autowired 将 Zoo 作为一个成员变量自动注入。
			(2)、Zoo.java 在 bean 中的 id 是"zoo"，即类名且首字母小写。

		@Service("Zoo")
		@Scope("prototype")
		可以通过 ApplicationContext 的 getBean("Zoo") 方法来得到 Zoo.java 了。

		这里我还多加了一个 @Scope 注解，应该很好理解。
		因为 Spring 默认产生的 bean 是单例的，假如我不想使用单例怎么办，xml 文件里面可以在 bean 里面配置 scope 属性。
		注解也是一样，配置 @Scope 即可，默认是"singleton"即单例，"prototype"表示原型即每次都会 new 一个新的出来。


使用注解来构造 IoC 容器

	用注解来向 Spring 容器注册 Bean。
		<context：component-scan base-package="cn.gacl.java"/>
	表明 cn.gacl.java 包及其子包中，如果某个类的头上带有特定的注解【@Component/@Repository/@Service/@Controller】，
	就会将这个对象作为 Bean 注册进 Spring 容器。
	也可以在<context：component-scan base-package=””/>中指定多个包，多个包逗号隔开。
	<context：component-scan base-package="cn.gacl.dao.impl,cn.gacl.service.impl,cn.gacl.action"/>

	1、@Component
		@Component 是所有受 Spring 管理组件的通用形式，@Component 注解可以放在类的头上，@Component 不推荐使用。

	2、@Controller
		@Controller 对应表现层的 Bean，也就是 Action，

		使用 @Controller 注解标识 UserAction 之后，就表示要把 UserAction 交给 Spring 容器管理，
		在 Spring 容器中会存在一个名字为"userAction"的 action，这个名字是根据 UserAction 类名来取的。
		注意：如果 @Controller 不指定其 value【@Controller】，则默认的 bean 名字为这个类的类名首字母小写，
		如果指定 value【@Controller(value="UserAction")】或者【@Controller("UserAction")】，则使用 value 作为 bean 的名字。

		这里的 UserAction 还使用了 @Scope 注解，@Scope("prototype") 表示将 Action 的范围声明为原型，可以利用容器的 scope="prototype"来保证每一个请求有一个单独的 Action 来处理，避免 struts 中 Action 的线程安全问题。spring 默认 scope 是单例模式 (scope="singleton")，这样只会创建一个 Action 对象，每次访问都是同一 Action 对象，数据不安全，struts2 是要求每次次访问都对应不同的 Action，scope="prototype" 可以保证当有请求的时候都创建一个 Action 对象。

	3、@Service
		@Service 对应的是业务层 Bean

		 @Service("userService") 注解是告诉 Spring，当 Spring 要创建 UserServiceImpl 的的实例时，bean 的名字必须叫做"userService"，
		 这样当 Action 需要使用 UserServiceImpl 的的实例时, 就可以由 Spring 创建好的"userService"，
		 然后注入给 Action：在 Action 只需要声明一个名字叫"userService"的变量来接收由 Spring 注入的"userService"即可，

		注意：在 Action 声明的"userService"变量的类型必须是"UserServiceImpl"或者是其父类"UserService"，
		否则由于类型不一致而无法注入，由于 Action 中的声明的"userService"变量使用了 @Resource 注解去标注，
		并且指明了其 name = "userService"，这就等于告诉 Spring，说我 Action 要实例化一个"userService"，你 Spring 快点帮我实例化好，然后给我，
		当 Spring 看到 userService 变量上的 @Resource 的注解时，根据其指明的 name 属性可以知道，
		Action 中需要用到一个 UserServiceImpl 的实例，
		此时 Spring 就会把自己创建好的名字叫做"userService"的 UserServiceImpl 的实例注入给 Action 中的"userService"变量，
		帮助 Action 完成 userService 的实例化，
		这样在 Action 中就不用通过"UserService userService = new UserServiceImpl();"这种最原始的方式去实例化 userService 了。
		如果没有 Spring，那么当 Action 需要使用 UserServiceImpl 时，必须通过"UserService userService = new UserServiceImpl();"主动去创建实例对象，
		但使用了 Spring 之后，Action 要使用 UserServiceImpl 时，就不用主动去创建 UserServiceImpl 的实例了，
		创建 UserServiceImpl 实例已经交给 Spring 来做了，Spring 把创建好的 UserServiceImpl 实例给 Action，Action 拿到就可以直接用了。
		Action 由原来的主动创建 UserServiceImpl 实例后就可以马上使用，
		变成了被动等待由 Spring 创建好 UserServiceImpl 实例之后再注入给 Action，Action 才能够使用。
		这说明 Action 对"UserServiceImpl"类的“控制权”已经被“反转”了，原来主动权在自己手上，自己要使用"UserServiceImpl"类的实例，自己主动去 new 一个出来马上就可以使用了，
		但现在自己不能主动去 new "UserServiceImpl"类的实例，new "UserServiceImpl"类的实例的权力已经被 Spring 拿走了，
		只有 Spring 才能够 new "UserServiceImpl"类的实例，而 Action 只能等 Spring 创建好"UserServiceImpl"类的实例后，
		再“恳求”Spring 把创建好的"UserServiceImpl"类的实例给他，这样他才能够使用"UserServiceImpl"，
		这就是 Spring 核心思想“控制反转”，也叫“依赖注入”，
		“依赖注入”也很好理解，Action 需要使用 UserServiceImpl 干活，那么就是对 UserServiceImpl 产生了依赖，
		Spring 把 Acion 需要依赖的 UserServiceImpl 注入 (也就是“给”) 给 Action，这就是所谓的“依赖注入”。
		对 Action 而言，Action 依赖什么东西，就请求 Spring 注入给他，对 Spring 而言，Action 需要什么，Spring 就主动注入给他。

	4、@ Repository
		@Repository 对应数据访问层 Bean

		@Repository(value="userDao") 注解是告诉 Spring，让 Spring 创建一个名字叫"userDao"的 UserDaoImpl 实例。

		当 Service 需要使用 Spring 创建的名字叫"userDao"的 UserDaoImpl 实例时，
		就可以使用 @Resource(name = "userDao") 注解告诉 Spring，Spring 把创建好的 userDao 注入给 Service 即可。


	Spring 常用注解汇总 
		本文汇总了 Spring 的常用注解，以方便大家查询和使用，具体如下：
			使用注解之前要开启自动扫描功能，其中 base-package 为需要扫描的包 (含子包)。
				<context：component-scan base-package="cn.test"/> 
		@Configuration：把一个类作为一个 IoC 容器，它的某个方法头上如果注册了 @Bean，就会作为这个 Spring 容器中的 Bean。
		@Scope：注解 作用域
		@Lazy(true)：表示延迟初始化
		@Controller：用于标注控制层组件 (如 struts 中的 action) 
		@Service：用于标注业务层组件
		@Repository：用于标注数据访问组件，即 DAO 组件。
		@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
		@Scope：用于指定 scope 作用域的 (用在类上) 
		@PostConstruct：用于指定初始化方法 (用在方法上) 
		@PreDestory：用于指定销毁方法 (用在方法上) 
		@DependsOn：定义 Bean 初始化及销毁时的顺序
		@Primary：自动装配时当出现多个 Bean 候选者时，被注解为 @Primary 的 Bean 将作为首选者，否则将抛出异常
		
		@Autowired：默认按类型装配，如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。如下：
		@Autowired @Qualifier("personDaoBean")：存在多个实例配合使用
		@Resource：默认按名称装配，当找不到与名称匹配的 bean 才会按类型装配。
		@PostConstruct：初始化注解
		@PreDestroy：摧毁注解 默认 单例 启动就加载
		@Async：异步方法调用








