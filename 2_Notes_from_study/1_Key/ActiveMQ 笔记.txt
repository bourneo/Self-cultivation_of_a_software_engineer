
ActiveMQ


ActiveMQ 核心

	是什么：
		
	为什么使用：
		
	基本原理：
		观察者模式
		queue 点到点
		topic 广播
		Producer
		Consumer
	怎么使用：
		引入 jar 包；
		整合 Spring；
			配置 Producer 和 Destination。
		测试。
	
小结
	ActiveMQ 消息队列：实现商品同步、同步生成静态网页。Activemq 整合 spring。
		1、queue 点到点
		2、topic 广播
		3、Producer
		4、Consumer
		ActiveMQ 作用：系统之间解耦时使用。实现数据最终一致。
	同步索引库分析：
		方案一：在 manager 中，添加商品的业务逻辑中，添加一个同步索引库的业务逻辑。
			缺点：业务逻辑耦合度高，业务拆分不明确
		方案二：业务逻辑在 search 中实现，调用服务在 manager 实现，业务逻辑分开。
			缺点：服务之间的耦合度变高，服务的启动有先后顺序。
		方案三：使用消息队列。
			MQ：消息中间件，ActiveMQ、RabbitMQ、kafka。

ActiveMQ
	ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。
	ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，
		尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。
	主要特点：
		1. 多种语言和协议编写客户端。语言: Java，C，C++，C#，Ruby，Perl，Python，PHP。
			应用协议: OpenWire，Stomp REST，WS Notification，XMPP，AMQP
		2. 完全支持 JMS1.1 和 J2EE 1.4 规范 (持久化，XA 消息，事务)
		3. 对 Spring 的支持，ActiveMQ 可以很容易内嵌到使用 Spring 的系统里面去，而且也支持 Spring2.0 的特性
		4. 通过了常见 J2EE 服务器 (如 Geronimo，JBoss 4，GlassFish，WebLogic) 的测试，
			其中通过 JCA 1.5 resource adaptors 的配置，
			可以让 ActiveMQ 可以自动的部署到任何兼容 J2EE 1.4 商业服务器上
		5. 支持多种传送协议:in-VM，TCP，SSL，NIO，UDP，JGroups，JXTA
		6. 支持通过 JDBC 和 journal 提供高速的消息持久化
		7. 从设计上保证了高性能的集群，客户端-服务器，点对点
		8. 支持 Ajax
		9. 支持与 Axis 的整合
		10. 可以很容易得调用内嵌 JMS provider，进行测试
		
	ActiveMQ 消息形式：
		消息的传递有两种类型：
			点对点模式：一个生产者和一个消费者一一对应；
			发布/订阅模式：一个生产者产生消息并进行发送后，可以由多个消费者进行接收。
			JMS 定义了五种不同的消息正文格式，以及调用的消息类型，
			允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。
			　　· StreamMessage -- Java 原始值的数据流
			　　· MapMessage--一套名称-值对
			　　· TextMessage--一个字符串对象
			　　· ObjectMessage--一个序列化的 Java 对象
			　　· BytesMessage--一个字节的数据流

	ActiveMQ 安装
		进入 http://activemq.apache.org/下载 ActiveMQ，使用的版本是 5.12.0
		安装环境：
			1、需要 jdk
			2、安装 Linux 系统。生产环境都是 Linux 系统。
		安装步骤
			第一步： 把 ActiveMQ 的压缩包上传到 Linux 系统。
			第二步：解压缩。
			第三步：启动。
				使用 bin 目录下的 activemq 命令启动：
					[root@localhost bin]# ./activemq start
				关闭：
					[root@localhost bin]# ./activemq stop
				查看状态：
					[root@localhost bin]# ./activemq status
				注意：如果 ActiveMQ 整合 spring 使用不要使用 activemq-all-5.12.0.jar 包。建议使用 5.11.2
				进入管理后台：
					http://192.168.25.168:8161/admin
					用户名：admin
					密码：admin
		503 错误解决:
			1、查看机器名
			[root@itcast168 bin]# cat /etc/sysconfig/network
				NETWORKING=yes
				HOSTNAME=itcast168
			2、修改 host 文件
			[root@itcast168 bin]# cat /etc/hosts
				127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 itcast168
				::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
				[root@itcast168 bin]# 
			3、重启 Activemq 服务

	ActiveMQ 的使用方法：
		Queue
			Producer
			生产者：生产消息，发送端。
				把 jar 包添加到工程中。使用 5.11.2 版本的 jar 包。
				第一步：创建 ConnectionFactory 对象，需要指定服务端 ip 及端口号。
				第二步：使用 ConnectionFactory 对象创建一个 Connection 对象。
				第三步：开启连接，调用 Connection 对象的 start 方法。
				第四步：使用 Connection 对象创建一个 Session 对象。
				第五步：使用 Session 对象创建一个 Destination 对象 (topic、queue) ，此处创建一个 Queue 对象。
				第六步：使用 Session 对象创建一个 Producer 对象。
				第七步：创建一个 Message 对象，创建一个 TextMessage 对象。
				第八步：使用 Producer 对象发送消息。
				第九步：关闭资源。
			Consumer
			消费者：接收消息。
				第一步：创建一个 ConnectionFactory 对象。
				第二步：从 ConnectionFactory 对象中获得一个 Connection 对象。
				第三步：开启连接。调用 Connection 对象的 start 方法。
				第四步：使用 Connection 对象创建一个 Session 对象。
				第五步：使用 Session 对象创建一个 Destination 对象。和发送端保持一致 queue，并且队列的名称一致。
				第六步：使用 Session 对象创建一个 Consumer 对象。
				第七步：接收消息。
				第八步：打印消息。
				第九步：关闭资源
		Topic
			Producer
			使用步骤：
				第一步：创建 ConnectionFactory 对象，需要指定服务端 ip 及端口号。
				第二步：使用 ConnectionFactory 对象创建一个 Connection 对象。
				第三步：开启连接，调用 Connection 对象的 start 方法。
				第四步：使用 Connection 对象创建一个 Session 对象。
				第五步：使用 Session 对象创建一个 Destination 对象 (topic、queue) ，此处创建一个 Topic 对象。
				第六步：使用 Session 对象创建一个 Producer 对象。
				第七步：创建一个 Message 对象，创建一个 TextMessage 对象。
				第八步：使用 Producer 对象发送消息。
				第九步：关闭资源。
			Consumer
			消费者：接收消息。
				第一步：创建一个 ConnectionFactory 对象。
				第二步：从 ConnectionFactory 对象中获得一个 Connection 对象。
				第三步：开启连接。调用 Connection 对象的 start 方法。
				第四步：使用 Connection 对象创建一个 Session 对象。
				第五步：使用 Session 对象创建一个 Destination 对象。和发送端保持一致 topic，并且话题的名称一致。
				第六步：使用 Session 对象创建一个 Consumer 对象。
				第七步：接收消息。
				第八步：打印消息。
				第九步：关闭资源

	Activemq 整合 spring
		使用方法
		第一步：引用相关的 jar 包。
		第二步：配置 Activemq 整合 spring。配置 ConnectionFactory
			<!-- 真正可以产生 Connection 的 ConnectionFactory，由对应的 JMS 服务厂商提供 -->
			<bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
				<property name="brokerURL" value="tcp://192.168.25.168:61616" />
			</bean>
			<!-- Spring 用于管理真正的 ConnectionFactory 的 ConnectionFactory -->
			<bean id="connectionFactory"
				class="org.springframework.jms.connection.SingleConnectionFactory">
				<!-- 目标 ConnectionFactory 对应真实的可以产生 JMS Connection 的 ConnectionFactory -->
				<property name="targetConnectionFactory" ref="targetConnectionFactory" />
			</bean>
		第三步：配置生产者。
			使用 JMSTemplate 对象。发送消息。
		第四步：在 spring 容器中配置 Destination。
			<!-- 配置生产者 -->
			<!-- Spring 提供的 JMS 工具类，它可以进行消息发送、接收等 -->
			<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">
				<!-- 这个 connectionFactory 对应的是我们定义的 Spring 提供的那个 ConnectionFactory 对象 -->
				<property name="connectionFactory" ref="connectionFactory" />
			</bean>
			<!--这个是队列目的地，点对点的 -->
			<bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue">
				<constructor-arg>
				<value>spring-queue</value>
				</constructor-arg>
			</bean>
			<!--这个是主题目的地，一对多的 -->
			<bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic">
				<constructor-arg value="topic" />
			</bean>
		第五步：代码测试
			发送消息
				第一步：初始化一个 spring 容器
				第二步：从容器中获得 JMSTemplate 对象。
				第三步：从容器中获得一个 Destination 对象
				第四步：使用 JMSTemplate 对象发送消息，需要知道 Destination
			接收消息
				第一步：把 Activemq 相关的 jar 包添加到工程中
				第二步：创建一个 MessageListener 的实现类。
				第三步：配置 spring 和 Activemq 整合。
					<!-- 真正可以产生 Connection 的 ConnectionFactory，由对应的 JMS 服务厂商提供 -->
					<bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
						<property name="brokerURL" value="tcp://192.168.25.168:61616" />
					</bean>
					<!-- Spring 用于管理真正的 ConnectionFactory 的 ConnectionFactory -->
					<bean id="connectionFactory"
						class="org.springframework.jms.connection.SingleConnectionFactory">
						<!-- 目标 ConnectionFactory 对应真实的可以产生 JMS Connection 的 ConnectionFactory -->
						<property name="targetConnectionFactory" ref="targetConnectionFactory" />
					</bean>
					<!-- 这个是队列目的地，点对点的 -->
					<bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue">
						<constructor-arg>
						<value>spring-queue</value>
						</constructor-arg>
					</bean>
					<!-- 这个是主题目的地，一对多的 -->
					<bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic">
						<constructor-arg value="topic" />
					</bean>
					<!-- 接收消息 -->
					<!-- 配置监听器 -->
					<bean id="myMessageListener" class="com.taotao.search.listener.MyMessageListener" />
					<!-- 消息监听容器 -->
					<bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
						<property name="connectionFactory" ref="connectionFactory" />
						<property name="destination" ref="queueDestination" />
						<property name="messageListener" ref="myMessageListener" />
					</bean>

实例
	添加商品同步索引库
		Producer
			在 manager-server 工程中发送消息。
			当商品添加完成后发送一个 TextMessage，包含一个商品 id。
		Consumer
			功能分析：
			1、接收消息。需要创建 MessageListener 接口的实现类。
			2、取消息，取商品 id。
			3、根据商品 id 查询数据库。
			4、创建一 SolrInputDocument 对象。
			5、使用 SolrServer 对象写入索引库。
			6、返回成功，返回 TaotaoResult。



