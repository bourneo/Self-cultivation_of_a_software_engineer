	
Python 笔记
	
	
基础部分
	
	数据类型：
		整数 (integer)；(Python的整数没有大小限制)
		浮点数 (float)；(Python的浮点数也没有大小限制，但是超出一定范围就直接表示为 inf 无限大)
		字符串 (str)；
		布尔值 bool()；
		空值 (None)；
	
	数据结构：
		list：列表；
			list是一种有序的集合，可以随时添加和删除其中的元素。
		tuple：元组；
			一旦初始化就不能修改；因为 tuple 不可变，所以代码更安全。
		dict：字典；
			dictionary，在其他语言中也称为map，使用键-值（key-value）存储。
			把数据放入 dict，除了初始化时指定外，还可以通过key放入：
				d['Adam'] = 67
				由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
				如果key不存在，dict就会报错：
				要避免key不存在的错误，有两种办法：
					一是通过in判断key是否存在：
					二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
				要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
				在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。
				list是可变的，就不能作为key：
		set：集；
			set和dict类似，也是一组key的集合，但不存储value。
			由于key不能重复，所以，在set中，没有重复的key。
				add(key)方法可以添加元素到set中
				remove(key)方法可以删除元素：
	
	条件判断：
		if <条件判断1>:
			<执行1>
		elif <条件判断2>:
			<执行2>
		else:
			<执行3>
		
		if判断条件还可以简写，只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
		比如：
			if x:
				print('True')
	
	类型转换：
		int()；
		str()；
		float()；
		bool()；
		
		
	循环：
		for ... in ... 循环：
			sum = 0
			for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
				sum = sum + x
			print(sum)
		while 循环：
			sum = 0
			n = 99
			while n > 0:
				sum = sum + n
				n = n - 2
			print(sum)
		break：
			提前退出循环。
		continue：
			跳过当前的这次循环，直接开始下一次循环。
	
	函数：
		range()：
			整数列表；
			可以生成一个整数序列，再通过list()函数可以转换为list。
		max()：
			可以接收任意多个参数，并返回最大的那个
		
		空函数：
			如果想定义一个什么事也不做的空函数，可以用pass语句：
		返回多个值：
			返回值是一个tuple；
			在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，
			所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
		
	参数：
		位置参数：
			positional argument
		默认参数：
			设置默认参数时，有几点要注意：
				一是必选参数在前，默认参数在后，否则Python的解释器会报错；
				二是如何设置默认参数。
			默认参数必须指向不变对象。
		可变参数：
			
		关键字参数：
			
		命名关键字参数：
			
		参数组合：
			
	递归函数：
		理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
			在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
			每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
			由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
		尾递归：在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
			这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
		大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
			
	切片：
		L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
		如果第一个索引是0，还可以省略。
		L[-1]取倒数第一个元素，同样支持倒数切片；倒数第一个元素的索引是-1。
		
			tuple也可以用切片操作，只是操作的结果仍是tuple。
			字符串也可以用切片操作，只是操作结果仍是字符串：
			
	迭代 Iteration ：
		for ... in ... 循环：
			for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。
		Python内置的enumerate函数可以把一个list变成索引-元素对，
		这样就可以在for循环中同时迭代索引和元素本身：
			for i, value in enumerate(['A', 'B', 'C']):
			
	列表生成式：
		生成 [1x1, 2x2, 3x3, ..., 10x10]：
			[x * x for x in range(1, 11)]
		for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
			[x * x for x in range(1, 11) if x % 2 == 0]
		还可以使用两层循环，可以生成全排列：
			[m + n for m in 'ABC' for n in 'XYZ']
		os.listdir可以列出文件和目录
			[d for d in os.listdir('.')]
		for 循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：
			d = {'x': 'A', 'y': 'B', 'z': 'C' }
			for k, v in d.items():
		列表生成式也可以使用两个变量来生成list：
			d = {'x': 'A', 'y': 'B', 'z': 'C' }
			[k + '=' + v for k, v in d.items()]
		一个list中所有的字符串变成小写：
			L = ['Hello', 'World', 'IBM', 'Apple']
			[s.lower() for s in L]
			
	生成器：generator
		第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
			L = [x * x for x in range(10)]
			g = (x * x for x in range(10))
			可以通过next()函数获得generator的下一个返回值：
			generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，
			没有更多的元素时，抛出StopIteration的错误。
			不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：
			g = (x * x for x in range(10))
			for n in g:
			我们创建了一个generator后，通过for循环来迭代它，并且不需要关心StopIteration的错误。
		第二种：如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
			generator和函数的执行流程不一样。
			函数是顺序执行，遇到return语句或者最后一行函数语句就返回。
			而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，
			再次执行时从上次返回的yield语句处继续执行。
		用for循环调用generator时，发现拿不到generator的return语句的返回值。
		如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：
			g = fib(6)
			while True:
				try:
					x = next(g)
					print('g:', x)
				except StopIteration as e:
					print('Generator return value:', e.value)
					break
		
	迭代器(Iterator)：
		可以被next()函数调用并不断返回下一个值的对象。
		可以直接作用于for循环的数据类型有以下几种：
			一类是集合数据类型，如list、tuple、dict、set、str等；
			一类是generator，包括生成器和带yield的generator function。
		这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。
		可以使用isinstance()判断一个对象是否是Iterable对象：
			from collections import Iterable
			isinstance([], Iterable)
		为什么list、dict、str等数据类型不是Iterator？
			这是因为Python的Iterator对象表示的是一个数据流，
			Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。
			可以把这个数据流看做是一个有序序列，
			但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，
			所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
			Iterator甚至可以表示一个无限大的数据流，例如全体自然数。
			而使用list是永远不可能存储全体自然数的。
		小结
			可作用于for循环的对象都是Iterable类型；
			可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
			集合数据类型如list、dict、str等是Iterable但不是Iterator，
			不过可以通过iter()函数获得一个Iterator对象。
			Python的for循环本质上就是通过不断调用next()函数实现的。
		
	高阶函数：
		高阶函数的抽象能力是非常强大的，核心代码可以保持得非常简洁。
		变量可以指向函数：函数本身也可以赋值给变量；
		函数名也是变量：可以把 函数名 指向其他对象；
		传入函数：
			既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，
			这种函数就称之为高阶函数。
		
		map()：
			接收两个参数，一个是函数，一个是Iterable，
			map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
			
		reduce()：
			reduce 把一个函数作用在一个序列[x1, x2, x3, ...]上，
			这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，
			其效果就是：
				reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
			
		lambda()：
			
			
		filter()：
			用于过滤序列。
			接收一个函数和一个序列。
			和map()不同的是，filter()把传入的函数依次作用于每个元素，
			然后根据返回值是True还是False决定保留还是丢弃该元素。
			
		sorted()：
			可以对list进行排序；
			sorted()是一个高阶函数，它还可以接收一个key函数来实现自定义的排序。
			key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。
			然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：
			
			
	返回函数：
		函数作为返回值：
			高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
			
		闭包
			有权访问另一个函数作用域内变量的函数都是闭包。
			返回的函数在其定义内部引用了局部变量args，
				所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，
				所以，闭包用起来简单，实现起来可不容易。
			另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。
			返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
				如果一定要引用循环变量怎么办？
				方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，
				无论该循环变量后续如何更改，已绑定到函数参数的值不变
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		strip()：
			用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
			
		split()：
			根据规定的字符将字符串进行分割。
			
			
			
			
		
			
			
			
			
			
			
			
			
			
			
	可变对象：
		list；
		
		
	不可变对象：
		str；
		integer；
		None；
		tuple；
	
	
	
	
	
	Introduction
		comments：注释；
			# 单行注释 
			"""
			多行注释 
			"""
		
	Variables：变量；
		variable definition：变量定义；
			链式赋值：a = b = 2；chained assignment；
			变量名：不能以数字开头；
			
		Variable types：变量类型；
			numbers: 
				integers：
				floats：
			
		Type conversion：类型转换；
			int(x)：转成整数类形；
			float(x)：转成浮点类型；
			str(b)：转成字符串类型；
		
		Arithmetic operators：算术操作；
			addition (+)
			subtraction (-)
			multiplication (*)
			division (/)
			power (**)：指数；
			modulo (%)：求模；
			
		Augmented assignment：增量赋值；
			+= ：
			-= ：
			
		Boolean operators：布尔运算；
			== ：
			!= ：
		
		Comparison operators：
			链式比较：chained comparison
				one < two < three
			>= ：
			<= ：
			> :
			< :
		
	Strings：字符串；
		Concatenation：连接符；
			+ ：
			
		String multiplication：字符串乘法；
			string-by-number multiplication：
			hello * 10
			
		String indexing：字符串索引取值；
			str[index]：索引处的元素；
			
		String negative indexing：字符串负索引取值；
			str[-1]：从末尾开始；
		
		String slicing：字符串切片；
			slicing：切片；可用于字符串、数组、List等类型；
			str[start:end]：起始(包含)，结束(不包含)
			str[start:]：
			str[:end]：
			str[:]：全部；
			
		In operator：包含；
			keyword in String：
			
		String length：字符串长度；
			len()：String 长度；
			
		Character escaping：字符转义；
			\ ：转义符；
			'\n'：换行；
		
		Basic string methods：字符串操作方法；
			lower()：
			upper()：
		
		String formatting：字符串格式化；
			% ：占位符；
			%s ：字符串占位符；
				% %s ：% 后面的变量会替换掉 String 中的 %s；
			%d ：数字占位符；
		
	Data structures：数据结构；
		Lists introduction：列表；
			slicing：切片；可用于字符串、数组、List、元组等类型；
			lst[start:end]：起始(包含)，结束(不包含)
			lst[start:end:stride]：起始(包含)，结束(不包含)，跨度(每几个取一个，为负则会从最末往前取)；
		
		Lists operations：列表操作；
			+= ：增量赋值；
			append()：追加；
		
		List items：列表项；
			animals = ['elephant', 'lion', 'tiger', "giraffe", "monkey", 'dog']
			animals[1:3] = ['cat']
			animals[1:3] = []
			animals[:] = []
		
		Tuples：元组；
			元组内元素无法被增加、修改或者删除；只能进行查询、截取和 + * 等运算操作；
			单元素元组必须以逗号结尾；
			内置函数：
				len()：长度；
				cmp()：比较；
				max()：最大元素；
				min()：最小元素；
		
		Dictionaries：字典；
			键值对；
			dic[key] = value
			keys()：键；
			values()：值；
			String in dic.keys();
			integer in dic.values();
			
	Condition expressions：条件表达式；
		Boolean operators：布尔运算；
			not：一级优先；
			and：二级优先；
			or：三级优先；
			== ：
			!= ：
			is：变量和字符串；
			运算顺序：
				not：first；
				and：next；
				or：last。
		
		If statement：条件语句；
			if boolean :
				todo
			elif boolean :
				todo
			else:
				todo
			
	Loops：循环；
		For loop：for 循环；
			for i in range(5):
				print(i)   
		
		For loop using string：字符串 for 循环；
			length = 0
			for ch in hello_world:
				length += 1
		
		While loop：while 循环；
			square = 1
			while square <= 10:
				print(square)
				square += 1 
		
		Break keyword：打断；
			count = 0
			while True:
				print(count)
				count += 1
				if count >= 5:
					break
		
		Continue keyword：略过继续；
			for x in range(10):
				if x % 2 == 0:
					continue
				print(x)
			
	Functions：函数；
		Definition：定义；
			def hello_world():
				print("Hello, World!")
		
		Parameters and call arguments：形参和调用传参；
			def square(x):
				print(x ** 2)
				square(5)
		
		Return value：返回值；
			def fib(n):
				result = []
				a = 1
				b = 1
			while a < n:
				result.append(a)
				tmp_var = b
				b = a + b
				a = tmp_var
			return result
		
		Default parameters：默认参数；
			def multiply_by(a, b=2):
				return a * b
			
	Classes and objects：类和对象；	
		Definition：定义；
			class MyClass:
			my_object = MyClass()
		
		Variable access：变量访问；
			my_object = MyClass()
			my_object.variable1
		
		Self explanation：当前对象；
			self：调用时的类的实例
				类的方法必须有个额外的第一个参数；
				按照Python的惯例，它用 self 来表示。
				self 不是关键字；
				self 代表当前对象的地址；
				self 在定义类时不可以省略，在调用时会自动传入。
				self 能避免非限定调用造成的全局变量。
			class Calculator:
				current = 0
				def add(self, amount):
					self.current += amount
				def get_current(self):
					return self.current
		
		Special __init__ method：初始化方法；
			__init__()：
				初始化方法，用于初始化一个类；
				类实例创建之后调用, 对当前对象的实例的一些初始化, 没有返回值；
				__new__()：创建类实例的方法, 创建对象时调用, 返回当前对象的一个实例；
				__str__()：内置方法, 只能返回字符串, 并且只能有一个参数 self；
				__call__()：
					对象通过提供一个 __call__(self, *args, *kwargs) 方法可以模拟函数的行为，
					如果一个对象提供了该方法, 可以向函数一样去调用它
			
	Modules and packages：模块和包；
		Import module：导入模块；
			import my_module
			
		Built-in modules：内置模块；
			import datetime
			print(datetime.datetime.today())
			
		From import：
			from calculator import Calculator：可以直接调用，无需模块名调用；
			
	File input output：文件输入输出；
		Read file：读取文件；
			f = open("output.txt", "r")
			for line in f.readlines():
				print(line)
			f.close()
		Write to file：写入文件；
			f = open("output.txt", "a")
			for i in zoo:
				f.write(i)
			f.close()
			注意：
				f = open("output.txt", "w")：如果存在同名文件，会先删除再新建文件写入；
				f = open("output.txt", "a")：追加写入；
		
		
提高
		
	描述符类：Python中一种用于储存类属性值的对象；
		通常需要以下几种魔术方法：
			__set__(self, instance, value)
			__get__(self, instance, owner)
			__delete__(self, instance)
			__set_name__(self, owner， name)
		
		
		
		
		
		
		
		
		
		
		
Django
	Django settings：配置；
		settings file contains all the configuration of your Django installation；
		设置文件包含了所有的配置信息。
	
	Models：模板；
		each model maps to a single database table. 
		每个模板对应一张数据库表；
		Each model is a Python class that subclasses django.db.models.Model.
		每个模板都是一个类；继承于 django.db.models.Model；
		Each attribute of the model represents a database field.
		模板的每一个属性，对应数据库表中的一个字段；
		Django gives you an automatically-generated database-access API
		能自动生成访问数据库的 API。
		
	URL dispatcher：资源路径调度器；
		URLconf (URL configuration)：simple mapping between URL patterns (simple regular expressions)；
			To capture a value from the URL, just put parenthesis around it.
			用圆括号获取 URL 中的值；
			There’s no need to add a leading slash, because every URL has that. 
			For example, it’s ^articles, not ^/articles.
			开头不需要斜杠；
			The 'r' in front of each regular expression string is optional but recommended. 
			It tells Python that a string is “raw” – that nothing in the string should be escaped.
			r 代表字符串是原生的，没有转义符。
		regular expressions：正则表达式；
			^ ：开头；
			$ ：结尾；
			[0-9] ：范围内选择；
			{4} ：重复次数；
			() ：允许重复多个字符；
			+ ：软性量词 出现一次或多次(至少一次)。
		
	Writing views：视图；
		def post_list(request):
			return render(request, 'blog/post_list.html', {})
		
	Templates：模板；
		HTML 文件；
		
	Dynamic data in templates：模板中的动态数据；
		def post_list(request):
			posts = Post.objects.order_by('published_date')
			return render(request, 'blog/post_list.html', {posts})
		Example：全部数据；
			Post.objects.all()
		Filter objects：过滤；
			Post.objects.filter(author=me)
		Ordering objects：排序；
			Post.objects.order_by('created_date')
			Post.objects.order_by('-created_date')
		Chaining QuerySets：链接查询集；
			Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
		
	Django template language：模板语言；
		Variables are surrounded by {{ and }}
		变量语法：{{ }}
		Tags are surrounded by {% and %}
		标签语法：{% %}
			{% for post in posts %}
				{{ post.author }} {{ post.title }} {{ post.text }} {{ post.created_date }} {{ post.published_date }}
			{% end for %}
		
		
单元测试
	结果类型：
	    def test_success(self):
			pass

		def test_failure(self):
			self.assertEqual(True, False)

		def test_error(self):
			raise Exception
		
		pass 语句：
			空语句，是为了保持程序结构的完整性。
			pass 不做任何事情，一般用做占位语句
			
		raise 关键字：
			用来触发异常；后面是要引发的异常的名称；异常类的名称后面可以添加一个逗号以及指定的参数；
			一旦执行了raise语句，raise后面的语句将不能执行；
			
		format 函数：
			通过 {} 和 : 来代替%。
			例如："Hello, {}!".format(name)
		
		copy 函数：
			复制；
			
	Assertion Types：断言类型；
		the integer zero is considered false, while all other integers are considered true. 
		0 代表假；其他整型代表真；
		Most containers are considered false when empty and true when non-empty
		空容器代表假，非空容器代表真。
		
		例如：
			def test_zero(self):
				self.assertFalse(0)

			def test_one(self):
				self.assertTrue(1)
			
			def test_none(self):
				self.assertFalse(None)
		
		    def _test_container_class(self, empty_container, non_empty_container):
				self.assertFalse(empty_container)
				self.assertTrue(non_empty_container)

			def test_list(self):
				self._test_container_class([], [False])

			def test_tuple(self):
				self._test_container_class((), (False, ))

			def test_set(self):
				self._test_container_class(set(), {False})

			def test_dict(self):
				self._test_container_class({}, {False: False})
		
		assertion methods：
			Method						Checks that				New in
			assertEqual(a, b)			a == b	 
			assertNotEqual(a, b)		a != b	 
			assertTrue(x)				bool(x) is True	 
			assertFalse(x)				bool(x) is False	 
			assertIs(a, b)				a is b					3.1
			assertIsNot(a, b)			a is not b				3.1
			assertIsNone(x)				x is None				3.1
			assertIsNotNone(x)			x is not None			3.1
			assertIn(a, b)				a in b					3.1
			assertNotIn(a, b)			a not in b				3.1
			assertIsInstance(a, b)		isinstance(a, b)		3.2
			assertNotIsInstance(a, b)	not isinstance(a, b)	3.2
			assertCountEqual(a, b)		a.len() == b.len()		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		