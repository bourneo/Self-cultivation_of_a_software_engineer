
GC 笔记
















Java 垃圾回收与内存

	垃圾回收

		对象是使用 new 创建的，但是并没有与之相对应的 delete 操作来回收对象占用的内存。当我们完成对某个对象的使用时，只需停止该对象的引用：
			将引用改变为指向其他对象；
			将引用指向 null；
			从方法中返回，使得该方法的局部变量不复存在。

		要点：
			当我们从任何可执行代码都无法到达某个对象时，它所占用的空间就可以被回收。
			垃圾回收意味着我们永远不用担心出现虚悬引用 (dangling reference)。
				虚悬引用，指得是引用已经被删除的内存空间。
				在那些程序员可以直接控制何时删除对象的系统中，会存在这样的问题。
			垃圾回收器模型：
				引用计数器法 (不能解决循环引用)，标记-清除 (mark-and-sweep)

	终结

		finalize 方法
			在垃圾回收器确定该对象是不可达的且该对象的空间将被回收之后，垃圾回收器就会调用这个方法。
			这个方法可以清除该对象所使用的所有非内存资源，对每一个对象最多只能调用一次，即使在这个方法的执行使得该对象重新变为可达之后又马上会再次变为不可达的情况下，该方法也只能调用一次。
			finalize 方法可以在任何特定的时间段内被调用，它也可能永远不会被调用 (java 虚拟机结束)。

		覆写 finalize 方法
			当一个对象变成垃圾时，它所引用的其他对象也很有可能会变成垃圾。这些垃圾可能在调用我们编写的 finalize 方法之前就已经被终结了，因此它们可能处于不可预知的状态。
			覆写 finalize 方法是，加上 super.finalize 方法。最好加在 finally 字句里面。保证其超类中声明的部分内容也可以被终结。

	与垃圾回收器交互的相关类和方法

		类：Runtime.getRuntime()，System
		方法：gc()，runFinalization()，freeMemory()，totalMemory()，maxMemory()
		System 类支持静态的 gc() 和 runFinalization() 方法，它们将调用当前 Runtime 对象上的相应方法。

	可达性状态和引用对象
	
		对象只有在没有任何引用指定它的时候才可以被当作垃圾回收，
		但有时我们可能希望在仍旧有选定引用指向对象时，将该对象作为垃圾回收掉。

			引用对象的唯一用途就是维护对另一个被称为指称物 (referent) 的对象的引用。
			通常我们通过字段或者局部变量来维护对对象的引用，
			但是现在我们可以维护对引用对象的直接引用，而该引用对象包装了我们实际需要的对象。
			垃圾回收器可能判断出对某个对象的残留引用是否都是经由引用对象面引用到该对象的，
			因此它可以决定是否要回收该对象。
			引用对象的强度将决定垃圾回收器的行为，普通的引用都是强度最大的引用。

		Reference 类
			包：java.lang.ref
			典型方法：get()，clear()，enqueue()，isEnqueued()

		引用和可达性强度：
			对象是强可达的 (strongly reachable)：普通的引用；
			对象是软可达的 (softly reachable)：SoftReference；
			对象是弱可达的 (weakly reachable)：WeakReference；
			对象是虚可达的 (phantom reachable)：PhantomReference；
			对象是不可达的：没有引用链接。
			一旦对象变为弱可达的 (或者列弱)，它就可以被终结。如果在终结之后该对象是不可达的，那么它就可以被回收了。

		对象可达性阶段会触发垃圾回收器对相关的引用对象类型做出适当的行为：
			软可达对象可能会任凭垃圾回收器去回收。
			我们可确定的是所有对软可达对象的 SoftReference 都会在抛出 outofMemoryError 错误这前被清除。
			弱可达对象将会被垃圾回收器回收。
			虚可达对象并不是真正意义上的可达，
				因为无法通过 PhantomReference 访问其指称对象，其 get 方法总是返回 null。
			但是虚引用的存在可以防止对象在显式清除虚引用之前被回收。虚引用使我们可以处理那些 finalize 方法已经被调用过的对象，从而可以安全地认为它们是"死"的。


Java 垃圾回收

	1 Java 垃圾回收

			gc 即垃圾收集机制是指 jvm 用于释放那些不再使用的对象所占用的内存。
			java 语言并不要求 jvm 有 gc，也没有规定 gc 如何工作。
			不过常用的 jvm 都有 gc，而且大多数 gc 都使用类似的算法管理内存和执行收集操作。

			在充分理解了垃圾收集算法和执行过程后，才能有效的优化它的性能。有些垃圾收集专用于特殊的应用程序。
			比如，实时应用程序主要是为了避免垃圾收集中断，而大多数 OLTP 应用程序则注重整体效率。
			理解了应用程序的工作负荷和 jvm 支持的垃圾收集算法，便可以进行优化配置垃圾收集器。

			垃圾收集的目的在于清除不再使用的对象。gc 通过确定对象是否被活动对象引用来确定是否收集该对象。
			gc 首先要判断该对象是否是时候可以收集。两种常用的方法是引用计数和对象引用遍历。

		引用计数

			引用计数存储对特定对象的所有引用数，
			也就是说，当应用程序创建引用以及引用超出范围时，jvm 必须适当增减引用数。
			当某对象的引用数为 0 时，便可以进行垃圾收集。

		对象引用遍历

			早期的 jvm 使用引用计数，现在大多数 jvm 采用对象引用遍历。对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达 (reachable) 的对象。如果某对象不能从这些根对象的一个 (至少一个) 到达，则将它作为垃圾收集。在对象遍历阶段，gc 必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记 (marking) 对象。

			下一步，gc 要删除不可到达的对象。删除时，有些 gc 只是简单的扫描堆栈，删除未标记的未标记的对象，并释放它们的内存以生成新的对象，这叫做清除 (sweeping) 。这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大。因此，许多 gc 可以重新组织内存中的对象，并进行压缩 (compact) ，形成可利用的空间。

			为此，gc 需要停止其他的活动活动。这种方法意味着所有与应用程序相关的工作停止，只有 gc 运行。结果，在响应期间增减了许多混杂请求。另外，更复杂的 gc 不断增加或同时运行以减少或者清除应用程序的中断。有的 gc 使用单线程完成这项工作，有的则采用多线程以增加效率。

	几种垃圾回收机制

		标记－清除收集器

			这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。

		标记－压缩收集器

			有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。

		复制收集器

			这种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，jvm 生成的新对象则放在另一半空间中。gc 运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。

		增量收集器

			增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾。这会造成较小的应用程序中断。

		分代收集器

			这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。jvm 生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。

		并发收集器

			并发收集器与应用程序同时运行。这些收集器在某点上 (比如压缩时) 一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低。

		并行收集器

			并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作。在多 cpu 机器上使用多线程技术可以显著的提高 java 应用程序的可扩展性。

	Sun HotSpot

		JVM 堆大小的调整

			使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。
			Jvm 生成的所有新对象放在新域中。一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域。在永久域中 jvm 则存储 class 和 method 对象。就配置而言，永久域是一个独立域并且不认为是堆的一部分。

			下面介绍如何控制这些域的大小。
				
				可使用-Xms 和-Xmx 控制整个堆的原始大小或最大值。

			下面的命令是把初始大小设置为 128M：

				java –Xms128m

				–Xmx256m 为控制新域的大小，可使用-XX：NewRatio 设置新域在堆中所占的比例。

			下面的命令把整个堆设置成 128m，新域比率设置成 3，即新域与旧域比例为 1：3，新域为堆的 1/4 或 32M：

				java –Xms128m –Xmx128m
				–XX：NewRatio =3 可使用-XX：NewSize 和-XX：MaxNewsize 设置新域的初始值和最大值。

			下面的命令把新域的初始值和最大值设置成 64m：

				java –Xms256m –Xmx256m –Xmn64m

			永久域默认大小为 4m。运行程序时，jvm 会调整永久域的大小以满足需要。
			每次调整时，jvm 会对堆进行一次完全的垃圾收集。

			使用-XX：MaxPerSize 标志来增加永久域搭大小。
			在 WebLogic Server 应用程序加载较多类时，经常需要增加永久域的最大值。
			当 jvm 加载类时，永久域中的对象急剧增加，从而使 jvm 不断调整永久域大小。
			为了避免调整，可使用-XX：PerSize 标志设置初始值。

			下面把永久域初始值设置成 32m，最大值设置成 64m。

				java -Xms512m -Xmx512m -Xmn128m -XX：PermSize=32m -XX：MaxPermSize=64m

			默认状态下，HotSpot 在新域中使用复制收集器。该域一般分为三个部分。
			第一部分为 Eden，用于生成新的对象。
			另两部分称为救助空间，当 Eden 充满时，收集器停止应用程序，把所有可到达对象复制到当前的 from 救助空间，
			一旦当前的 from 救助空间充满，收集器则把可到达对象复制到当前的 to 救助空间。
			From 和 to 救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域。
				
				使用-XX：SurvivorRatio 可控制新域子空间的大小。

			同 NewRation 一样，SurvivorRation 规定某救助域与 Eden 空间的比值。
			比如，以下命令把新域设置成 64m，Eden 占 32m，每个救助域各占 16m：

				java -Xms256m -Xmx256m -Xmn64m -XX：SurvivorRation =2

			如前所述，默认状态下 HotSpot 对新域使用复制收集器，对旧域使用标记－清除－压缩收集器。在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出 Eden 空间时将被收集。如果能够这样的话，并且移出 Eden 空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。为控制新域中对象的复制，可用-XX：TargetSurvivorRatio 控制救助空间的比例 (该值是设置救助空间的使用比例。如救助空间位 1M，该值 50 表示可用 500K) 。该值是一个百分比，默认值是 50。当较大的堆栈使用较低的 sruvivorratio 时，应增加该值到 80 至 90，以更好利用救助空间。用-XX：maxtenuring threshold 可控制上限。

			为放置所有的复制全部发生以及希望对象从 eden 扩展到旧域，可以把 MaxTenuring Threshold 设置成 0。
			设置完成后，实际上就不再使用救助空间了，因此应把 SurvivorRatio 设成最大值以最大化 Eden 空间，设置如下：

				java … -XX：MaxTenuringThreshold=0 –XX：SurvivorRatio＝50000 …

	BEA JRockit JVM 的使用

			Bea WebLogic 8。1 使用的新的 JVM 用于 Intel 平台。
			在 Bea 安装完毕的目录下可以看到有一个类似于 jrockit81sp1_141_03 的文件夹。
			这就是 Bea 新 JVM 所在目录。
			不同于 HotSpot 把 Java 字节码编译成本地码，它预先编译成类。
			JRockit 还提供了更细致的功能用以观察 JVM 的运行状态，主要是独立的 GUI 控制台
			 (只能适用于使用 Jrockit 才能使用 jrockit81sp1_141_03 自带的 console 监控一些 cpu 及 memory 参数) 
			或者 WebLogic Server 控制台。

			Bea JRockit JVM 支持 4 种垃圾收集器：

		分代复制收集器

			它与默认的分代收集器工作策略类似。对象在新域中分配，即 JRockit 文档中的 nursery。这种收集器最适合单 cpu 机上小型堆操作。

		单空间并发收集器

			该收集器使用完整堆，并与背景线程共同工作。尽管这种收集器可以消除中断，但是收集器需花费较长的时间寻找死对象，而且处理应用程序时收集器经常运行。如果处理器不能应付应用程序产生的垃圾，它会中断应用程序并关闭收集。

			分代并发收集器这种收集器在护理域使用排它复制收集器，在旧域中则使用并发收集器。由于它比单空间共同发生收集器中断频繁，因此它需要较少的内存，应用程序的运行效率也较高，注意，过小的护理域可以导致大量的临时对象被扩展到旧域中。这会造成收集器超负荷运作，甚至采用排它性工作方式完成收集。

		并行收集器

			该收集器也停止其他进程的工作，但使用多线程以加速收集进程。尽管它比其他的收集器易于引起长时间的中断，但一般能更好的利用内存，程序效率也较高。

			默认状态下，JRockit 使用分代并发收集器。要改变收集器，可使用-Xgc：，对应四个收集器分别为 gencopy，singlecon，gencon 以及 parallel。可使用-Xms 和-Xmx 设置堆的初始大小和最大值。要设置护理域，则使用- Xns：java –jrockit –Xms512m –Xmx512m –Xgc：gencon –Xns128m…尽管 JRockit 支持-verbose：gc 开关，但它输出的信息会因收集器的不同而异。JRockit 还支持 memory、 load 和 codegen 的输出。

			注意 ：如果 使用 JRockit JVM 的话还可以使用 WLS 自带的 console (C：\bea\jrockit81sp1_141_03\bin 下) 来监控一些数据，如 cpu，memery 等。要想能构监控必须在启动服务时 startWeblogic。cmd 中加入－Xmanagement 参数。

	如何从 JVM 中获取信息来进行调整

		-verbose。gc 开关可显示 gc 的操作内容。
		打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。
		打开- xx：+ printgcdetails 开关，可以详细了解 gc 中的变化。
		打开-XX：+ PrintGCTimeStamps 开关，可以了解这些垃圾收集发生的时间，自 jvm 启动以后以秒计量。
		最后，通过-xx：+ PrintHeapAtGC 开关了解堆的更详细的信息。
		为了了解新域的情况，可以通过-XX：=PrintTenuringDistribution 开关了解获得使用期的对象权。

	Pdm 系统 JVM 调整

		服务器：前提内存 1G 单 CPU

			可通过如下参数进行调整：－server 启用服务器模式 (如果 CPU 多，服务器机建议使用此项) 

			－Xms，－Xmx 一般设为同样大小。800m

			－Xmn 是将 NewSize 与 MaxNewSize 设为一致。320m

			－XX：PerSize 64m

			－XX：NewSize 320m 此值设大可调大新对象区，减少 Full GC 次数

			－XX：MaxNewSize 320m

			－XX：NewRato NewSize 设了可不设。

			－XX：SurvivorRatio

			－XX：userParNewGC 可用来设置并行收集

			－XX：ParallelGCThreads 可用来增加并行度

			－XXUseParallelGC 设置后可以使用并行清除收集器

			－XX：UseAdaptiveSizePolicy 与上面一个联合使用效果更好，利用它可以自动优化新域大小以及救助空间比值

		客户机：通过在 JNLP 文件中设置参数来调整客户端 JVM

			JNLP 中参数：initial-heap-size 和 max-heap-size

			这可以在 framework 的 RequestManager 中生成 JNLP 文件时加入上述参数，但是这些值是要求根据客户机的硬件状态变化的 (如客户机的内存大小等) 。建议这两个参数值设为客户机可用内存的 60％ (有待测试) 。为了在动态生成 JNLP 时以上两个参数值能够随客户机不同而不同，可靠虑获得客户机系统信息并将这些嵌到首页 index。jsp 中作为连接请求的参数。

			在设置了上述参数后可以通过 Visualgc 来观察垃圾回收的一些参数状态，再做相应的调整来改善性能。一般的标准是减少 fullgc 的次数，最好硬件支持使用并行垃圾回收 (要求多 CPU) 。


			
			
			