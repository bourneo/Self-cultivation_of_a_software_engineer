
实用基础

	
核心词汇：
	
	comma：逗号；['kɒmə]
	colon：冒号；['kəʊlən]
	exclamation：惊叹号；[,eksklə'meɪʃ(ə)n]
	apostrophe：撇号、省略号；[ə'pɒstrəfɪ]
	
	quotation marks：引号；[kwə(ʊ)'teɪʃ(ə)n]
	single quotation marks：单引号；
	double quotation marks：双引号；
	
	parenthesis：圆括号；[pə'renθɪsɪs]
	square brackets：方括号；[skweə] ['brækɪts]
	underscore：下划线；[ʌndə'skɔː]
	escape：转义，反斜杠；
	leading slash：斜杠，前倒斜杠；[slæʃ]
	
	tuple：元组；[tjʊpəl; ˈtʌpəl]
	reduce：减少；分解；归纳；[rɪ'djuːs]
	
	parameter：参数；形参；[pə'ræmɪtə]
	arguments：参数；['ɑːgjʊm(ə)nts]
	switch：开关；闸门；分流；[swɪtʃ]
	
	thread：线；螺纹；线程；[θred]
	recur：重现；循环；递归； [rɪ'kɜː]
	recursive：递归的；循环的；[rɪ'kɜːsɪv]
	allocate：分配；拨出；['æləkeɪt]
	
	wrapper：包装材料；['ræpə]
	render：补偿；['rendə]
	digit：数字；一指宽；['dɪdʒɪt] 
	
	
	inherit：继承；[ɪn'herɪt]
	coroutine：协程；[,kəuru:'ti:n]
	convention：惯例；[kən'venʃ(ə)n]
	slot：插槽；[slɒt]
	pickle：泡菜；腌制：['pɪk(ə)l]
	threshold：门槛；阈值；['θreʃəʊld; 'θreʃ,həʊld]
	realm：领域；王国；[relm]
	
	
	toggle：系紧；开关；['tɒg(ə)l]
	sibling：兄弟姊妹；同层级；['sɪblɪŋ]
	epoch：世纪；新纪元；新时代；['iːpɒk; 'epɒk]
	capitalization：用大写，资本化；[,kæpɪt(ə)laɪ'zeɪʃ(ə)n]
	Fibonacci sequence：斐波拉契数列；
	
	
	
	essence：本质、精华；['es(ə)ns]
	chaos：混沌；['keɪɒs]
	sake：目的，利益；[seɪk]
	explicit：明确的；显式；[ɪk'splɪsɪt; ek-]
	rejoice：使高兴；[rɪ'dʒɒɪs]
	swagger：吹牛；招摇；['swægə]
	
	
	giraffe：长颈鹿；[dʒɪˈrɑ:f]
	dinosaur：恐龙；['daɪnəsɔː]
	ostrich：鸵鸟；
	parrot：鹦鹉；
	
	
	January：[ 'dʒænjuəri ]
	February：[ 'februəri ]
	March：三月；[ mɑ:tʃ ]
	April：[ 'eiprəl ]
	May：[ mei, me ]
	June：[ dʒu:n ]
	July：七月；[ dʒu(:)'lai ]
	August：八月；[ 'ɔ:gəst ]
	September：九月；[ səp'tembə ]
	October：[ ɔk'təubə ]
	November：[ nəu'vembə ]
	December：[ di'sembə ]
	
	
	
	
	
	
	
	
	
	
	
	
	
词汇例句：
	fun is cheap, show me the reason and sake.
	keep away from the people who lacks common sense.
	
	
	
	
	
类型转换：
	
	包装类 转 字符串：
		String.valueOf();

	String 转 包装类：
		String 转 Integer：
			Integer.valueOf();
		String 类型转换之前，一定要对 String 进行非空判断，否则很可能报空指针异常。

	对象 转 String：
		object.toString();

	Array 转成 List：
		toArray()：
			Object[] objs = strList.toArray();
			如果要变成String数组，需要强转类型。
			String[] strs = (String[]) strList.toArray(new String[0]);
			可以指定大小：
			String[] strs = strList.toArray(new String[strList.size()]);

	List 转 Array：
		addAll()：
			String[] userid = {"aa","bb","cc"};
			List<String> userList = new ArrayList<String>();
			Collections.addAll(userList, userid);
		asList()：
			String[] userid = {"aa","bb","cc"};
			List list = new ArrayList(Arrays.asList(userid));
		asList()：
			List<String> userList = Arrays.asList(userid);
			Arrays.asList() 返回一个受指定数组支持的固定大小的列表，所以不能做Add、Remove等操作。

	String 类型转 sql.Time：
		public static java.sql.Time strToTime(String strDate) {  
			String str = strDate;
			SimpleDateFormat format = new SimpleDateFormat("HH:mm:ss");
			java.util.Date d = null;
			try {
				d = format.parse(str);
			} catch (Exception e) {
				e.printStackTrace();
			}  
			java.sql.Time time = new java.sql.Time(d.getTime());  
			return time.valueOf(str);  
		}  
		自用：
			SimpleDateFormat sdf= new SimpleDateFormat("HH:mm:ss");
			try {
				Time timeStart = new Time(sdf.parse(timeStartOrigin).getTime());
				Time timeEnd = new Time(sdf.parse(timeEndOrigin).getTime());
				goodsInfo.setTimeStart(timeStart);
				goodsInfo.setTimeEnd(timeEnd);
			} catch (ParseException exception) {
				exception.printStackTrace();
			}
			
			
JSON 工具：
	Gson 包：
		Gson gson = new Gson();
		String str = gson.toJson(nodeTree);
	fastjson 包：
		String str = JSON.toJSONString(nodeTree);
			
			
			
			
			
		
UUID：
	056085ce-8e46-492a-bcec-9a4d3690ce83
	总共 56，4 个-，8-4-4-4-12
	8 位：
		String id = UUID.randomUUID().toString();
	String[] idd=id.toString().split("-");
	String sn = idd[0];
	
	
随机数：
	Math.Random()：
		小数点 16 位；如：0.5778562302429017。
		返回带正号的 double 值，该值大于等于 0.0 且小于 1.0，
			取值范围： [0.0,1.0)，左闭右开区间；
		返回值是一个伪随机选择的数，在该范围内 (近似) 均匀分布。
		例如：
			(int)(Math.random()*171) + 30		// 30 到 200 
	
	nextInt()：
		能接受一个整数作为它所产生的随机整数的上限,下限为零。
		例如：
			new Random().nextInt (201) ;     	// 0 - 200
			new Random().nextInt (171) + 30 ; 	// 30 到 200
	
判空：
	list 判空：
		list == null || list.size() == 0
		list.isEmpty();
		
	普通对象判空：
		if (emp==null) ｛ ｝
		
	字符串判空：
		if (str != null && str.equals("")) {}
		if (str == null || str.length() <= 0){}
		if (str == null || str.isEmpty()) {}
		if (!"".equals(str)) {//将""写在前头，这样，不管name是否为null，都不会出错。}
	
	判空和判等：
		判空时，养成null在前是个好习惯；
			null==xxxx这样的写法，可以保证你不会少写=，因为你写null=xxx编译器肯定会给你报错。
			使用equals方法时，必须将非空的对象放在前面，null的对象一定不能放在前面。
　　	判等时，为了避免被判断对象可能为空，所以把肯定不为空的对象放到前面是个好习惯

	1. 集合类Array、List、Map、Set的判空：
		a.List进行判空
			//判断关联的积分项是否为空，若不为空，则插入数据库
			if(pointsItemList != null && !pointsItemList.isEmpty()){
			 // 不为空的代码处理
			}
			!= null 与 ！isEmpty()就如前辈所说的杯子与水的道理：!= null是为了判断有没有水杯；!isEmpty()是为了判断水杯里有没有水；二者合一，就能稳稳的判定pointsItemList 是否为空。

			误区：使用pointsItemLists.size() == 0, 
				List一旦初始化，就无法用.size()来处理，因为.size()是判断的元素的个数。
		b.Array进行判空
			// 判断是否为空
			public static boolean isEmptyArray(Object[] objs) {
				return (null == objs || objs.length == 0);
			}
			// 判断是否不为空
			public static boolean isNotEmptyArray(Object[] objs) {
				return !isEmptyArray(objs);
			}
		c.Map进行判空
			// 判断是否为空
			public static boolean isEmptyMap(Map<?, ?> map) {
				return (null == map || map.size() == 0);
			}
			// 判断是否不为空
			public static boolean isNotEmptyMap(Map<?, ?> map) {
				return !isEmptyMap(map);
			}
		d.Set进行判空
			// 判断是否为空
			public static boolean isEmptySet(Set<?> set) {
				return (null == set || set.size() == 0);
			}
			// 判断是否不为空
			public static boolean isNotEmptySet(Set<?> set) {
				return !isEmptySet(set);
			}
	2. String 对象的判空：
		a.判定空对象：String s = null;
			定义：
				空对象是指定义一个对象s，但是没有给该对象分配空间，即没有实例化该对象，因此，
				空对象在调用所有对象方法时候都会抛出异常，如s.length(), s.isEmpty()等方法。

			判定：
				判断一个字符变量是否是null ,使用 逻辑判断 等于(==)与null对象比较，代码表达式如下： 
				s == null;
		b.判定空值”“：String s = “”;
			定义：
				空值是指一个字符串对象已经实例化，即系统已经给该变量分配了空间，只是对象的内容为空。
			判定：
				三种方式： 
					(1) s.equals(“”)， equals方法比较的是两个对象的内容是否相同; 
					(2) s.length() == 0， length()方法是查看某个字符串对象的字符个数; 
					(3) s.isEmpty()，isEmpty()方法是判断某个字符串对象字符个数是否为0 ;
		c.判定空格” “：String s = ” “;
			定义：
				是指一个字符对象已经实例化，对象的内容为空格。
			判定：
				s.equals(” “) ;
	
		



精确运算：
	double：计算不精确，会有类似 0.0000000000000002 的误差，正确的方法是使用 BigDecimal 或者用整型；
	整型：适合于货币精度已知的情况，比如 12.11 + 1.10 转成 1211+110 计算，最后再 /100 即可；
		int：最大只能存储999999999，不到10亿的数值；
		TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT 占用存储空间分别为 1 字节、2 字节、3 字节、4 字节和 8 字节，
		就无符号的整数而言，这些类型能表示的最大整数分别为 255、65535、16777215、4294967295 和 18446744073709551615。
	DECIMAL 从MySQL 5.1 引入，列的声明语法是DECIMAL(M,D)。
		Decimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。
		在MySQL 5.1中，参量的取值范围如下：
			·M是数字的最大数（精度）。其范围为1～65（在较旧的MySQL版本中，允许的范围是1～254），M 的默认值是10。
			·D是小数点右侧数字的数目（标度）。其范围是0～30，但不得超过M。
		说明：float占4个字节，double占8个字节，decimail(M,D)占M+2个字节。
	BigDecimal方法：
		BigDecimal b1 = new BigDecimal(Double.toString(value1));
		BigDecimal b2 = new BigDecimal(Double.toString(value2));
		return b1.add(b2).doubleValue();
		return b1.subtract(b2).doubleValue();
		return b1.multiply(b2).doubleValue();
		提供（相对）精确的除法运算，当发生除不尽的情况时， 精确到小数点以后10位，以后的数字四舍五入。
			return divide(dividend, divisor, DEF_DIV_SCALE);
		提供（相对）精确的除法运算。 当发生除不尽的情况时，由scale参数指定精度，以后的数字四舍五入。
			return b1.divide(b2, scale,RoundingMode.HALF_UP).doubleValue();
		供指定数值的（精确）小数位四舍五入处理。
			return b.divide(one,scale, RoundingMode.HALF_UP).doubleValue();

位运算：
	>、>>、>>> 的区别：
		> ：大于；
			如：if(a>b)...结果是boolean类型
		>> ：带符号右移；
			如：int i=15; i>>2的结果是3，移出的部分将被抛弃。
			转为二进制的形式可能更好理解，0000 1111(15)右移2位
			结果是0000 0011(3)，0001 1010(18)右移3位的结果是0000 0011(3)。

		>>>：无符号右移；
			按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。
			对于正数来说和带符号右移相同，对于负数来说不同。
			其他结构和>>相似。
		
	位运算符：
		~ ：按位非（NOT）（一元运算） 
		& ：按位与（AND） 
		| ：按位或（OR） 
		^ ：按位异或（XOR） 
		>> ：右移 
		>>> ：右移，左边空出的位以0填充 
		<< ：左移 
		&= ：按位与赋值 
		|= ：按位或赋值 
		^= ：按位异或赋值 
		>>= ：右移赋值 
		>>>= ：右移赋值，左边空出的位以0填充 
		<<= ：左移赋值
	
多态与覆盖：
	因为覆盖，所以多态。
		方法重写之后就有了多态。

	
控制台输出：
	private static Log log = LogFactory.getLog(TfSupermxInfoDao.class);
	log.debug("操作子表：" + sb);
	
	
	static Logger log = LoggerFactory.getLogger(this.getClass());
	log.trace("这是rrace日志。。。");
	
	
	static Logger logger = LoggerFactory.getLogger(this.class);
	
	static Logger LOG= Logger.getLogger(this.class);
	
	static Logger logger = Logger.getLogger(Object.class);
	
	
	
	
	
	
	
	
	
	
	
	
	
