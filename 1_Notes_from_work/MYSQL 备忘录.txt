
MYSQL 工作笔记


聚合函数中加入条件：
	sum()：
		case when d.STATUS=7 then d.GOODS_PAYMENT else 0 end
	count()：
		if(d.STATUS=7,true,null)
	
in 和 not in 查询：
	in 后面的结果里只能包含一个字段，字段里面可以有多个值；
	in 前面只能包含一个字段；
		如 where userIds in(0,7,8)。
	
日期计算：
	NOW()；
	interval + 时间；
		SELECT * FROM 表名 WHERE 字段名>NOW()-INTERVAL 2 HOUR;
		SELECT * FROM 表名 WHERE 字段名 > DATE_SUB(NOW(), INTERVAL 60 MINUTE);
	
子查询的子表必须要有别名。
	
字段去重：
	DISTINCT 字段。	
	
limit：
	如果只给定一个参数，它表示返回最大的记录行数目： 
	SELECT * FROM table LIMIT 5; //检索前 5 个记录行
	也就是说：LIMIT n 等价于 LIMIT 0,n

	为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： 
	SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.
	
	常用的用法：
	SELECT * FROM table LIMIT 5,10; // 检索记录行 第 6 行至第 15 行的数据
	
TIMESTAMP 默认值：
	1，TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录和修改现有记录的时候都对这个数据列刷新

	2，TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为当前时间，但以后修改时，不再刷新它

	3，TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为 0，以后修改时刷新它

	4，TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss’ ON UPDATE CURRENT_TIMESTAMP 
		在创建新记录的时候把这个字段设置为给定值，以后修改时刷新它
	
	
	
drop、truncate 和 delete：

	1、drop table tb 
		drop 将表格直接删除，没有办法找回
	2、truncate (table) tb
		删除表中的所有数据，不能与 where 一起使用
	3、delete from tb (where)
		删除表中的数据 (可制定某一行)
		
	truncate 和 delete ：
		1、事务：truncate 是不可以 rollback 的，但是 delete 是可以 rollback 的；
			原因：truncate 删除整表数据 (ddl 语句, 隐式提交)，delete 是一行一行的删除，可以 rollback
		2、效果：truncate 删除后将重新水平线和索引 (id 从零开始) ,delete 不会删除索引；
		3、truncate 不能触发任何 Delete 触发器；
		4、delete 删除可以返回行数；

	
分组取最新的一条记录：
	多条最新：
		select * from (select * from t_assistant_article order by create_time desc) as a group by base_id
		SELECT * from (SELECT * from model_online_forecastscore_phone0001 ORDER BY id DESC) as cn GROUP BY cn.mobile
	单条最新：
		SELECT * from model WHERE (1 = 1) GROUP BY u.id ORDER BY field(u.state, 1, 2, 3) 
			GROUP BY 和 ORDER BY 一起使用时，ORDER BY 要在 GROUP BY 的后面。 
		SELECT *, ABS(NOW() - startTime)  AS diffTime FROM PolicyShuPrice ORDER BY diffTime ASC LIMIT 0, 1
	
	
MySQL 8 递归查询

	递归公用表表达式(CTE)是一个具有引用CTE名称本身的子查询的CTE。
	以下说明递归CTE的语法：
		WITH RECURSIVE cte_name AS (
			initial_query  -- anchor member
			UNION ALL
			recursive_query -- recursive member that references to the CTE name
		)
		SELECT * FROM cte_name;
	SQL递归CTE由三个主要部分组成：
		形成CTE结构的基本结果集的初始查询(initial_query)，初始查询部分被称为锚成员。
		递归查询部分是引用CTE名称的查询，因此称为递归成员。
			递归成员由一个UNION ALL或UNION DISTINCT运算符与锚成员相连。
		终止条件是当递归成员没有返回任何行时，确保递归停止。
	递归CTE的执行顺序如下：
		首先，将成员分为两个：锚点和递归成员。
		接下来，执行锚成员形成基本结果集(R0)，并使用该基本结果集进行下一次迭代。
		然后，将Ri结果集作为输入执行递归成员，并将Ri+1作为输出。
		之后，重复第三步，直到递归成员返回一个空结果集，换句话说，满足终止条件。
		最后，使用UNION ALL运算符将结果集从R0到Rn组合。
	
	例如：
		WITH RECURSIVE cte_name AS
		(
				SELECT
					FCODE,
					FNAME,
					FPCODE,
					FCODEKEY,
					FCUSER,
					FCDATE,
					FMUSER,
					FMDATE
				FROM
					t_commom_area A
				WHERE
					FPCODE = null
			UNION ALL
				SELECT
					K.FCODE,
					K.FNAME,
					K.FPCODE,
					K.FCODEKEY,
					K.FCUSER,
					K.FCDATE,
					K.FMUSER,
					K.FMDATE
				FROM
					t_commom_area K
				INNER JOIN cte C ON C.FCODE = K.FPCODE
		)
		SELECT
			FCODE,
			FNAME,
			FPCODE,
			FCODEKEY,
			FCUSER,
			FCDATE,
			FMUSER,
			FMDATE
		FROM
			t_commom_area cte_name
		WHERE
			FCODE != ''
			OR FNAME != ''
			OR FCODEKEY != ''
	例如：
		with RECURSIVE cte as
		(
		select a.id,cast(a.name as varchar(100)) from tb a where id='002'
		union all 
		select k.id,cast(c.name||'>'||k.name as varchar(100)) as name  from tb k 
		inner join cte c on c.id = k.pid
		)select id,name from cte ;
	
	
	
	
	
getPublicGoodsType
	
addShoppingCart
	
	
	string exist="select * from product where name='A'" --查询数据库中有没有商品
if exist <> null --数据库中有 A 产品
string sql="update product set num=num+2"; 设置 A 的数量加上 2
	


MYSQL 中 TIMESTAMP 类型的默认值理解

	MYSQL 中 TIMESTAMP 类型可以设定默认值，就像其他类型一样。

	1、自动 UPDATE 和 INSERT 到当前的时间：
	表：
	———————————

	Table Create Table 
	—— ————————————————————————————-
	t1 CREATE TABLE `t1` ( 
			 `p_c` int(11) NOT NULL, 
			 `p_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
			) ENGINE=InnoDB DEFAULT CHARSET=gb2312 

	数据：

	1 2017-04-17 11:53:35
	2 2017-04-17 11:54:00

	insert into t1(p_c) select 3;
	update t1 set p_c = 2 where p_c = 5;

	数据：

	1 2017-04-17 11:53:35
	5 2017-04-17 12:00:37
	3 2017-04-17 12:00:37

	2、自动 INSERT 到当前时间，不过不自动 UPDATE。

	表：
	———————————

	Table Create Table 
	—— ———————————————————
	t1 CREATE TABLE `t2` ( 
			 `p_c` int(11) NOT NULL, 
			 `p_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP 
			) ENGINE=InnoDB DEFAULT CHARSET=gb2312 

	数据：
	insert into t2(p_c) select 4;
	update t2 set p_c = 3 where p_c = 5;

	1 2017-04-17 11:53:35
	2 2017-04-17 12:00:37
	5 2017-04-17 12:00:37
	4 2017-04-17 12:05:19

	3、一个表中不能有两个字段默认值是当前时间，否则就会出错。不过其他的可以。
	表：
	———————————

	Table Create Table 
	—— —————————————————————
	t1 CREATE TABLE `t1` ( 
			 `p_c` int(11) NOT NULL, 
			 `p_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, 
			 `p_timew2` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' 
			) ENGINE=InnoDB DEFAULT CHARSET=gb2312 

	数据：
	1 2017-04-17 11:53:35 0000-00-00 00:00:00
	2 2017-04-17 12:00:37 0000-00-00 00:00:00
	3 2017-04-17 12:00:37 0000-00-00 00:00:00
	4 2017-04-17 12:05:19 0000-00-00 00:00:00

	TIMESTAMP 的变体
		1，TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录和修改现有记录的时候都对这个数据列刷新

		2，TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为当前时间，但以后修改时，不再刷新它

		3，TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为 0，以后修改时刷新它

		4，TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss’ ON UPDATE CURRENT_TIMESTAMP 
		在创建新记录的时候把这个字段设置为给定值，以后修改时刷新它












