

SQL 备忘




聚合函数中加入条件：
	sum()：
		case when d.STATUS=7 then d.GOODS_PAYMENT else 0 end
	count()：
		if(d.STATUS=7,true,null)
	
in 和 not in 查询：
	in 后面的结果里只能包含一个字段，字段里面可以有多个值；
	in 前面只能包含一个字段；
		如 where userIds in(0,7,8)。

Mybatis 迭代数组：
	<foreach collection="userIds" index="index" item="item" open="(" separator="," close=")">
		#{item}
	</foreach>
	
日期计算：
	NOW()；
	interval + 时间；
		SELECT * FROM 表名 WHERE 字段名>NOW()-INTERVAL 2 HOUR;
		SELECT * FROM 表名 WHERE 字段名 > DATE_SUB(NOW(), INTERVAL 60 MINUTE);
	
子查询的子表必须要有别名。
	
字段去重：
	DISTINCT 字段。	
	
limit：
	如果只给定一个参数，它表示返回最大的记录行数目： 
	SELECT * FROM table LIMIT 5;     //检索前 5 个记录行
	也就是说：LIMIT n 等价于 LIMIT 0,n

	为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： 
	SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.
	
	常用的用法：
	SELECT * FROM table LIMIT 5,10;  // 检索记录行 第6行至第15行的数据
	
TIMESTAMP 默认值：
	1，TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录和修改现有记录的时候都对这个数据列刷新

	2，TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为当前时间，但以后修改时，不再刷新它

	3，TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
		在创建新记录的时候把这个字段设置为0，以后修改时刷新它

	4，TIMESTAMP DEFAULT ‘yyyy-mm-dd hh:mm:ss’ ON UPDATE CURRENT_TIMESTAMP 
		在创建新记录的时候把这个字段设置为给定值，以后修改时刷新它
		
TRUNCATE() 函数：
	truncate(number, 2);	截取到小数点后2位
	TRUNCATE(X,D)
		X 表示需要处理的数字，D 表示需要截取的位数。如果 D 为零，则返回的数字不含小数。D 也可以是负数，这样会把整数的部分置零。
		示例如下：
			mysql> SELECT TRUNCATE(1.223,1);
			-> 1.2
			mysql> SELECT TRUNCATE(1.999,1);
			-> 1.9
			mysql> SELECT TRUNCATE(1.999,0);
			-> 1
			mysql> SELECT TRUNCATE(-1.999,1);
			-> -1.9
			mysql> SELECT TRUNCATE(122,-2);
			-> 100
			mysql> SELECT TRUNCATE(10.28*100,0);
			-> 1028
	
	
	
当月查询：
	where MONTH(CREATE_TIME) = MONTH(now()) and YEAR(CREATE_TIME)=YEAR(NOW())
	
	
当日查询：
	where TO_DAYS(CREATE_TIME)=TO_DAYS(NOW())
	where DATE(CREATE_TIME) = CURDATE()
	where YEAR(CREATE_TIME) = YEAR(now()) and MONTH(CREATE_TIME) = MONTH(now()) and DAY(CREATE_TIME) = DAY(NOW())
	
	
	
	
	
	
	
	
	
	
	
	<!-- 统计用户消费数据 -->
	<select id="getUserConsumptionData" resultType="java.util.HashMap">
	    select 
		u.REAL_NAME, 
		u.WX_BIND_PHONE, 
		sum(case when d.STATUS=7 then d.GOODS_PAYMENT else 0 end ) as PAYMENTS, 
		count(if(d.STATUS=7,true,null)) AS PAYMENT_COUNT, 
		s.STORE_NAME, 
		u.SEX, 
		sum(case when d.STATUS=6 then d.REFUND_MONEY else 0 end ) as REFUNDS, 
		count(if(d.STATUS=6,true,null)) AS REFUND_COUNT 
		from 
		t_store_user u, 
		t_goods_order_detail d, 
		t_goods_order o, 
		t_app_store s 
		where 
		u.USER_ID=o.USER_ID and 
		s.PRIID=o.app_store_id and 
		d.ORDER_ID=o.ORDER_ID 
		and o.instance_id = #{instanceId} 
		GROUP BY WX_BIND_PHONE 
		order by PAYMENTS desc 
		limit #{index}, #{rows} 
    </select>

	<select id="getRecommendGoodsAll" resultMap="NewGoodsMap">
		select n.GOODS_ID, n.GOODS_IMAGE, n.GOODS_NAME, n.MARKET_PRICE, n.GROUNDING_TIME, 
		a.RECOMMEND_ORDER as base_num, 
		a.GOODS_ACTIVITY_PRIID as SERVICE_ID, 
		a.ACTIVITY_PRICE as SELL_PRICE, 
		a.ACTIVITY_ID as SUPPLIER_ID 
		from t_new_goods n, t_goods_activity a 
		where a.RECOMMEND_STATUS > 0 
		and n.GOODS_ID = a.GOODS_ID 
		order by base_num desc 
	</select>



not in 子查询：
in 后面的结果里只能包含一个字段。

	WHERE  IN 
	<foreach collection="userIds" index="index" item="item" open="(" separator="," close=")">
		#{item}
	</foreach>

	<!-- 团长销售额销售量排名 -->
	<select id="getStoreSalesRank" resultMap="StoreAppMap">
		select s.PRIID, u.HEADIMGURL, u.USER_NAME as CONTACTS, sum(o.SETTLEMENT_AMOUNT) as REBATE_RATE, sum(o.SHOPPING_NUM) as REBATE_VALID, s.STORE_NAME, s.STORE_ADDRESS 
		from t_goods_order o, t_app_store s, t_mall_user u 
		where o.ORDER_STATUS not in(0,7,8) 
		and o.app_store_id = s.PRIID 
		and s.STORE_MALL_ID = u.OPEN_ID 
		and o.instance_id = #{instanceId} 
		group by PRIID 
		order by REBATE_RATE DESC 
	</select>

	
	select * 
	from t_label
	where LABEL_ID not in (
		select a.LABEL_ID 
		from t_label a, t_goods_label g 
		where g.GOODS_ID = 83336 
		and a.LABEL_ID = g.LABEL_ID 
	)
	order by CREATE_TIME desc

	select * 
	from t_label t 
	where t.LABEL_ID not in (
		select a.LABEL_ID 
		from t_label a, t_goods_label g 
		where g.GOODS_ID = 83336
		and a.LABEL_ID = g.LABEL_ID 
	)
	order by CREATE_TIME desc
	
	select
	<include refid="Base_Column_List" />
	,
	<include refid="Blob_Column_List" />
	from t_label t 
	where t.LABEL_ID not in (
		select a.LABEL_ID 
		from t_label a, t_goods_label g 
		where g.GOODS_ID = #{goodsId,jdbcType=BIGINT} 
		and a.LABEL_ID = g.LABEL_ID 
	)
	order by CREATE_TIME desc


查询标签表和中间表

	根据商品id 查询标签名：
	select a.LABEL_NAME 
	from t_label a, t_goods_label g
	where g.GOODS_ID = #{goodsId,jdbcType=BIGINT}
	and a.LABEL_ID = g.LABEL_ID 
	order by a.CREATE_TIME desc


	select a.LABEL_ID, a.LABEL_NAME 
	from t_label a, t_goods_label g
	where g.GOODS_ID = 83336
	and a.LABEL_ID = g.LABEL_ID 
	order by a.CREATE_TIME desc

	根据标签id 查询商品：
	select * 
	from t_goods_label a, t_new_goods g
	where a.LABEL_ID = #{labelId,jdbcType=BIGINT}
	and a.GOODS_ID = g.GOODS_ID
	order by g.CREATE_TIME desc
	
	select * 
	from t_goods_label a, t_new_goods g
	where a.LABEL_ID = 15
	and a.GOODS_ID = g.GOODS_ID
	order by g.CREATE_TIME desc
	
	
取消配送单

	删除
		t_distribute_detail
		中的
		prid 相等的记录

	修改
		t_goods_order
		中的
		FAST_STATUS 为 1 待发货

		修改
		t_goods_order_detail
		中的
		STATUS 为 1 已向供应商下单
		DISTRIBUTE_NUM 为 null

	UPDATE t_goods_order o, t_goods_order_detail d 
	SET o.ORDER_STATUS=1, d.STATUS=0, d.DISTRIBUTE_NUM="" 
	WHERE o.ORDER_ID=d.ORDER_ID 
	AND d.DISTRIBUTE_NUM="2018081046327" 
	AND o.app_store_id=10 
	AND d.goods_id=83672 
	AND d.GOODS_CONTENT="B款约12只"

	String distributeNum
	int appStoreId
	int goodsId
	String goodsContent

	UPDATE t_goods_order o, t_goods_order_detail d 
	SET o.ORDER_STATUS=1, d.STATUS=0, d.DISTRIBUTE_NUM="" 
	WHERE o.ORDER_ID=d.ORDER_ID 
	AND d.DISTRIBUTE_NUM=#{distributeNum}
	AND o.app_store_id=#{appStoreId} 
	AND d.goods_id=#{goodsId} 
	AND d.GOODS_CONTENT=#{goodsContent}

	select * 
	from t_goods_order o, t_goods_order_detail d 
	WHERE o.ORDER_ID=d.ORDER_ID 
	AND d.DISTRIBUTE_NUM="2018081046327" 
	AND o.app_store_id=10 
	AND d.goods_id=83672 
	AND d.GOODS_CONTENT="B款约12只"


查询半个小时之内的订单信息：

	SELECT * 
	FROM t_goods_order 
	WHERE PAY_MONEY_TIME 
	BETWEEN DATE_SUB(NOW(), INTERVAL 30 MINUTE) AND NOW() 
	ORDER BY PAY_MONEY_TIME DESC;

	select * 
	from t_goods_order 
	where PAY_MONEY_TIME >= DATE_SUB(NOW(),INTERVAL 30 MINUTE);

	select * 
	from t_goods_order 
	where PAY_MONEY_TIME >= DATE_SUB(NOW(),INTERVAL 30 MINUTE);




TRUNCATE、Drop、Delete区别：
 
	1.drop和delete只是删除表的数据(定义),drop语句将删除表的结构、被依赖的约束(constrain)、触发器 (trigger)、索引(index);依赖于该表的存储过程/函数将保留,但是变为invalid状态。
	2.delete语句是DML语言,这个操作会放在rollback segement中,事物提交后才生效;如果有相应的触发器(trigger),执行的时候将被触发。truncate、drop是DDL语言,操作后即 生效,原数据不会放到rollback中,不能回滚,操作不会触发trigger。

	3.delete语句不影响表所占用的extent、高水线(high watermark)保持原位置不动。drop语句将表所占用的空间全部释放。truncate语句缺省情况下将空间释放到minextents的 extent,除非使用reuse storage。truncate会将高水线复位(回到最初)。

	4.效率方面:drop > truncate > delete

	5.安全性:小心使用drop与truncate,尤其是在 没有备份的时候,想删除部分数据可使用delete需要带上where子句,回滚段要足够大,想删除表可以用drop,想保留表只是想删除表的所有数据、 如果跟事物无关可以使用truncate,如果和事物有关、又或者想触发 trigger,还是用delete,如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入、插入数据。

	6.delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。

	7、drop一般用于删除整体性数据 如表，模式，索引，视图，完整性限制等；delete用于删除局部性数据 如表中的某一元组

	8、DROP把表结构都删了；DELETE只是把数据清掉

	9、当你不再需要该表时， 用 drop；当你仍要保留该表，但要删除所有记录时， 用 truncate；当你要删除部分记录时（always with a WHERE clause), 用 delete.


jdbc.url=jdbc\:mysql\://47.97.211.254:3306/dmz_test?useUnicode\=true&characterEncoding\=UTF-8&allowMultiQueries\=true&autoReconnect\=true&verifyServerCertificate=false&useSSL=true




