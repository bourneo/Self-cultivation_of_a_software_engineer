
元注解


自定义注解

	@interface 注解

		注释类型的定义跟定义一个接口相似，我们需要在 interface这个关键字前面加上一个@符号，即@interface。
		注释中的每一个方法定义了这个注释类型的一个元素，注释中方法的声明中一定不能包含参数，也不能抛出异 常；
		方法的返回值被限制为简单类型、String、Class、emnus、注释，和这些类型的数组。
		方法可以有一个缺省值。

		一旦定义好了一个注释类型，你就可以用来作注释声明。
		注释一中特殊的修饰符，在其他修饰符（比如public，static，或者final等） 使用地方都可以使用。
		按照惯例，注释应该放在其他修饰符的前面。注释的声明用@符号后面跟上这个注释类型的名字，再后面跟上括号，括号中列出这个注释中元 素/方法的key－value对。值必须是常量。


	@Retention 注解

		Reteniton的作用是定义被它所注解的注解保留多久，
		一共有三种策略，定义在RetentionPolicy枚举中
			public enum RetentionPolicy {
				SOURCE,
				CLASS,
				RUNTIME
			}

		SOURCE
			被编译器忽略

		CLASS
			注解将会被保留在Class文件中，但在运行时并不会被VM保留。
			这是默认行为，所有没有用Retention注解的注解，都会采用这种策略。

		RUNTIME
			保留至运行时。所以我们可以通过反射去获取注解信息。

		Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:
			1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略
			2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略
			3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.


	@Target
		
		@Target 说明了 Annotation 所修饰的对象范围：Annotation 可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。
		在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。

	　　作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）

	　　取值(ElementType)有：

	　　　　1.CONSTRUCTOR:用于描述构造器
	　　　　2.FIELD:用于描述域
	　　　　3.LOCAL_VARIABLE:用于描述局部变量
	　　　　4.METHOD:用于描述方法
	　　　　5.PACKAGE:用于描述包
	　　　　6.PARAMETER:用于描述参数
	　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
		
		
	@Repeatable
		
		Repeatable 被此注解修饰的注解是可以重复的。
		
		
		
	@Expose
	
		@Expose 注解的作用：
			区分实体中不想被序列化的属性，
			其自身包含两个属性deserialize(反序列化)和serialize（序列化），
			默认都为true。

		使用 new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		创建 Gson 对象，没有 @Expose 注释的属性将不会被序列化。


		@SerializedName注解的作用：定义属性序列化后的名称
		
		另外想要不序列化某个属性，也可以使用transient。


	@Inherited
	
		@Inherited：允许子类继承父类的注解。
		对注解使用元注解 Inherited 声明出的注解，
		在使用时用在类上，可以被子类所继承，
		对属性或方法无效。


	@Documented

		Documented 注解表明这个注解应该被 javadoc工具记录. 
		默认情况下,javadoc是不包括注解的. 
		但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 
		所以注解类型信息也会被包括在生成的文档中. 














