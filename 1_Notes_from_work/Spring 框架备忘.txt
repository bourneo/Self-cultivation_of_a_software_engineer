
Spring 框架


Spring 核心
	是什么：
		提供 依赖注入 的容器框架；
	为什么使用：
		可以创建和维护 Bean 之间的关系；可以管理表现层、服务层、持久层，并且维护各层之间的关系。
	基本原理：
		IOC 容器：
		AOP 切面：
		启动过程：
	怎么使用：
		配置核心配置文件的路径；
		配置核心配置文件；
		
		
	Spring 依赖注入的三种方式：
		interface：
			@Resource
			private UserService userService;
		setter：
			private UserDao userDao;
			@Resource
			public void setUserDao(UserDao userDao) {
				super.setBaseDao(userDao);
				this.userDao = userDao;
			}
		constructor：
			private DataBase db; 
			public Business (DataBase db) { 
			this.db = db; 
			} 

Spring 对 json 数据转换成对象的处理
	
	一：@RequestBody

		面对前端传输过来的 json 数据，通过该注解可以让它自动装配成 map 对象或自定义对象 (前提要用二中的注解先作匹配) 


	二：@JsonProperty(value = "register_id")
	 1：在实体类中：

		 @JsonProperty(value = "register_id")

		 private String registerId;
	 2：在浏览器前端输入 json 格式：

		 {

		 "register_id":"12345"

		 }
		
	后台可以使用 @ModelAttribute 、 @RequestBody 

	 都是根据被转换的对象的字段依次从请求参数中获取对应的字段设置值。


	前端有所不同：

	data 一个要的 json 字符串，一个是 json 对象

	 1. @RequestBody 

		$.ajax({
		 type: "post",
		 contentType: 'application/json;charset=UTF-8', //必须这么写； 表示传递的参数 是 json 类型的 
		 dataType:'json',//非必须
		 data: JSON.stringify({ //必须转换为 json 字符串传递，要直接传该字符，否则就是错误。
			userName: 'xxx'
		 } ),
		 url: 'user/save',
		 success: function (res) {
			console.log(res);
		 }

	 });


	 2. @ModelAttribute 

		$.ajax({

		 type: "post",

	// contentType: 'application/x-www-form-urlencoded;charset=UTF-8',//这是默认的 请求类型
		 data: { //必须转换为 json 字符串，直接传 json
			userName: 'xxx'
		 } ,
		 url: 'user/save',
		 success: function (res) {
			console.log(res);
		 }

	 });
		
		
	@requestbody 
		放在 controller 层有 @requestmapping 注解的方法参数前面的注解，
			例如：
				@RequestMapping(value = "user/login")
				@ResponseBody
				// 将 ajax (datas) 发出的请求写入 User 对象中
				public User login(@RequestBody User user) { 
				// 这样就不会再被解析为跳转路径，而是直接将 user 对象写入 HTTP 响应正文中
				 return user; 
				}
	@jsonproperty 是放在实体类参数上的注解，
		该注解的目的是为了让前台穿过来的 json 数据按照 @jsonproperty 注释过的实体类的格式拼装成一个跟实体类一样的对象 这样间接实现了前台传输对象到后台 (该对象是通过注解拼装而成的) 
	
	
	
	
	
	
	
	
	
	
	
		
Spring 基本概念
	BOP (Bean Oriented Programming)：面向 Bean 的编程；
	POJO (Plain Old Java Object)：普通 Java™ 对象；
	DI (Dependency Injection) ：依赖注入；
	IoC (Inversion of Control) ：控制倒转
	AOP (Aspect-Oriented Programming) ：面向切面编程。
	
	1) spring 是容器框架，创建 bean，维护 bean 之间的关系；truts2 是 web 框架，hibernate 是 orm 框架；
	2) spring 可以管理 web 层，业务层，dao 层，spring 可以配置各个层的组件，并且维护各个层的关系。

	Bean 和 Bean 之间的合作关系既然不写在代码中，那这些信息保存在哪里？
		IoC 是将 Bean 之间的依赖关系告诉容器，让容器统一管理。
		而这个告诉的方式一定不是以代码的形式 (如果是这样，就不需要这个框架了) 。
		所以可能的方式是：一个文件，一个外部资源，一个 URI。反正它一定存在于 Java 运行时之外的。
		既然在内存之外，我们就需要将它以流的方式读入内存，然后对它做一定的封装，使我们可以读取这些内容的信息，然后处理。
	
	容器是什么：
		容器当然是一个全局对象。而我们能通过 getBean 方法从它手中获得一个 Bean，它应该有个 map 保存这些 beans。
		第一步从外部读取的信息，最终处理的结果就是存放到这个 map 里。

	两个设计主线：
		BeanFactory：
			只定义最简单的 IoC 容器的基本功能。如 getBean。
		ApplicationContext：
			ApplicationContext 继承 BeanFactory，也就是它也是 IoC 容器，只是它的功能更丰富：
				它同时继承 ResourcePatternResolver，MessageSource 等接口，是高级容器。
				
	Spring 到底是怎么运行的：
		首先，我们定义一个 Bean 类，这个类用来存放一个 Bean 拥有的属性；
			一个 Bean 包括 id,type, 和 Properties。
		接下来 Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个 HashMap 中，
			HashMap 的 key 就是 Bean 的 Id，HasMap 的 value 是这个 Bean，
			只有这样我们才能通过 context.getBean("animal") 这个方法获得 Animal 这个类。
			我们都知道 Spirng 可以注入基本类型，而且可以注入像 List，Map 这样的类型，
		其实依赖注入的思想也很简单，它是通过反射机制实现的，在实例化一个类时，
			它通过反射调用类中 set 方法将事先保存在 HashMap 中的类属性注入到类中。
		最后它将这个类的实例返回给我们，我们就可以用了。

	Spring 启用注解 (通常有两种方式)：
		1. 在 Spring 配置文件中的<beans>标签中配置
			<context:annotation-config />
			通过这种配置方式可使整个项目中的 Spring 注解生效
		2. 在<beans>标签里配置扫描的包名
			<context:component-scan base-package=”com.veegn”>
			这样可使指定包目录下的 Spring 注解生效


	Spring 事务：
	
		Propagation （事务的传播属性）
		
		Propagation：key属性确定代理应该给哪个方法增加事务行为。
			这样的属性最重要的部份是传播行为。
			有以下选项可供使用：
			
				PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

				PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。

				PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。

				PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起。

				PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

				PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常。		

		Isolation Level(事务隔离等级):
		
			1、Serializable：最严格的级别，事务串行执行，资源消耗最大；

			2、REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。

			3、READ COMMITTED:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。

			4、Read Uncommitted：保证了读取过程中不会读取到非法数据。隔离级别在于处理多事务的并发问题。
		
		
		并发中可能发生的3中不讨人喜欢的事情：

			1： Dirty reads--读脏数据。
				也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，
				如果事务A失败回滚，会导致事务B所读取的的数据是错误的。

			2： non-repeatable reads--数据不可重复读。
				比如事务A中两处读取数据-total-的值。
				在第一读的时候，total是100，然后事务B就把total的数据改成 200，事务A再读一次，
				结果就发现，total竟然就变成200了，造成事务A数据混乱。

			3： phantom reads--幻象读数据，这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。
				但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），
				但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。
				比如Select account.id where account.name="ppgogo*",第一次读去了6个符合条件的id，
				第二次读取的时候，由于事务b把一个帐号的名字由"dd"改成"ppgogo1"，结果取出来了7个数据。
		
		
		



		
Spring 核心原理

	1.IOC 控制反转

		概念：控制权由对象本身转向容器，由容器根据配置文件创建对象实例，并实现各个对象的依赖关系。
		核心：bean 工厂

		内部最核心的就是 IOC，动态注入，让一个对象的创建不用 new 了，可以自动的生产；
		这其实就是利用 java 里的反射，反射其实就是在运行时动态的去创建、调用对象，
		Spring 就是在运行时，跟 xml Spring 的配置文件来动态的创建对象，和调用对象里的方法的。

	2.AOP 面向切面编程

		Spring 还有一个核心就是 AOP 这个就是面向切面编程，可以为某一类对象 进行监督和控制 (也就是 在调用这类对象的具体方法的前后去调用你指定的 模块) 从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。

		a. 静态代理

			就是通过接口继承复用的方式来完成的，代理类与被代理对象实现相同的接口，
			然后代理类里面会拥有一个被代理对象，代理类与被代理对象相同的方法，活调用被代理对象的方法，
			不过中间会加以限制，您翻开任何一本设计模式相关的书，翻到代理模式这一节，讲的就是它了。

			根据每个具体类分别编写代理类
			根据一个接口编写一个代理类

		b. 动态代理

			动态代理就是允许我们在程序运行过程中，为动态生成的对象，动态的生成代理。显然，这比静态代理灵活太多了。
			Java 默认提供了动态代理的实现方式，但是有限制，它要求被代理对象必须实现某一个接口。
			为了突破这一限制，为普通类也可以提供代理，CGLib 这个库横空出世。
			CGLib：针对一个方面编写一个 InvocationHandler，然后借用 JDK 反射包中的 Proxy 类为各种接口动态生成相应的代理类
			动态代理：
				不用写代理类，虚拟机根据真实对象实现的接口产生一个类，
				通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，
				当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的 Method, 调用装备的 invoke 方法，
				将动态代理、 Method、方法参数传与装备的 invoke 方法，invoke 方法在唤起 method 方法前或后做一些处理。
					 1、产生动态代理的类：
						java.lang.refect.Proxy
					 2、装备必须实现 InvocationHandler 接口实现 invoke 方法

		 

Spring 原理小结

	1. 使用 spring，没有 new 对象，我们把创建对象的任务交给 spring 框架
	2. spring 实际上是一个容器框架，可以配置各种 bean (action/service/domain/dao)，
		并且可以维护 bean 与 bean 的关系，当我们需要使用某个 bean 的时候，我们可以 getBean(id)，使用即可.

	Spring 目的：
		让对象与对象 (模块与模块) 之间的关系没有通过代码来关联，
		都是通过配置类说明管理的 (Spring 根据这些配置 内部通过反射去动态的组装对象) 

	Spring 是一个容器，凡是在容器里的对象才会有 Spring 所提供的这些服务和功能。
	Spring 里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)，
	Spring 里的配置是很多的，很难都记住，但是 Spring 里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了 Spring.

	


Spring 框架的架构
	Spring 框架是一个分层架构，由 7 个定义良好的模块组成。
		Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，
		组成 Spring 框架的每个模块 (或组件) 都可以单独存在，或者与其他一个或多个模块联合实现。
	
	每个模块的功能如下：

		核心容器：
			核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。
			BeanFactory 使用控制反转 (IOC) 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。

		Spring 上下文：
			Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。
			Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。

		Spring AOP：
			通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。
			所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。
			Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。
			通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。

		Spring DAO：
			JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。
			异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量 (例如打开和关闭连接) 。
			Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。

		Spring ORM：
			Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。
			所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。

		Spring Web 模块：
			Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。
			所以，Spring 框架支持与 Jakarta Struts 的集成。
			Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。

		Spring MVC 框架：
			MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。
			通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

	
Spring 七大模块

	1. Spring Core： Core 封装包是框架的最基础部分，提供 IOC 和依赖注入特性。这里的基础概念是 BeanFactory，它提供对 Factory 模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。

	2.Spring Context: 构建于 Core 封装包基础上的 Context 封装包，提供了一种框架式的对象访问方法，有些象 JNDI 注册器。Context 封装包的特性得自于 Beans 封装包，并添加了对国际化 (I18N) 的支持 (例如资源绑定) ，事件传播，资源装载的方式和 Context 的透明创建，比如说通过 Servlet 容器。

	3．Spring DAO: DAO (Data Access Object) 提供了 JDBC 的抽象层，它可消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码。并且，JDBC 封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的 POJOs (plain old Java objects) 都适用。

	4.Spring ORM: ORM 封装包提供了常用的“对象/关系”映射 APIs 的集成层。其中包括 JPA、JDO、Hibernate 和 iBatis。利用 ORM 封装包，可以混合使用所有 Spring 提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。

	5.Spring AOP: Spring 的 AOP 封装包提供了符合 AOP Alliance 规范的面向方面的编程实现，让你可以定义，例如方法拦截器 (method-interceptors) 和切点 (pointcuts) ，从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用 source-level 的元数据功能，还可以将各种行为信息合并到你的代码中。

	6.Spring Web: Spring 中的 Web 包提供了基础的针对 Web 开发的集成特性，例如多方文件上传，利用 Servlet listeners 进行 IOC 容器初始化和针对 Web 的 ApplicationContext。当与 WebWork 或 Struts 一起使用 Spring 时，这个包使 Spring 可与其他框架结合。

	7.Spring Web MVC: Spring 中的 MVC 封装包提供了 Web 应用的 Model-View-Controller (MVC) 实现。Spring 的 MVC 框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和 Web Form 之间。并且，还可以借助 Spring 框架的其他特性。



Spring 的核心接口及核类配置文件：
	FactoryBean：工厂 bean 主要实现 ioc/di
	ApplicationContext ac=new FileXmlApplicationContext("applicationContext.xml");
	Object obj=ac.getBean("id 值");

Spring 中设计模式分析
		Spring 中使用的设计模式也很多，比如工厂模式、单例模式、模版模式、代理模式、策略模式等。
	代理模式原理
		代理模式就是给某一个对象创建一个代理对象，而由这个代理对象控制对原对象的引用，
			而创建这个代理对象就是可以在调用原对象时增加一些额外的操作。
		代理模式的结构
			Subject：抽象主题，它是代理对象的真实对象要实现的接口，当然这可以由多个接口组成。
			ProxySubject：代理类除了实现抽象主题定义的接口外，还必须持有所代理对象的引用
			RealSubject：被代理的类，是目标对象。
		Spring 中如何实现代理模式
			Spring Aop 中 Jdk 动态代理就是利用代理模式技术实现的。
			在 Spring 中除了实现被代理对象的接口外，
			还会有 org.springframework.aop.SpringProxy 和 org.springframework.aop.framework.Advised 两个接口。
		Spring 中使用代理模式的结构：
			$Proxy 就是创建的代理对象，而 Subject 是抽象主题，代理对象是通过 InvocationHandler 来持有对目标对象的引用的。

	策略模式原理
		策略模式顾名思义就是做某事的策略，这在编程上通常是指完成某个操作可能有多种方法，
			这些方法各有千秋，可能有不同的适应的场合，然而这些操作方法都有可能用到。
			各一个操作方法都当作一个实现策略，使用者可能根据需要选择合适的策略。
		下面是策略模式的结构：
			Context：使用不同策略的环境，它可以根据自身的条件选择不同的策略实现类来完成所要的操作。
				它持有一个策略实例的引用。创建具体策略对象的方法也可以由他完成。
			Strategy：抽象策略，定义每个策略都要实现的策略方法
			ConcreteStrategy：具体策略实现类，实现抽象策略中定义的策略方法
		Spring 中策略模式的实现
			Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。
			这里主要看一下代理对象创建的策略模式的实现。
			前面已经了解 Spring 的代理方式有两个 Jdk 动态代理和 CGLIB 代理。
			这两个代理方式的使用正是使用了策略模式。

	
Spring IOC 原理

	IOC 总结
	
		Spring IOC 容器主要有继承体系底层的 BeanFactory、高层的 ApplicationContext 和 WebApplicationContext；

		Bean 有自己的生命周期

		容器启动原理：
		
			Spring 应用的 IOC 容器通过 tomcat 的 Servlet 或 Listener 监听启动加载；
			Spring MVC 的容器由 DispatchServlet 作为入口加载；
			Spring 容器是 Spring MVC 容器的父容器

		容器加载 Bean 原理：

			BeanDefinitionReader 读取 Resource 所指向的配置文件资源，然后解析配置文件。
			配置文件中每一个解析成一个 BeanDefinition 对象，并保存到 BeanDefinitionRegistry 中；

			容器扫描 BeanDefinitionRegistry 中的 BeanDefinition；
			调用 InstantiationStrategy 进行 Bean 实例化的工作；
			使用 BeanWrapper 完成 Bean 属性的设置工作；

			单例 Bean 缓存池：
				Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，
				它是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。
			
			
	Spring 容器高层视图

		Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配置注册表，
		然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。

	IOC 容器介绍
		Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，
		利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。
		Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。
		BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；
		ApplicationContext 面向使用 Spring 框架的开发者，
		几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。

	BeanFactory
		BeanDefinitionRegistry：
		Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。
		而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。

		BeanFactory 接口位于类结构树的顶端，它最主要的方法就是 getBean(String beanName)，
		该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：

		ListableBeanFactory：
		该接口定义了访问容器中 Bean 基本信息的若干方法，
		如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；

		HierarchicalBeanFactory：
		父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 
		通过 HierarchicalBeanFactory 接口，Spring 的 IoC 容器可以建立父子层级关联的容器体系，
		子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。
		Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，
		展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。
		这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。

		ConfigurableBeanFactory：
		是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；

		AutowireCapableBeanFactory：
		定义了将容器中的 Bean 按某种规则 (如按名字匹配、按类型匹配等) 进行自动装配的方法；

		SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例 Bean 的方法；
		
		例子：
			使用 Spring 配置文件为 Car 提供配置信息：beans.xml：
			通过 BeanFactory 装载配置文件，启动 Spring IoC 容器：
			
			XmlBeanFactory 通过 Resource 装载 Spring 配置信息并启动 IoC 容器，
			然后就可以通过 BeanFactory#getBean(beanName) 方法从 IoC 容器中获取 Bean 了。
			通过 BeanFactory 启动 IoC 容器时，并不会初始化配置文件中定义的 Bean，初始化动作发生在第一个调用时。

			对于单实例 (singleton) 的 Bean 来说，BeanFactory 会缓存 Bean 实例，
			所以第二次使用 getBean() 获取 Bean 时将直接从 IoC 容器的缓存中获取 Bean 实例。
			Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，
			它是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。

			值得一提的是，在初始化 BeanFactory 时，必须为其提供一种日志框架，
			比如使用 Log4J，即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。

	ApplicationContext
		ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。
		在 BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。

		ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，
		在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：

			ClassPathXmlApplicationContext：默认从类路径加载配置文件

			FileSystemXmlApplicationContext：默认从文件系统中装载配置文件

			ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。在 ApplicationContext 抽象实现类 AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。

			MessageSource：为应用提供 i18n 国际化消息访问的功能；

			ResourcePatternResolver：所 有 ApplicationContext 实现类都实现了类似于 PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。

			LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start() 和 stop() 两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。

		ConfigurableApplicationContext 扩展于 ApplicationContext，
		它新增加了两个主要的方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。
			在应用上下文关闭的情况下调用 refresh() 即可启动应用上下文，在已经启动的状态下，
			调用 refresh() 则清除缓存并重新装载配置信息，而调用 close() 则可关闭应用上下文。
			这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。

		使用：
			如果配置文件放置在类路径下，用户可以优先使用 ClassPathXmlApplicationContext 实现类：

			如果配置文件放置在文件系统的路径下，则可以优先考虑使用 FileSystemXmlApplicationContext 实现类：

			Spring 3.0 支持基于类注解的配置方式，主要功能来自于 Spring 的一个名为 JavaConfig 子项目，
			目前 JavaConfig 已经升级为 Spring 核心框架的一部分。

			ApplicationContext 在初始化应用上下文时就实例化所有单实例的 Bean。

	WebApplicationContext

		WebApplication 体系架构：

			WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。
			从 WebApplicationContext 中可以获得 ServletContext 的引用，
			整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。
			WebApplicationContext 定义了一个常量 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，
			在上下文启动时，WebApplicationContext 实例即以此为键放置在 ServletContext 的属性列表中，
			因此我们可以直接通过以下语句从 Web 容器中获取 WebApplicationContext：

		Spring 和 Web 应用的上下文融合：

			WebApplicationContext 的初始化方式：WebApplicationContext 需要 ServletContext 实例，
			它必须在拥有 Web 容器的前提下才能完成启动的工作。
			可以在 web.xml 中配置自启动的 Servlet 或定义 Web 容器监听器 (ServletContextListener) ，
			借助这两者中的任何一个就可以完成启动 Spring Web 应用上下文的工作。
			Spring 分别提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器：
				org.springframework.web.context.ContextLoaderServlet；
				org.springframework.web.context.ContextLoaderListener。

			由于 WebApplicationContext 需要使用日志功能，比如日志框架使用 Log4J，
			用	户可以将 Log4J 的配置文件放置到类路径 WEB-INF/classes 下，这时 Log4J 引擎即可顺利启动。
			如果 Log4J 配置文件放置在其他位置，用户还必须在 web.xml 指定 Log4J 配置文件位置。

	Bean 的生命周期
		1．当调用者通过 getBean(beanName) 向容器请求某一个 Bean 时，
			如果容器注册了 org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 接口，
			在实例化 Bean 之前，将调用接口的 postProcessBeforeInstantiation() 方法；

		2．根据配置情况调用 Bean 构造函数或工厂方法实例化 Bean；

		3．如果容器注册了 InstantiationAwareBeanPostProcessor 接口，在实例化 Bean 之后，
			调用该接口的 postProcessAfterInstantiation() 方法，可在这里对已经实例化的对象进行一些“梳妆打扮”；

		4．如果 Bean 配置了属性信息，容器在这一步着手将配置值设置到 Bean 对应的属性中，
		不过在设置每个属性之前将先调用 InstantiationAwareBeanPostProcessor 接口的 postProcessPropertyValues() 方法；

		5．调用 Bean 的属性设置方法设置属性值；

		6．如果 Bean 实现了 org.springframework.beans.factory.BeanNameAware 接口，
			将调用 setBeanName() 接口方法，将配置文件中该 Bean 对应的名称设置到 Bean 中；

		7．如果 Bean 实现了 org.springframework.beans.factory.BeanFactoryAware 接口，
			将调用 setBeanFactory() 接口方法，将 BeanFactory 容器实例设置到 Bean 中；

		8．如果 BeanFactory 装配了 org.springframework.beans.factory.config.BeanPostProcessor 后处理器，
			将调用 BeanPostProcessor 的 Object postProcessBeforeInitialization(Object bean, String beanName) 接口方法对 Bean 进行加工操作。
			其中入参 bean 是当前正在处理的 Bean，而 beanName 是当前 Bean 的配置名，返回的对象为加工处理后的 Bean。
			用户可以使用该方法对某些 Bean 进行特殊的处理，甚至改变 Bean 的行为，
			BeanPostProcessor 在 Spring 框架中占有重要的地位，为容器提供对 Bean 进行后续加工处理的切入点，
			Spring 容器所提供的各种“神奇功能” (如 AOP，动态代理等) 都通过 BeanPostProcessor 实施；

		9．如果 Bean 实现了 InitializingBean 的接口，将调用接口的 afterPropertiesSet() 方法；

		10．如果在通过 init-method 属性定义了初始化方法，将执行这个方法；

		11．BeanPostProcessor 后处理器定义了两个方法：
			其一是 postProcessBeforeInitialization() 在第 8 步调用；
			其二是 Object postProcessAfterInitialization(Object bean, String beanName) 方法，
			这个方法在此时调用，容器再次获得对 Bean 进行加工处理的机会；

		12．如果在中指定 Bean 的作用范围为 scope=“prototype”，将 Bean 返回给调用者，
			调用者负责 Bean 后续生命的管理，Spring 不再管理这个 Bean 的生命周期。
			如果作用范围设置为 scope=“singleton”，则将 Bean 放入到 Spring IoC 容器的缓存池中，
			并将 Bean 引用返回给调用者，Spring 继续对这些 Bean 进行后续的生命管理；

		13．对于 scope=“singleton”的 Bean，当容器关闭时，将触发 Spring 对 Bean 的后续生命周期的管理工作，
			首先如果 Bean 实现了 DisposableBean 接口，则将调用接口的 afterPropertiesSet() 方法，
			可以在此编写释放资源、记录日志等操作；

		14．对于 scope=“singleton”的 Bean，如果通过的 destroy-method 属性指定了 Bean 的销毁方法，
			Spring 将执行 Bean 的这个方法，完成 Bean 资源的释放等操作。

	可以将这些方法大致划分为三类：

		Bean 自身的方法：
			如调用 Bean 构造函数实例化 Bean，
			调用 Setter 设置 Bean 的属性值以及通过的 init-method 和 destroy-method 所指定的方法；

		Bean 级生命周期接口方法：
			如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，
			这些接口方法由 Bean 类直接实现；

		容器级生命周期接口方法：
			在上图中带“★”的步骤是由 InstantiationAwareBean PostProcessor 和 BeanPostProcessor 这两个接口实现，
			一般称它们的实现类为“后处理器”。
			后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，
			实现类以容器附加装置的形式注册到 Spring 容器中并通过接口反射为 Spring 容器预先识别。
			当 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。
			当然，用户可以通过合理地编写后处理器，让其仅对感兴趣 Bean 进行加工处理

	ApplicationContext 和 BeanFactory 另一个最大的不同之处在于：
		ApplicationContext 会利用 Java 反射机制自动识别出配置文件中定义的 BeanPostProcessor、 InstantiationAwareBeanPostProcessor 和 BeanFactoryPostProcessor，并自动将它们注册到应用上下文中；
		而后者需要在代码中通过手工调用 addBeanPostProcessor() 方法进行注册。
		这也是为什么在应用开发时，我们普遍使用 ApplicationContext 而很少使用 BeanFactory 的原因之一。


IOC 容器工作机制

	容器启动过程

	web 环境下 Spring 容器、SpringMVC 容器启动过程：

		首先，对于一个 web 应用，其部署在 web 容器中，web 容器提供其一个全局的上下文环境，
		这个上下文就是 ServletContext，为后面的 spring IoC 容器提供宿主环境；

		其次，在 web.xml 中会提供有 contextLoaderListener (或 ContextLoaderServlet) 。
		在 web 容器启动时，会触发容器初始化事件，此时 contextLoaderListener 会监听到这个事件，
		其 contextInitialized 方法会被调用，在这个方法中，spring 会初始化一个启动上下文，
		这个上下文被称为根上下文，即 WebApplicationContext，
		这是一个接口类，确切的说，其实际的实现类是 XmlWebApplicationContext。
		这个就是 spring 的 IoC 容器，其对应的 Bean 定义的配置由 web.xml 中的 context-param 标签指定。
		在这个 IoC 容器初始化完毕后，
		spring 容器以 WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 为属性 Key，
		将其存储到 ServletContext 中，便于获取；

		再次，contextLoaderListener 监听器初始化完毕后，开始初始化 web.xml 中配置的 Servlet，
		这个 servlet 可以配置多个，以最常见的 DispatcherServlet 为例 (Spring MVC) ，
		这个 servlet 实际上是一个标准的前端控制器，用以转发、匹配、处理每个 servlet 请求。
		DispatcherServlet 上下文在初始化的时候会建立自己的 IoC 上下文容器，用以持有 spring mvc 相关的 bean，
		这个 servlet 自己持有的上下文默认实现类也是 XmlWebApplicationContext。
		在建立 DispatcherServlet 自己的 IoC 上下文时，会利用 WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 先从 ServletContext 中获取之前的根上下文 (即 WebApplicationContext) 作为自己上下文的 parent 上下文 (即第 2 步中初始化的 XmlWebApplicationContext 作为自己的父容器) 。
		有了这个 parent 上下文之后，再初始化自己持有的上下文 (这个 DispatcherServlet 初始化自己上下文的工作在其 initStrategies 方法中可以看到，大概的工作就是初始化处理器映射、视图解析等) 。
		初始化完毕后，spring 以与 servlet 的名字相关 (此处不是简单的以 servlet 名为 Key，而是通过一些转换) 的属性为属性 Key，也将其存到 ServletContext 中，以便后续使用。
		这样每个 servlet 就持有自己的上下文，即拥有自己独立的 bean 空间，同时各个 servlet 共享相同的 bean，即根上下文定义的那些 bean。


	Bean 加载过程

		Spring 的高明之处在于，它使用众多接口描绘出了所有装置的蓝图，构建好 Spring 的骨架，
		继而通过继承体系层层推演，不断丰富，最终让 Spring 成为有血有肉的完整的框架。
		所以查看 Spring 框架的源码时，有两条清晰可见的脉络：

			1) 接口层描述了容器的重要组件及组件间的协作关系；
			2) 继承体系逐步实现组件的各项功能。

		接口层清晰地勾勒出 Spring 框架的高层功能，框架脉络呼之欲出。
		有了接口层抽象的描述后，不但 Spring 自己可以提供具体的实现，任何第三方组织也可以提供不同实现，可以说 Spring 完善的接口层使框架的扩展性得到了很好的保证。
		纵向继承体系的逐步扩展，分步骤地实现框架的功能，
		这种实现方案保证了框架功能不会堆积在某些类的身上，造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。

		Spring 组件按其所承担的角色可以划分为两类：

			1) 物料组件：Resource、BeanDefinition、PropertyEditor 以及最终的 Bean 等，
			它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料；

				BeanDefinition：Spring 通过 BeanDefinition 将配置文件中的配置信息转换为容器的内部表示，
				并将这些 BeanDefinition 注册到 BeanDefinitionRegistry 中。
				Spring 容器的后续操作直接从 BeanDefinitionRegistry 中读取配置信息。
			2) 加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy 以及 BeanWrapper 等组件像是流水线上不同环节的加工设备，对物料组件进行加工处理。

				InstantiationStrategy：
				负责实例化 Bean 操作，相当于 Java 语言中 new 的功能，并不会参与 Bean 属性的配置工作。
				属性填充工作留待 BeanWrapper 完成

				BeanWrapper：继承了 PropertyAccessor 和 PropertyEditorRegistry 接口，
				BeanWrapperImpl 内部封装了两类组件： (1) 被封装的目标 Bean (2) 一套用于设置 Bean 属性的属性编辑器；
				具有三重身份： (1) Bean 包裹器 (2) 属性访问器 (3) 属性编辑器注册表。
				PropertyAccessor：定义了各种访问 Bean 属性的方法。
				PropertyEditorRegistry：属性编辑器的注册表

		Spring 容器从加载配置文件到创建出一个完整 Bean 的作业流程：

			１、ResourceLoader 从存储介质中加载 Spring 配置信息，并使用 Resource 表示这个配置文件的资源；

			２、BeanDefinitionReader 读取 Resource 所指向的配置文件资源，然后解析配置文件。
			配置文件中每一个解析成一个 BeanDefinition 对象，并保存到 BeanDefinitionRegistry 中；

			３、容器扫描 BeanDefinitionRegistry 中的 BeanDefinition，
			使用 Java 的反射机制自动识别出 Bean 工厂后处理后器 (实现 BeanFactoryPostProcessor 接口) 的 Bean，
			然后调用这些 Bean 工厂后处理器对 BeanDefinitionRegistry 中的 BeanDefinition 进行加工处理。

				主要完成以下两项工作：

					1) 对使用到占位符的元素标签进行解析，得到最终的配置值，
					这意味对一些半成品式的 BeanDefinition 对象进行加工处理并得到成品的 BeanDefinition 对象；

					2) 对 BeanDefinitionRegistry 中的 BeanDefinition 进行扫描，
					通过 Java 反射机制找出所有属性编辑器的 Bean (实现 java.beans.PropertyEditor 接口的 Bean) ，
					并自动将它们注册到 Spring 容器的属性编辑器注册表中 (PropertyEditorRegistry) ；

			4．Spring 容器从 BeanDefinitionRegistry 中取出加工后的 BeanDefinition，
			并调用 InstantiationStrategy 着手进行 Bean 实例化的工作；

			5．在实例化 Bean 时，Spring 容器使用 BeanWrapper 对 Bean 进行封装，
			BeanWrapper 提供了很多以 Java 反射机制操作 Bean 的方法，
			它将结合该 Bean 的 BeanDefinition 以及容器中属性编辑器，完成 Bean 属性的设置工作；

			6．利用容器中注册的 Bean 后处理器 (实现 BeanPostProcessor 接口的 Bean) 对已经完成属性设置工作的 Bean 进行后续加工，
			直接装配出一个准备就绪的 Bean。




