
Spring Boot 备忘录


Spring Boot 核心

	是什么：
		伴随 Spring 4.0 诞生；
		内嵌 Web 容器的可执行程序框架。
		
		
	为什么使用：
		配置更简单；
			比如同样是 web 框架，Spring Boot 比 SpringMVC 少了很多导入包和 xml 配置；
		编码更简单；
			配置注解化；
		部署更简单；
			每个 Spring Boot 项目自带 Web 容器；
		监控更简单；
			支持 HTTP 加路径的方式管理和监控项目；
			支持可视化的 Spring Boot Admin。
		
	基本原理：
		
		
	怎么使用：
		@SpringBootApplication：
			相当于 EnableAutoConfiguration + @ComponentScan。
		@SpringBootConfiguration：
			和 @Configuration 功能一样；
			用来代替 xml 配置中的 bean 标签。
		@EnableAutoConfiguration
			自动加载 jar 的默认配置。
		@ComponentScan：
			自动扫描
		@RestController：
			相当于 @Controller + @ResponseBody
		@Controller：
			控制器类；
		@ResponseBody：
			返回参数转成 json 格式的字符串。
		@RequestMapping：
			请求映射路径；
		@Value：
			配置文件中定义的变量。
		@ControllerAdvice：	
			
			
			
			
			
			
			
			
			
			
			
		
	Spring Boot 
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		

@Autowired 与 @Resource：

	1、@Autowired 与 @Resource 都可以用来装配 bean. 都可以写在字段上, 或写在 setter 方法上。

	2、@Autowired 默认按类型装配 (这个注解是属业 spring 的) ，
	默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false，
		如：
		@Autowired(required=false)，如果我们想使用名称装配可以结合 @Qualifier 注解进行使用，
		如下：
		Java 代码
		@Autowired() @Qualifier("baseDao") 
		private BaseDao baseDao;

	3、@Resource 是 JDK1.6 支持的注解，默认按照名称进行装配，
		名称可以通过 name 属性进行指定，
		如果没有指定 name 属性，当注解写在字段上时，默认取字段名，按照名称查找，
		如果注解写在 setter 方法上默认取属性名进行装配。
		当找不到与名称匹配的 bean 时才按照类型进行装配。
		但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。

		只不过注解处理器我们使用的是 Spring 提供的，是一样的，无所谓解耦不解耦的说法，两个在便利程度上是等同的。

	他们的主要区别就是：
		@Autowired 是默认按照类型装配的
		@Resource 默认是按照名称装配的
		
		byName 通过参数名自动装配，如
			果一个 bean 的 name 和另外一个 bean 的 property 相同，就自动装配。
		byType 通过参数的数据类型自动自动装配，
			如果一个 bean 的数据类型和另外一个 bean 的 property 属性的数据类型兼容，就自动装配
		-----------------------------------------------------------------------------------------------------------------------------------------
		我们可以通过 @Autowired 或 @Resource 在 Bean 类中使用自动注入功能，但是 Bean 还是在 XML 文件中通过 <bean> 进行定义 —— 也就是说，在 XML 配置文件中定义 Bean，通过 @Autowired 或 @Resource 为 Bean 的成员变量、方法入参或构造函数入参提供自动注入的功能。









Spring Boot 基础

	注解：
		@Controller					所在类为控制器，由于数量多，建子包集中保存。
		@EnableAutoConfiguration		开启自动配置，是 springboot 的启动注解配置。
		@RequestMapping("/") 		设置 URL 映射路径
		@ResponseBody				Restful 架构中，将返回的数据以字符串或 json 形式接收
		
		@ComponentScan				定义扫描路径
		@SpringBootApplication			启动 SpringBoot 程序，自带子包扫描。
			@SpringBootApplication = @EnableAutoConfiguration + @ComponentScan + 其他。
		@ConfigrationProperties			参数绑定标签
		@Getter@Setter@ToString		方法替代
		@Bean
		@Component 				扫描
		@MapperScan				扫描 mapper 接口
		
		@EnableTransactionManagement	开启事务注解驱动支持 (主配置类中) 
		@Transaction					指定开启事务
		@ImportResource				引入事务配置文件 (applicationContext.xml) 
		@ControllerAdviece			自定义异常处理类
		@ExceptionHandler			异常处理方法
		
		
			
	建议：
		所有程序类，放在启动类所在包的子包下。

	依赖库：
		springloaded
		spring-boot-devtools
		
	内置对象：
		HttpServletRequest
		HttpServletResponse

	网贷项目：
		website：打包成 war，项目前台；
		mgrsite：打包成 war，项目后台。
		优化：
		core：打包成 jar，提前安装到仓库中，供前台和后台项目引用；
			是 website，mgrsite 项目的公共文件的抽取。
		进一步优化：
		parent：打包类型为 pom.xml。
			不存放任何代码，专门用来管理多个项目之间的公共依赖；
			子项目中使用 parent 标签，来表示和父项目之间的继承关系；
			子项目之间的依赖关系交给父项目 pom 管理，方便维护。
		
	参数设置：
		通过 @Autowired 注入 ApplicationArguments 对象。
		来源：命令行；ServletConfig 和 ServletContext；系统环境变量；
			application.properties；YAML 文件
		
		application.properties 加载路径：
			当前目录的 config 子目录；
			当前目录；
			classpath 下的 config 子目录；
			classpath。
		修改配置：
			--spring.config.name：修改 application.properties 名称；
				如：--spring.config.name=application1。
			--spring.config.location：修改加载地址。
		
	参数绑定：
		@ConfigrationProperties 参数绑定标签；prefix=前缀，点号隔开
		@PropertySource 加载文件到内存中，不解析表达式
		@PropertySourcesPlaceholderConfigurer 解析 ${} 表达式，把内存中对应的值注入到对象中
		
	热部署：
		依赖中的 option 标签：属性为 true 表示阻止依赖传递；
		
	mybatis 集成：
		mybatis.configLocation：配置文件地址；
		mybatis.mapperLocation：映射文件地址；
		mybatis.typeAliasesPackage：别名扫描包。
		logging.level. 全包名=debug：输出 SQL 执行语句。
		build 标签中 resource 配置：把 xml 文件加载到 classes 目录。
		
	事务集成：
		注解方式：
			@EnableTransactionManagement	开启事务注解驱动支持 (主配置类中) 
			@Transaction					指定开启事务
		xml 方式：
			添加依赖 (用于支持 AspectJ 表达式) 
			添加 applicationContext-tx.xml 配置文件
			主配置类中我添加事务管理器：	PlatformTransactionManager 类。
			引入 applicationContext-tx.xml 文件：	@ImportResource。
			
	自动装配原理：
		
		
	静态资源：
		默认加载路径：
			classpath 下的 static, public, resources, META-INFO/resources。
		修改加载地址：
			spring.resources-location=classpath：
		
	FreeMarker：
		Springboot 对 JSP 支持不好；
		SpringMVC 和 Freemarker 集成；
			引入 spring-boot-starter-freemarker；
			Springboot 配置 freemarker：
				spring.freemarker.expose-session-attributes。
			
	统一异常处理：
		默认把所有错误重新定位到 error 这个处理路径，由 BasicErrorController 类完成处理
		默认结构：src/resources/public/error/4xx.html
		
	servlet：
		server.prot：定制监听端口；
		server.session.timeout：session 有效时间；
		servlet 注册方式：
			配置类添加 @ServletComponentScan，自动扫描 @WebServlet @WebFilter @WebListener 类
			创建 ServletListenerRegistrationBean ServletRegistrationBean FilterRegistrationBean 完成注册
		
	文件上传：
		使用 Servlet3 中的 Part 对象完成上传
		上传配置：
			spring.http.multipart.enabled=true：允许文件上传；
			spring.http.multipart.maxFileSize=1MB：最大单文件上传大小；
			spring.http.multipart.maxRequestSize=10MB：最大请求大小。
		上传路径：
			通过配置 spring.resources.static-locations 完成资源位置映射。
			file.path=D：/upload/
		
	拦截器：
		主配置类继承 WebMvcConfigurerAdapter 类；
		重写 addInterceptor 方法。
		拦截器类继承 HandlerInterceptorAdaptor ；
		重写 preHandle 方法。
	
	
	
Spring Boot 常用注解
	
	@RestController：
		被称为一个构造型 (stereotype) 注解。它为阅读代码的开发人员提供建议。
		对于 Spring，该类扮演了一个特殊角色。它继承自 @Controller 注解。
		4.0 之前的版本，spring MVC 的组件都使用 @Controller 来标识当前类是一个控制器 servlet。
		使用这个特性，我们可以开发 REST 服务的时候不需要使用 @Controller 而专门的 @RestController。

		实例：在本实例中，Example 的类是一个 web @Controller，所以当处理进来的 web 请求时，Spring 会询问它。
			import org.springframework.boot.*;
			import org.springframework.boot.autoconfigure.*;
			import org.springframework.stereotype.*;
			import org.springframework.web.bind.annotation.*;
			@RestController
			@EnableAutoConfiguration
			public class Example {
				@RequestMapping("/")
				String home() {
				return "Hello World!";
				}
				public static void main(String[] args) throws Exception {
				SpringApplication.run(Example.class, args);
				}
			}
	
	@RequestMapping：
		注解提供路由信息。它告诉 Spring 任何来自"/"路径的 HTTP 请求都应该被映射到 home 方法。
		@RestController 注解告诉 Spring 以字符串的形式渲染结果，并直接返回给调用者。该注解有六个属性： 

			params：指定 request 中必须包含某些参数值是，才让该方法处理。

			headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。

			value：指定请求的实际地址，指定的地址可以是 URI Template 模式

			method：指定请求的 method 类型，GET、POST、PUT、DELETE 等

			consumes：指定处理请求的提交内容类型 (Content-Type) ，如 application/json,text/html

			produces：指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回

		实例：
			@RequestMapping(“/test”) 
			@ResponseBody 
			public String test(){ 
				return”ok”; 
			}
		注意：@RestController 和 @RequestMapping 注解是 Spring MVC 注解 (它们不是 Spring Boot 的特定部分) 



	@EnableAutoConfiguration
		第二个类级别的注解是 @EnableAutoConfiguration。
		这个注解告诉 Spring Boot 根据添加的 jar 依赖猜测你想如何配置 Spring。
		
		由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，
		所以 auto-configuration 将假定正在开发一个 web 应用并相应地对 Spring 进行设置。
		Starter POMs 和 Auto-Configuration 设计 auto-configuration 的目的是更好的使用"Starter POMs"，但这两个概念没有直接的联系。
		可以自由地挑选 starter POMs 以外的 jar 依赖，并且 Spring Boot 将仍旧尽最大努力去自动配置你的应用。

		你可以通过将 @EnableAutoConfiguration 或 @SpringBootApplication 注解添加到一个 @Configuration 类上来选择自动配置。
		注意：只需要添加一个 @EnableAutoConfiguration 注解。
			建议将它添加到主 @Configuration 类上，
			如果发现应用不想要的特定自动配置类，可以使用 @EnableAutoConfiguration 注解的排除属性来禁用它们。
				import org.springframework.boot.autoconfigure.*; 
				import org.springframework.boot.autoconfigure.jdbc.*; 
				import org.springframework.context.annotation.*; 
				@Configuration 
				@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) 
				public class MyConfiguration { 
					// ... 
				}


	@Configuration
		Spring Boot 提倡基于 Java 的配置。
		尽管可以使用一个 XML 源来调用 SpringApplication.run()，但官方建议使用 @Configuration 类作为主要源。
		
		一般定义 main 方法的类也是主要 @Configuration 的一个很好候选。不需要将所有的 @Configuration 放进一个单独的类。
		@Import 注解可以用来导入其他配置类。另外也可以使用 @ComponentScan 注解自动收集所有的 Spring 组件，包括 @Configuration 类。

		如果需要使用基于 XML 的配置，官方建议仍旧从一个 @Configuration 类开始。可以使用附加的 @ImportResource 注解加载 XML 配置文件。

		@Configuration 注解该类，等价与 XML 中配置 beans；用 @Bean 标注方法等价于 XML 中配置 bean。

		@ComponentScan(basePackages = "com.yoodb.blog",includeFilters = {@ComponentScan.Filter(Aspect.class)})
		@ComponentScan：表示将该类自动发现扫描组件。
		如果扫描到有 @Component、@Controller、@Service 等这些注解的类，并注册为 Bean，
		可以自动收集所有的 Spring 组件，包括 @Configuration 类。
		使用 @ComponentScan 注解搜索 beans，并结合 @Autowired 注解导入。
		可以自动收集所有的 Spring 组件，包括 @Configuration 类。如果没有配置，Spring Boot 会扫描启动类所在包下以及子包下的使用了 @Service,@Repository 等注解的类。

	@SpringBootApplication

		很多 Spring Boot 开发者总是使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan 注解他们的 main 类。
		由于这些注解被如此频繁地一块使用 (特别是你遵循以上最佳实践时) ，Spring Boot 提供一个方便的 @SpringBootApplication 选择。
		该 @SpringBootApplication 注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan。

			import org.springframework.boot.SpringApplication; 
			import org.springframework.boot.autoconfigure.SpringBootApplication; 
			@SpringBootApplication // 等同于 @Configuration @EnableAutoConfiguration @ComponentScan 
			public class Application { 
				public static void main(String[] args) { 
				SpringApplication.run(Application.class, args); 
				} 
			}
			Spring Boot 将尝试校验外部的配置，默认使用 JSR-303 (如果在 classpath 路径中) 。可以轻松的为 @ConfigurationProperties 类添加 JSR-303 javax.validation 约束注解：

			@Component 
			@ConfigurationProperties(prefix="connection") 
			public class ConnectionSettings { 
				@NotNull 
				private InetAddress remoteAddress; 
				// ... getters and setters 
			}

	@Profiles

		Spring Profiles 提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。
		任何 @Component 或 @Configuration 都能被 @Profile 标记，从而限制加载它的时机。

			@Configuration 
			@Profile("production") 
			public class ProductionConfiguration { 
				// ... 
			}

	全局异常处理

		@ControllerAdvice：包含 @Component。可以被扫描到。统一处理异常。
		@ExceptionHandler (Exception.class) ：用在方法上面表示遇到这个异常就执行以下方法。
				/** 
				 * 全局异常处理 
				 */ 
				@ControllerAdvice 
				public class GlobalDefaultExceptionHandler { 
					public static final String DEFAULT_ERROR_VIEW = "error"; 
					@ExceptionHandler({TypeMismatchException.class,NumberFormatException.class}) 
					public ModelAndView formatErrorHandler(HttpServletRequest req, Exception e) throws Exception { 
					ModelAndView mav = new ModelAndView(); 
					mav.addObject("error","参数类型错误"); 
					mav.addObject("exception", e); 
					mav.addObject("url", RequestUtils.getCompleteRequestUrl(req)); 
					mav.addObject("timestamp", new Date()); 
					mav.setViewName(DEFAULT_ERROR_VIEW); 
					return mav; 
					}
				}
			通过 @value 注解来读取 application.properties 里面的配置，使用实例参考：
				/************** application.properties *************/
				qq_api_key=********1***********
				qq_api_secrt=******2***********

				/************* Java **************/
				@Value("${qq_api_key}") 
				private String API_KEY; 

				@Value("${qq_api_secrt}") 
				private String API_SECRET;
			注意：
				使用 @Value 注解的时其使用的类如果被其他类作为对象引用，
				必须要使用注入的方式而不能 new，一般常用的配置在 application.properties 文件。

	其他注解

		@ResponseBody：
			表示该方法的返回结果直接写入 HTTP response body 中一般在异步获取数据时使用，在使用 @RequestMapping 后，
			返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。
			如异步获取 json 数据，加上 @Responsebody 后，会直接返回 json 数据。

		@Component：
			泛指组件，当组件不好归类时，可以使用这个注解进行标注。一般公共的方法会用上这个注解

		@RequestParam：
			用在方法的参数前面，
			实例：@RequestParam String a =request.getParameter("a");

		@PathVariable：
			路径变量注解，其参数与大括号里的名字一样要保持一致，
			实例：
				RequestMapping("yoodb/detail/{id}") 
				public String getByMacAddress(@PathVariable String id){ 
					//do something; 
				}

		@Inject：
			等价于默认的 @Autowired，只是没有 required 属性。

		@Bean：
			相当于 XML 中的, 放在方法的上面，而不是类，意思是产生一个 bean, 并交给 spring 管理。
			
		@AutoWired：
			自动导入依赖的 bean。byType 方式。
			把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。
			当加上 (required=false) 时，就算找不到 bean 也不报错。

		@Qualifier：
			当有多个同一类型的 Bean 时，可以用 @Qualifier(“name”) 来指定。与 @Autowired 配合使用。
			@Qualifier 限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，
			具体使用方式如下：
				@Autowired 
				@Qualifier(value = "demoInfoService") 
				private DemoInfoService demoInfoService;
				@Resource(name="name",type="type")：没有括号内内容的话，默认 byName。与 @Autowired 类似。
	

Spring Boot 常用注解

	@RestController 和 @RequestMapping 注解

		4.0 重要的一个新的改进是 @RestController 注解，它继承自 @Controller 注解。
		4.0 之前的版本，Spring MVC 的组件都使用 @Controller 来标识当前类是一个控制器 servlet。
		使用这个特性，我们可以开发 REST 服务的时候不需要使用 @Controller 而专门的 @RestController。

		 当你实现一个 RESTful web services 的时候，response 将一直通过 response body 发送。
		 为了简化开发，Spring 4.0 提供了一个专门版本的 controller。
		 
		 下面我们来看看 @RestController 实现的定义：
			@Target(value=TYPE) 
			@Retention(value=RUNTIME) 
			@Documented 
			@Controller 
			@ResponseBody 
			public @interface RestController 

		@RequestMapping 注解提供路由信息。它告诉 Spring 任何来自"/"路径的 HTTP 请求都应该被映射到 home 方法。
		@RestController 注解告诉 Spring 以字符串的形式渲染结果，并直接返回给调用者。

			注： @RestController 和 @RequestMapping 注解是 Spring MVC 注解 (它们不是 Spring Boot 的特定部分) 

	@EnableAutoConfiguration 注解

		第二个类级别的注解是 @EnableAutoConfiguration。
		这个注解告诉 Spring Boot 根据添加的 jar 依赖猜测你想如何配置 Spring。
		由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，
			所以 auto-configuration 将假定你正在开发一个 web 应用并相应地对 Spring 进行设置。
		Starter POMs 和 Auto-Configuration：设计 auto-configuration 的目的是更好的使用"Starter POMs"，但这两个概念没有直接的联系。
		你可以自由地挑选 starter POMs 以外的 jar 依赖，并且 Spring Boot 将仍旧尽最大努力去自动配置你的应用。

		你可以通过将 @EnableAutoConfiguration 或 @SpringBootApplication 注解添加到一个 @Configuration 类上来选择自动配置。
		注：你只需要添加一个 @EnableAutoConfiguration 注解。我们建议你将它添加到主 @Configuration 类上。

		如果发现应用了你不想要的特定自动配置类，你可以使用 @EnableAutoConfiguration 注解的排除属性来禁用它们。
			<pre name="code" class="java">import org.springframework.boot.autoconfigure.*;
			import org.springframework.boot.autoconfigure.jdbc.*;
			import org.springframework.context.annotation.*;
			@Configuration
			@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
			public class MyConfiguration {
			}
	
	@Configuration

		Spring Boot 提倡基于 Java 的配置。
		尽管你可以使用一个 XML 源来调用 SpringApplication.run()，我们通常建议你使用 @Configuration 类作为主要源。
		一般定义 main 方法的类也是主要 @Configuration 的一个很好候选。
		你不需要将所有的 @Configuration 放进一个单独的类。
		@Import 注解可以用来导入其他配置类。
		另外，你也可以使用 @ComponentScan 注解自动收集所有的 Spring 组件，包括 @Configuration 类。

		如果你绝对需要使用基于 XML 的配置，我们建议你仍旧从一个 @Configuration 类开始。
		你可以使用附加的 @ImportResource 注解加载 XML 配置文件。

		@Configuration 注解该类，等价 与 XML 中配置 beans；用 @Bean 标注方法等价于 XML 中配置 bean

		@ComponentScan(basePackages = "com.hyxt",includeFilters = {@ComponentScan.Filter(Aspect.class)})

	@SpringBootApplication

		很多 Spring Boot 开发者总是使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan 注解他们的 main 类。
		由于这些注解被如此频繁地一块使用 (特别是你遵循以上最佳实践时) ，Spring Boot 提供一个方便的 @SpringBootApplication 选择。
		该 @SpringBootApplication 注解等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan。
			package com.example.myproject;
			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;
			@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
			public class Application {
				public static void main(String[] args) {
				SpringApplication.run(Application.class, args);
				}
			}

		Spring Boot 将尝试校验外部的配置，默认使用 JSR-303 (如果在 classpath 路径中) 。
		你可以轻松的为你的 @ConfigurationProperties 类添加 JSR-303 javax.validation 约束注解：
			@Component
			@ConfigurationProperties(prefix="connection")
			public class ConnectionSettings {
				@NotNull
				private InetAddress remoteAddress;
				// ... getters and setters
			}

	@Profiles

		Spring Profiles 提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。
		任何 @Component 或 @Configuration 都能被 @Profile 标记，从而限制加载它的时机。
			@Configuration
			@Profile("production")
			public class ProductionConfiguration {
				// ...
			}
	
	@ResponseBody
		表示该方法的返回结果直接写入 HTTP response body 中：
		一般在异步获取数据时使用，在使用 @RequestMapping 后，返回值通常解析为跳转路径，
		加上 @responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。
		比如
		异步获取 json 数据，加上 @responsebody 后，会直接返回 json 数据。


	@Component：
		泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。一般公共的方法我会用上这个注解

	@AutoWired
		byType 方式。把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构
		造函数进行标注，完成自动装配的工作。
		当加上 (required=false) 时，就算找不到 bean 也不报错。

	@RequestParam：
		用在方法的参数前面。
		@RequestParam String a =request.getParameter("a")。

	@PathVariable:
		路径变量。
			RequestMapping("user/get/mac/{macAddress}")
			public String getByMacAddress(@PathVariable String macAddress){
				//do something;
			}
		参数与大括号里的名字一样要相同。
			以上注解的示范
				/**
				 * 用户进行评论及对评论进行管理的 Controller 类；
				 */
				@Controller
				@RequestMapping("/msgCenter")
				public class MyCommentController extends BaseController {
					@Autowired
					CommentService commentService;
					@Autowired
					OperatorService operatorService;

					/**
					 * 添加活动评论；
					 *
					 * @param applyId 活动 ID；
					 * @param content 评论内容；
					 * @return
					 */
					@ResponseBody
					@RequestMapping("/addComment")
					public Map<String, Object> addComment(@RequestParam("applyId") Integer applyId, @RequestParam("content") String content) {
					....
					return result;
					}
				}

				 @RequestMapping("/list/{applyId}")
					public String list(@PathVariable Long applyId, HttpServletRequest request, ModelMap modelMap) {
				}

	全局处理异常的：
		@ControllerAdvice：
			包含 @Component。可以被扫描到。
			统一处理异常。

		@ExceptionHandler (Exception.class) ：
			用在方法上面表示遇到这个异常就执行以下方法。
				/**
				 * 全局异常处理
				 */
				@ControllerAdvice
				class GlobalDefaultExceptionHandler {
					public static final String DEFAULT_ERROR_VIEW = "error";
					@ExceptionHandler({TypeMismatchException.class,NumberFormatException.class})
					public ModelAndView formatErrorHandler(HttpServletRequest req, Exception e) throws Exception {
					ModelAndView mav = new ModelAndView();
					mav.addObject("error","参数类型错误");
					mav.addObject("exception", e);
					mav.addObject("url", RequestUtils.getCompleteRequestUrl(req));
					mav.addObject("timestamp", new Date());
					mav.setViewName(DEFAULT_ERROR_VIEW);
					return mav;
					}}
			通过 @value 注解来读取 application.properties 里面的配置
				# face++ key
				face_api_key = R9Z3Vxc7ZcxfewgVrjOyrvu1d-qR****
				face_api_secret =D9WUQGCYLvOCIdsbX35uTH********
				@Value("${face_api_key}")
				private String API_KEY;
				@Value("${face_api_secret}")
				private String API_SECRET;
			注意：
			使用這個注解的时候 使用 @Value 的类如果被其他类作为对象引用，必须要使用注入的方式，而不能 new。
			这个很重要，我就是被这个坑了。
			所以一般常用的配置都是配置在 application.properties 文件的。
	



	
